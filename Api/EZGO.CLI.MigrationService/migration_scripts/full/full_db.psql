/*
 Navicat PostgreSQL Data Transfer

 Source Server         : Local Postgres
 Source Server Type    : PostgreSQL
 Source Server Version : 120001
 Source Host           : localhost:5432
 Source Catalog        : ezgo_prod_17may
 Source Schema         : public

 Target Server Type    : PostgreSQL
 Target Server Version : 120001
 File Encoding         : 65001

 Date: 05/08/2021 14:30:14
*/


-- ----------------------------
-- Sequence structure for actions_action_assigned_areas_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."actions_action_assigned_areas_id_seq";
CREATE SEQUENCE "public"."actions_action_assigned_areas_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for actions_action_assigned_users_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."actions_action_assigned_users_id_seq";
CREATE SEQUENCE "public"."actions_action_assigned_users_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for actions_action_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."actions_action_id_seq";
CREATE SEQUENCE "public"."actions_action_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for actions_actioncomment_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."actions_actioncomment_id_seq";
CREATE SEQUENCE "public"."actions_actioncomment_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for actions_actioncommentviewed_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."actions_actioncommentviewed_id_seq";
CREATE SEQUENCE "public"."actions_actioncommentviewed_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for actions_actionviewed_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."actions_actionviewed_id_seq";
CREATE SEQUENCE "public"."actions_actionviewed_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for announcement_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."announcement_id_seq";
CREATE SEQUENCE "public"."announcement_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for auditproperty_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."auditproperty_id_seq";
CREATE SEQUENCE "public"."auditproperty_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for audits_audit_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."audits_audit_id_seq";
CREATE SEQUENCE "public"."audits_audit_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for audits_audit_tasks_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."audits_audit_tasks_id_seq";
CREATE SEQUENCE "public"."audits_audit_tasks_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for audits_audittemplate_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."audits_audittemplate_id_seq";
CREATE SEQUENCE "public"."audits_audittemplate_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for audits_audittemplate_tasks_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."audits_audittemplate_tasks_id_seq";
CREATE SEQUENCE "public"."audits_audittemplate_tasks_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for audittemplateproperty_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."audittemplateproperty_id_seq";
CREATE SEQUENCE "public"."audittemplateproperty_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for auth_group_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."auth_group_id_seq";
CREATE SEQUENCE "public"."auth_group_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for auth_group_permissions_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."auth_group_permissions_id_seq";
CREATE SEQUENCE "public"."auth_group_permissions_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for auth_permission_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."auth_permission_id_seq";
CREATE SEQUENCE "public"."auth_permission_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for checklistproperty_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."checklistproperty_id_seq";
CREATE SEQUENCE "public"."checklistproperty_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for checklists_checklist_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."checklists_checklist_id_seq";
CREATE SEQUENCE "public"."checklists_checklist_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for checklists_checklist_tasks_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."checklists_checklist_tasks_id_seq";
CREATE SEQUENCE "public"."checklists_checklist_tasks_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for checklists_checklisttemplate_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."checklists_checklisttemplate_id_seq";
CREATE SEQUENCE "public"."checklists_checklisttemplate_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for checklists_checklisttemplate_tasks_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."checklists_checklisttemplate_tasks_id_seq";
CREATE SEQUENCE "public"."checklists_checklisttemplate_tasks_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for checklisttemplateproperty_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."checklisttemplateproperty_id_seq";
CREATE SEQUENCE "public"."checklisttemplateproperty_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for comments_commentviewed_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."comments_commentviewed_id_seq";
CREATE SEQUENCE "public"."comments_commentviewed_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for comments_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."comments_id_seq";
CREATE SEQUENCE "public"."comments_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for companies_area_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."companies_area_id_seq";
CREATE SEQUENCE "public"."companies_area_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for companies_company_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."companies_company_id_seq";
CREATE SEQUENCE "public"."companies_company_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for companies_properties_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."companies_properties_id_seq";
CREATE SEQUENCE "public"."companies_properties_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for companies_setting_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."companies_setting_id_seq";
CREATE SEQUENCE "public"."companies_setting_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for companies_shift_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."companies_shift_id_seq";
CREATE SEQUENCE "public"."companies_shift_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for django_admin_log_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."django_admin_log_id_seq";
CREATE SEQUENCE "public"."django_admin_log_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for django_content_type_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."django_content_type_id_seq";
CREATE SEQUENCE "public"."django_content_type_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for django_migrations_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."django_migrations_id_seq";
CREATE SEQUENCE "public"."django_migrations_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for factoryfeed_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."factoryfeed_id_seq";
CREATE SEQUENCE "public"."factoryfeed_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for factoryfeed_messageliked_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."factoryfeed_messageliked_id_seq";
CREATE SEQUENCE "public"."factoryfeed_messageliked_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for factoryfeed_messageviewed_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."factoryfeed_messageviewed_id_seq";
CREATE SEQUENCE "public"."factoryfeed_messageviewed_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for factoryfeedmessages_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."factoryfeedmessages_id_seq";
CREATE SEQUENCE "public"."factoryfeedmessages_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for fcm_django_fcmdevice_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."fcm_django_fcmdevice_id_seq";
CREATE SEQUENCE "public"."fcm_django_fcmdevice_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for guardian_groupobjectpermission_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."guardian_groupobjectpermission_id_seq";
CREATE SEQUENCE "public"."guardian_groupobjectpermission_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for guardian_userobjectpermission_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."guardian_userobjectpermission_id_seq";
CREATE SEQUENCE "public"."guardian_userobjectpermission_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for logging_data_auditing_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."logging_data_auditing_id_seq";
CREATE SEQUENCE "public"."logging_data_auditing_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for logging_log_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."logging_log_id_seq";
CREATE SEQUENCE "public"."logging_log_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for logging_requestresponse_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."logging_requestresponse_id_seq";
CREATE SEQUENCE "public"."logging_requestresponse_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for profiles_user_allowed_areas_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."profiles_user_allowed_areas_id_seq";
CREATE SEQUENCE "public"."profiles_user_allowed_areas_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for profiles_user_areas_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."profiles_user_areas_id_seq";
CREATE SEQUENCE "public"."profiles_user_areas_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for profiles_user_groups_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."profiles_user_groups_id_seq";
CREATE SEQUENCE "public"."profiles_user_groups_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for profiles_user_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."profiles_user_id_seq";
CREATE SEQUENCE "public"."profiles_user_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for profiles_user_user_permissions_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."profiles_user_user_permissions_id_seq";
CREATE SEQUENCE "public"."profiles_user_user_permissions_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for properties_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."properties_id_seq";
CREATE SEQUENCE "public"."properties_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for propertygroups_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."propertygroups_id_seq";
CREATE SEQUENCE "public"."propertygroups_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for propertyvalue_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."propertyvalue_id_seq";
CREATE SEQUENCE "public"."propertyvalue_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for propertyvaluekind_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."propertyvaluekind_id_seq";
CREATE SEQUENCE "public"."propertyvaluekind_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for resource_languages_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."resource_languages_id_seq";
CREATE SEQUENCE "public"."resource_languages_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for resource_settings_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."resource_settings_id_seq";
CREATE SEQUENCE "public"."resource_settings_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for taskproperty_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."taskproperty_id_seq";
CREATE SEQUENCE "public"."taskproperty_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for tasks_task_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."tasks_task_id_seq";
CREATE SEQUENCE "public"."tasks_task_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for tasks_taskrecurrency_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."tasks_taskrecurrency_id_seq";
CREATE SEQUENCE "public"."tasks_taskrecurrency_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for tasks_taskrecurrency_one_time_shifts_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."tasks_taskrecurrency_one_time_shifts_id_seq";
CREATE SEQUENCE "public"."tasks_taskrecurrency_one_time_shifts_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for tasks_taskrecurrency_shifts_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."tasks_taskrecurrency_shifts_id_seq";
CREATE SEQUENCE "public"."tasks_taskrecurrency_shifts_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for tasks_taskstatusrecord_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."tasks_taskstatusrecord_id_seq";
CREATE SEQUENCE "public"."tasks_taskstatusrecord_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for tasks_tasktemplate_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."tasks_tasktemplate_id_seq";
CREATE SEQUENCE "public"."tasks_tasktemplate_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for tasks_tasktemplate_tags_links_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."tasks_tasktemplate_tags_links_id_seq";
CREATE SEQUENCE "public"."tasks_tasktemplate_tags_links_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for tasks_tasktemplatestep_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."tasks_tasktemplatestep_id_seq";
CREATE SEQUENCE "public"."tasks_tasktemplatestep_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for tasks_tasktemplatetag_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."tasks_tasktemplatetag_id_seq";
CREATE SEQUENCE "public"."tasks_tasktemplatetag_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for tasktemplateproperty_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."tasktemplateproperty_id_seq";
CREATE SEQUENCE "public"."tasktemplateproperty_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Sequence structure for uploads_requesteds3link_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "public"."uploads_requesteds3link_id_seq";
CREATE SEQUENCE "public"."uploads_requesteds3link_id_seq" 
INCREMENT 1
MINVALUE  1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Table structure for actions_action
-- ----------------------------
DROP TABLE IF EXISTS "public"."actions_action";
CREATE TABLE "public"."actions_action" (
  "id" int4 NOT NULL DEFAULT nextval('actions_action_id_seq'::regclass),
  "created_at" timestamptz(6) NOT NULL,
  "due_date" date NOT NULL,
  "is_resolved" bool NOT NULL,
  "comment" text COLLATE "pg_catalog"."default",
  "description" text COLLATE "pg_catalog"."default",
  "image_1" varchar(100) COLLATE "pg_catalog"."default",
  "image_2" varchar(100) COLLATE "pg_catalog"."default",
  "image_3" varchar(100) COLLATE "pg_catalog"."default",
  "image_4" varchar(100) COLLATE "pg_catalog"."default",
  "image_0" varchar(100) COLLATE "pg_catalog"."default",
  "created_by_id" int4 NOT NULL,
  "task_id" int4,
  "resolved_at" timestamptz(6),
  "company_id" int4,
  "modified_at" timestamptz(6) NOT NULL,
  "is_active" bool NOT NULL,
  "task_template_id" int4,
  "video" varchar(200) COLLATE "pg_catalog"."default",
  "video_thumbnail" varchar(100) COLLATE "pg_catalog"."default",
  "video_0" varchar(200) COLLATE "pg_catalog"."default",
  "video_1" varchar(200) COLLATE "pg_catalog"."default",
  "video_2" varchar(200) COLLATE "pg_catalog"."default",
  "video_3" varchar(200) COLLATE "pg_catalog"."default",
  "video_4" varchar(200) COLLATE "pg_catalog"."default",
  "video_thumbnail_0" varchar(100) COLLATE "pg_catalog"."default",
  "video_thumbnail_1" varchar(100) COLLATE "pg_catalog"."default",
  "video_thumbnail_2" varchar(100) COLLATE "pg_catalog"."default",
  "video_thumbnail_3" varchar(100) COLLATE "pg_catalog"."default",
  "video_thumbnail_4" varchar(100) COLLATE "pg_catalog"."default",
  "image_5" varchar(100) COLLATE "pg_catalog"."default",
  "video_5" varchar(200) COLLATE "pg_catalog"."default",
  "video_thumbnail_5" varchar(100) COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for actions_action_assigned_areas
-- ----------------------------
DROP TABLE IF EXISTS "public"."actions_action_assigned_areas";
CREATE TABLE "public"."actions_action_assigned_areas" (
  "id" int4 NOT NULL DEFAULT nextval('actions_action_assigned_areas_id_seq'::regclass),
  "action_id" int4 NOT NULL,
  "area_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for actions_action_assigned_users
-- ----------------------------
DROP TABLE IF EXISTS "public"."actions_action_assigned_users";
CREATE TABLE "public"."actions_action_assigned_users" (
  "id" int4 NOT NULL DEFAULT nextval('actions_action_assigned_users_id_seq'::regclass),
  "action_id" int4 NOT NULL,
  "user_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for actions_actioncomment
-- ----------------------------
DROP TABLE IF EXISTS "public"."actions_actioncomment";
CREATE TABLE "public"."actions_actioncomment" (
  "id" int4 NOT NULL DEFAULT nextval('actions_actioncomment_id_seq'::regclass),
  "comment" text COLLATE "pg_catalog"."default",
  "image_1" varchar(100) COLLATE "pg_catalog"."default",
  "image_2" varchar(100) COLLATE "pg_catalog"."default",
  "image_3" varchar(100) COLLATE "pg_catalog"."default",
  "image_4" varchar(100) COLLATE "pg_catalog"."default",
  "image_0" varchar(100) COLLATE "pg_catalog"."default",
  "action_id" int4 NOT NULL,
  "user_id" int4 NOT NULL,
  "created_at" timestamptz(6) NOT NULL,
  "company_id" int4,
  "modified_at" timestamptz(6) NOT NULL,
  "is_active" bool NOT NULL,
  "video" varchar(200) COLLATE "pg_catalog"."default",
  "video_thumbnail" varchar(100) COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for actions_actioncommentviewed
-- ----------------------------
DROP TABLE IF EXISTS "public"."actions_actioncommentviewed";
CREATE TABLE "public"."actions_actioncommentviewed" (
  "id" int4 NOT NULL DEFAULT nextval('actions_actioncommentviewed_id_seq'::regclass),
  "comment_id" int4 NOT NULL,
  "user_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for actions_actionviewed
-- ----------------------------
DROP TABLE IF EXISTS "public"."actions_actionviewed";
CREATE TABLE "public"."actions_actionviewed" (
  "id" int4 NOT NULL DEFAULT nextval('actions_actionviewed_id_seq'::regclass),
  "action_id" int4 NOT NULL,
  "user_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for announcement
-- ----------------------------
DROP TABLE IF EXISTS "public"."announcement";
CREATE TABLE "public"."announcement" (
  "id" int4 NOT NULL DEFAULT nextval('announcement_id_seq'::regclass),
  "title" varchar(512) COLLATE "pg_catalog"."default" NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "announcement_date" timestamptz(6) NOT NULL,
  "created_on" timestamptz(6) NOT NULL,
  "announcement_type" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for audits_audit
-- ----------------------------
DROP TABLE IF EXISTS "public"."audits_audit";
CREATE TABLE "public"."audits_audit" (
  "id" int4 NOT NULL DEFAULT nextval('audits_audit_id_seq'::regclass),
  "company_id" int4 NOT NULL,
  "template_id" int4 NOT NULL,
  "is_complete" bool NOT NULL,
  "total_score" int2,
  "signature_1" varchar(100) COLLATE "pg_catalog"."default",
  "signature_2" varchar(100) COLLATE "pg_catalog"."default",
  "signed_at_1" timestamptz(6),
  "signed_at_2" timestamptz(6),
  "signed_by_1_id" int4,
  "signed_by_2" varchar(255) COLLATE "pg_catalog"."default",
  "created_at" timestamptz(6) NOT NULL,
  "modified_at" timestamptz(6) NOT NULL,
  "is_active" bool NOT NULL
)
;

-- ----------------------------
-- Table structure for audits_audit_tasks
-- ----------------------------
DROP TABLE IF EXISTS "public"."audits_audit_tasks";
CREATE TABLE "public"."audits_audit_tasks" (
  "id" int4 NOT NULL DEFAULT nextval('audits_audit_tasks_id_seq'::regclass),
  "audit_id" int4 NOT NULL,
  "task_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for audits_audittemplate
-- ----------------------------
DROP TABLE IF EXISTS "public"."audits_audittemplate";
CREATE TABLE "public"."audits_audittemplate" (
  "id" int4 NOT NULL DEFAULT nextval('audits_audittemplate_id_seq'::regclass),
  "name" varchar(255) COLLATE "pg_catalog"."default" NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "picture" varchar(100) COLLATE "pg_catalog"."default",
  "double_signature_required" bool NOT NULL,
  "score_type" varchar(16) COLLATE "pg_catalog"."default" NOT NULL,
  "min_task_score" int4,
  "max_task_score" int4,
  "area_id" int4 NOT NULL,
  "company_id" int4 NOT NULL,
  "last_completed_date" timestamptz(6),
  "role" varchar(16) COLLATE "pg_catalog"."default",
  "signature_required" bool NOT NULL,
  "created_at" timestamptz(6) NOT NULL,
  "modified_at" timestamptz(6) NOT NULL,
  "is_active" bool NOT NULL
)
;

-- ----------------------------
-- Table structure for audits_audittemplate_properties
-- ----------------------------
DROP TABLE IF EXISTS "public"."audits_audittemplate_properties";
CREATE TABLE "public"."audits_audittemplate_properties" (
  "id" int4 NOT NULL DEFAULT nextval('audittemplateproperty_id_seq'::regclass),
  "company_id" int4 NOT NULL,
  "audittemplate_id" int4 NOT NULL,
  "property_id" int4 NOT NULL,
  "propertyvalue_id" int4,
  "primary_int_value" int4,
  "secondary_int_value" int4,
  "primary_decimal_value" numeric(32,5),
  "secondary_decimal_value" numeric(32,5),
  "primary_datetime_value" timestamp(6),
  "secondary_datetime_value" timestamp(6),
  "primary_time_value" time(6),
  "secondary_time_value" time(6),
  "primary_string_value" text COLLATE "pg_catalog"."default",
  "secondary_string_value" text COLLATE "pg_catalog"."default",
  "bool_value" bool,
  "custom_value_type_display" varchar COLLATE "pg_catalog"."default",
  "custom_title_display" varchar COLLATE "pg_catalog"."default",
  "custom_display_type" varchar COLLATE "pg_catalog"."default",
  "display_type" int4,
  "is_required" bool DEFAULT false,
  "index" int4 NOT NULL DEFAULT 0,
  "is_active" bool NOT NULL DEFAULT true,
  "created_at" timestamp(6) NOT NULL DEFAULT now(),
  "modified_at" timestamp(6) NOT NULL DEFAULT now()
)
;

-- ----------------------------
-- Table structure for audits_audittemplate_tasks
-- ----------------------------
DROP TABLE IF EXISTS "public"."audits_audittemplate_tasks";
CREATE TABLE "public"."audits_audittemplate_tasks" (
  "id" int4 NOT NULL DEFAULT nextval('audits_audittemplate_tasks_id_seq'::regclass),
  "audittemplate_id" int4 NOT NULL,
  "tasktemplate_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for audits_properties
-- ----------------------------
DROP TABLE IF EXISTS "public"."audits_properties";
CREATE TABLE "public"."audits_properties" (
  "id" int4 NOT NULL DEFAULT nextval('auditproperty_id_seq'::regclass),
  "company_id" int4 NOT NULL,
  "audit_id" int4 NOT NULL,
  "property_id" int4 NOT NULL,
  "template_property_id" int4 NOT NULL,
  "user_id" int4 NOT NULL,
  "value_int" int4,
  "value_string" text COLLATE "pg_catalog"."default",
  "value_decimal" numeric(32,5),
  "value_time" time(6),
  "value_date" timestamp(6),
  "value_bool" bool,
  "created_at" timestamp(6) NOT NULL DEFAULT now(),
  "modified_at" timestamp(6) NOT NULL DEFAULT now()
)
;

-- ----------------------------
-- Table structure for auth_group
-- ----------------------------
DROP TABLE IF EXISTS "public"."auth_group";
CREATE TABLE "public"."auth_group" (
  "id" int4 NOT NULL DEFAULT nextval('auth_group_id_seq'::regclass),
  "name" varchar(80) COLLATE "pg_catalog"."default" NOT NULL
)
;

-- ----------------------------
-- Table structure for auth_group_permissions
-- ----------------------------
DROP TABLE IF EXISTS "public"."auth_group_permissions";
CREATE TABLE "public"."auth_group_permissions" (
  "id" int4 NOT NULL DEFAULT nextval('auth_group_permissions_id_seq'::regclass),
  "group_id" int4 NOT NULL,
  "permission_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for auth_permission
-- ----------------------------
DROP TABLE IF EXISTS "public"."auth_permission";
CREATE TABLE "public"."auth_permission" (
  "id" int4 NOT NULL DEFAULT nextval('auth_permission_id_seq'::regclass),
  "name" varchar(255) COLLATE "pg_catalog"."default" NOT NULL,
  "content_type_id" int4 NOT NULL,
  "codename" varchar(100) COLLATE "pg_catalog"."default" NOT NULL
)
;

-- ----------------------------
-- Table structure for authtoken_token
-- ----------------------------
DROP TABLE IF EXISTS "public"."authtoken_token";
CREATE TABLE "public"."authtoken_token" (
  "key" varchar(40) COLLATE "pg_catalog"."default" NOT NULL,
  "created" timestamptz(6) NOT NULL,
  "user_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for checklists_checklist
-- ----------------------------
DROP TABLE IF EXISTS "public"."checklists_checklist";
CREATE TABLE "public"."checklists_checklist" (
  "id" int4 NOT NULL DEFAULT nextval('checklists_checklist_id_seq'::regclass),
  "signed_at_1" timestamptz(6),
  "signature_1" varchar(100) COLLATE "pg_catalog"."default",
  "company_id" int4 NOT NULL,
  "signed_by_1_id" int4,
  "template_id" int4 NOT NULL,
  "signature_2" varchar(100) COLLATE "pg_catalog"."default",
  "signed_at_2" timestamptz(6),
  "signed_by_2" varchar(255) COLLATE "pg_catalog"."default",
  "is_complete" bool NOT NULL,
  "created_at" timestamptz(6) NOT NULL,
  "modified_at" timestamptz(6) NOT NULL,
  "is_active" bool NOT NULL
)
;

-- ----------------------------
-- Table structure for checklists_checklist_tasks
-- ----------------------------
DROP TABLE IF EXISTS "public"."checklists_checklist_tasks";
CREATE TABLE "public"."checklists_checklist_tasks" (
  "id" int4 NOT NULL DEFAULT nextval('checklists_checklist_tasks_id_seq'::regclass),
  "checklist_id" int4 NOT NULL,
  "task_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for checklists_checklisttemplate
-- ----------------------------
DROP TABLE IF EXISTS "public"."checklists_checklisttemplate";
CREATE TABLE "public"."checklists_checklisttemplate" (
  "id" int4 NOT NULL DEFAULT nextval('checklists_checklisttemplate_id_seq'::regclass),
  "name" varchar(255) COLLATE "pg_catalog"."default" NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "picture" varchar(100) COLLATE "pg_catalog"."default",
  "area_id" int4 NOT NULL,
  "company_id" int4 NOT NULL,
  "double_signature_required" bool NOT NULL,
  "role" varchar(16) COLLATE "pg_catalog"."default",
  "created_at" timestamptz(6) NOT NULL,
  "modified_at" timestamptz(6) NOT NULL,
  "is_active" bool NOT NULL,
  "signature_required" bool NOT NULL
)
;

-- ----------------------------
-- Table structure for checklists_checklisttemplate_properties
-- ----------------------------
DROP TABLE IF EXISTS "public"."checklists_checklisttemplate_properties";
CREATE TABLE "public"."checklists_checklisttemplate_properties" (
  "id" int4 NOT NULL DEFAULT nextval('checklisttemplateproperty_id_seq'::regclass),
  "company_id" int4 NOT NULL,
  "checklisttemplate_id" int4 NOT NULL,
  "property_id" int4 NOT NULL,
  "propertyvalue_id" int4,
  "primary_int_value" int4,
  "secondary_int_value" int4,
  "primary_decimal_value" numeric(32,5),
  "secondary_decimal_value" numeric(32,5),
  "primary_datetime_value" timestamp(6),
  "secondary_datetime_value" timestamp(6),
  "primary_time_value" time(6),
  "secondary_time_value" time(6),
  "primary_string_value" text COLLATE "pg_catalog"."default",
  "secondary_string_value" text COLLATE "pg_catalog"."default",
  "bool_value" bool,
  "custom_value_type_display" varchar COLLATE "pg_catalog"."default",
  "custom_title_display" varchar COLLATE "pg_catalog"."default",
  "custom_display_type" varchar COLLATE "pg_catalog"."default",
  "display_type" int4,
  "is_required" bool DEFAULT false,
  "index" int4 NOT NULL DEFAULT 0,
  "is_active" bool NOT NULL DEFAULT true,
  "created_at" timestamp(6) NOT NULL DEFAULT now(),
  "modified_at" timestamp(6) NOT NULL DEFAULT now()
)
;

-- ----------------------------
-- Table structure for checklists_checklisttemplate_tasks
-- ----------------------------
DROP TABLE IF EXISTS "public"."checklists_checklisttemplate_tasks";
CREATE TABLE "public"."checklists_checklisttemplate_tasks" (
  "id" int4 NOT NULL DEFAULT nextval('checklists_checklisttemplate_tasks_id_seq'::regclass),
  "checklisttemplate_id" int4 NOT NULL,
  "tasktemplate_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for checklists_properties
-- ----------------------------
DROP TABLE IF EXISTS "public"."checklists_properties";
CREATE TABLE "public"."checklists_properties" (
  "id" int4 NOT NULL DEFAULT nextval('checklistproperty_id_seq'::regclass),
  "company_id" int4 NOT NULL,
  "checklist_id" int4 NOT NULL,
  "property_id" int4 NOT NULL,
  "template_property_id" int4 NOT NULL,
  "user_id" int4 NOT NULL,
  "value_int" int4,
  "value_string" text COLLATE "pg_catalog"."default",
  "value_decimal" numeric(32,5),
  "value_time" time(6),
  "value_date" timestamp(6),
  "value_bool" bool,
  "created_at" timestamp(6) NOT NULL DEFAULT now(),
  "modified_at" timestamp(6) NOT NULL DEFAULT now()
)
;

-- ----------------------------
-- Table structure for comments
-- ----------------------------
DROP TABLE IF EXISTS "public"."comments";
CREATE TABLE "public"."comments" (
  "id" int4 NOT NULL DEFAULT nextval('comments_id_seq'::regclass),
  "company_id" int4 NOT NULL,
  "user_id" int4 NOT NULL,
  "task_id" int4,
  "comment" text COLLATE "pg_catalog"."default",
  "comment_date" timestamp(6),
  "description" text COLLATE "pg_catalog"."default",
  "attachments" text COLLATE "pg_catalog"."default",
  "is_active" bool NOT NULL,
  "created_at" timestamp(6) NOT NULL,
  "modified_at" timestamp(6) NOT NULL,
  "tasktemplate_id" int4
)
;

-- ----------------------------
-- Table structure for comments_commentviewed
-- ----------------------------
DROP TABLE IF EXISTS "public"."comments_commentviewed";
CREATE TABLE "public"."comments_commentviewed" (
  "id" int4 NOT NULL DEFAULT nextval('comments_commentviewed_id_seq'::regclass),
  "comment_id" int4 NOT NULL,
  "user_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for companies_area
-- ----------------------------
DROP TABLE IF EXISTS "public"."companies_area";
CREATE TABLE "public"."companies_area" (
  "id" int4 NOT NULL DEFAULT nextval('companies_area_id_seq'::regclass),
  "name" varchar(255) COLLATE "pg_catalog"."default" NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "company_id" int4 NOT NULL,
  "picture" varchar(100) COLLATE "pg_catalog"."default",
  "level" int4 NOT NULL,
  "lft" int4 NOT NULL,
  "parent_id" int4,
  "rght" int4 NOT NULL,
  "tree_id" int4 NOT NULL,
  "is_active" bool NOT NULL,
  "label" varchar(255) COLLATE "pg_catalog"."default",
  "custom_shifts" bool NOT NULL,
  "created_at" timestamptz(6) NOT NULL,
  "modified_at" timestamptz(6) NOT NULL,
  "is_system" bool NOT NULL,
  "system_role" varchar(32) COLLATE "pg_catalog"."default",
  "days_to_get_data" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for companies_company
-- ----------------------------
DROP TABLE IF EXISTS "public"."companies_company";
CREATE TABLE "public"."companies_company" (
  "id" int4 NOT NULL DEFAULT nextval('companies_company_id_seq'::regclass),
  "name" varchar(255) COLLATE "pg_catalog"."default" NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "picture" varchar(100) COLLATE "pg_catalog"."default",
  "basic_role_display_name" varchar(100) COLLATE "pg_catalog"."default",
  "manager_role_display_name" varchar(100) COLLATE "pg_catalog"."default",
  "shift_leader_role_display_name" varchar(100) COLLATE "pg_catalog"."default",
  "manager_id" int4,
  "created_at" timestamptz(6) NOT NULL,
  "modified_at" timestamptz(6) NOT NULL,
  "is_active" bool NOT NULL,
  "logoff_after" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for companies_properties
-- ----------------------------
DROP TABLE IF EXISTS "public"."companies_properties";
CREATE TABLE "public"."companies_properties" (
  "id" int4 NOT NULL DEFAULT nextval('companies_properties_id_seq'::regclass),
  "property_id" int4 NOT NULL,
  "company_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for companies_setting
-- ----------------------------
DROP TABLE IF EXISTS "public"."companies_setting";
CREATE TABLE "public"."companies_setting" (
  "id" int4 NOT NULL DEFAULT nextval('companies_setting_id_seq'::regclass),
  "company_id" int4 NOT NULL,
  "value" text COLLATE "pg_catalog"."default",
  "description" text COLLATE "pg_catalog"."default",
  "resource_setting_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for companies_shift
-- ----------------------------
DROP TABLE IF EXISTS "public"."companies_shift";
CREATE TABLE "public"."companies_shift" (
  "id" int4 NOT NULL DEFAULT nextval('companies_shift_id_seq'::regclass),
  "day" int2 NOT NULL,
  "start" time(6) NOT NULL,
  "end" time(6) NOT NULL,
  "company_id" int4 NOT NULL,
  "area_id" int4,
  "created_at" timestamptz(6) NOT NULL,
  "modified_at" timestamptz(6) NOT NULL,
  "is_active" bool NOT NULL,
  "weekday" int2 NOT NULL
)
;

-- ----------------------------
-- Table structure for django_admin_log
-- ----------------------------
DROP TABLE IF EXISTS "public"."django_admin_log";
CREATE TABLE "public"."django_admin_log" (
  "id" int4 NOT NULL DEFAULT nextval('django_admin_log_id_seq'::regclass),
  "action_time" timestamptz(6) NOT NULL,
  "object_id" text COLLATE "pg_catalog"."default",
  "object_repr" varchar(200) COLLATE "pg_catalog"."default" NOT NULL,
  "action_flag" int2 NOT NULL,
  "change_message" text COLLATE "pg_catalog"."default" NOT NULL,
  "content_type_id" int4,
  "user_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for django_content_type
-- ----------------------------
DROP TABLE IF EXISTS "public"."django_content_type";
CREATE TABLE "public"."django_content_type" (
  "id" int4 NOT NULL DEFAULT nextval('django_content_type_id_seq'::regclass),
  "app_label" varchar(100) COLLATE "pg_catalog"."default" NOT NULL,
  "model" varchar(100) COLLATE "pg_catalog"."default" NOT NULL
)
;

-- ----------------------------
-- Table structure for django_migrations
-- ----------------------------
DROP TABLE IF EXISTS "public"."django_migrations";
CREATE TABLE "public"."django_migrations" (
  "id" int4 NOT NULL DEFAULT nextval('django_migrations_id_seq'::regclass),
  "app" varchar(255) COLLATE "pg_catalog"."default" NOT NULL,
  "name" varchar(255) COLLATE "pg_catalog"."default" NOT NULL,
  "applied" timestamptz(6) NOT NULL
)
;

-- ----------------------------
-- Table structure for django_session
-- ----------------------------
DROP TABLE IF EXISTS "public"."django_session";
CREATE TABLE "public"."django_session" (
  "session_key" varchar(40) COLLATE "pg_catalog"."default" NOT NULL,
  "session_data" text COLLATE "pg_catalog"."default" NOT NULL,
  "expire_date" timestamptz(6) NOT NULL
)
;

-- ----------------------------
-- Table structure for factoryfeed_messageliked
-- ----------------------------
DROP TABLE IF EXISTS "public"."factoryfeed_messageliked";
CREATE TABLE "public"."factoryfeed_messageliked" (
  "id" int4 NOT NULL DEFAULT nextval('factoryfeed_messageliked_id_seq'::regclass),
  "factoryfeedmessage_id" int4 NOT NULL,
  "user_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for factoryfeed_messages
-- ----------------------------
DROP TABLE IF EXISTS "public"."factoryfeed_messages";
CREATE TABLE "public"."factoryfeed_messages" (
  "id" int4 NOT NULL DEFAULT nextval('factoryfeedmessages_id_seq'::regclass),
  "company_id" int4 NOT NULL,
  "factoryfeed_id" int4 NOT NULL,
  "user_id" int4,
  "title" varchar(250) COLLATE "pg_catalog"."default" NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "attachments" text COLLATE "pg_catalog"."default",
  "is_sticky" bool NOT NULL,
  "is_highlighted" bool NOT NULL,
  "message_type" int4 NOT NULL,
  "data" text COLLATE "pg_catalog"."default",
  "message_date" timestamp(6) NOT NULL,
  "created_at" timestamp(6) NOT NULL,
  "modified_at" timestamp(6) NOT NULL,
  "is_active" bool NOT NULL,
  "parent_id" int4
)
;

-- ----------------------------
-- Table structure for factoryfeed_messageviewed
-- ----------------------------
DROP TABLE IF EXISTS "public"."factoryfeed_messageviewed";
CREATE TABLE "public"."factoryfeed_messageviewed" (
  "id" int4 NOT NULL DEFAULT nextval('factoryfeed_messageviewed_id_seq'::regclass),
  "factoryfeedmessage_id" int4 NOT NULL,
  "user_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for factoryfeeds
-- ----------------------------
DROP TABLE IF EXISTS "public"."factoryfeeds";
CREATE TABLE "public"."factoryfeeds" (
  "id" int4 NOT NULL DEFAULT nextval('factoryfeed_id_seq'::regclass),
  "company_id" int4 NOT NULL,
  "name" varchar(250) COLLATE "pg_catalog"."default" NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "attachments" text COLLATE "pg_catalog"."default",
  "data" text COLLATE "pg_catalog"."default",
  "feed_type" int4 NOT NULL,
  "is_active" bool NOT NULL
)
;

-- ----------------------------
-- Table structure for fcm_django_fcmdevice
-- ----------------------------
DROP TABLE IF EXISTS "public"."fcm_django_fcmdevice";
CREATE TABLE "public"."fcm_django_fcmdevice" (
  "id" int4 NOT NULL DEFAULT nextval('fcm_django_fcmdevice_id_seq'::regclass),
  "name" varchar(255) COLLATE "pg_catalog"."default",
  "active" bool NOT NULL,
  "date_created" timestamptz(6),
  "device_id" varchar(150) COLLATE "pg_catalog"."default",
  "registration_id" text COLLATE "pg_catalog"."default" NOT NULL,
  "type" varchar(10) COLLATE "pg_catalog"."default" NOT NULL,
  "user_id" int4
)
;

-- ----------------------------
-- Table structure for guardian_groupobjectpermission
-- ----------------------------
DROP TABLE IF EXISTS "public"."guardian_groupobjectpermission";
CREATE TABLE "public"."guardian_groupobjectpermission" (
  "id" int4 NOT NULL DEFAULT nextval('guardian_groupobjectpermission_id_seq'::regclass),
  "object_pk" varchar(255) COLLATE "pg_catalog"."default" NOT NULL,
  "content_type_id" int4 NOT NULL,
  "group_id" int4 NOT NULL,
  "permission_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for guardian_userobjectpermission
-- ----------------------------
DROP TABLE IF EXISTS "public"."guardian_userobjectpermission";
CREATE TABLE "public"."guardian_userobjectpermission" (
  "id" int4 NOT NULL DEFAULT nextval('guardian_userobjectpermission_id_seq'::regclass),
  "object_pk" varchar(255) COLLATE "pg_catalog"."default" NOT NULL,
  "content_type_id" int4 NOT NULL,
  "permission_id" int4 NOT NULL,
  "user_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for logging_data_auditing
-- ----------------------------
DROP TABLE IF EXISTS "public"."logging_data_auditing";
CREATE TABLE "public"."logging_data_auditing" (
  "id" int8 NOT NULL DEFAULT nextval('logging_data_auditing_id_seq'::regclass),
  "original_object" text COLLATE "pg_catalog"."default",
  "mutated_object" text COLLATE "pg_catalog"."default",
  "object_type" varchar(40) COLLATE "pg_catalog"."default",
  "object_id" int4,
  "company_id" int4,
  "user_id" int4,
  "description" text COLLATE "pg_catalog"."default",
  "created_on" timestamptz(6) NOT NULL
)
;

-- ----------------------------
-- Table structure for logging_log
-- ----------------------------
DROP TABLE IF EXISTS "public"."logging_log";
CREATE TABLE "public"."logging_log" (
  "id" int4 NOT NULL DEFAULT nextval('logging_log_id_seq'::regclass),
  "message" varchar(255) COLLATE "pg_catalog"."default",
  "type" varchar(40) COLLATE "pg_catalog"."default",
  "eventid" varchar(40) COLLATE "pg_catalog"."default",
  "eventname" varchar(40) COLLATE "pg_catalog"."default",
  "description" text COLLATE "pg_catalog"."default",
  "created_on" timestamptz(6) NOT NULL,
  "source" varchar(255) COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for logging_requestresponse
-- ----------------------------
DROP TABLE IF EXISTS "public"."logging_requestresponse";
CREATE TABLE "public"."logging_requestresponse" (
  "id" int4 NOT NULL DEFAULT nextval('logging_requestresponse_id_seq'::regclass),
  "domain" text COLLATE "pg_catalog"."default",
  "path" text COLLATE "pg_catalog"."default",
  "query" text COLLATE "pg_catalog"."default",
  "status" varchar(20) COLLATE "pg_catalog"."default",
  "header" text COLLATE "pg_catalog"."default",
  "request" text COLLATE "pg_catalog"."default",
  "response" text COLLATE "pg_catalog"."default",
  "created_on" timestamptz(6) NOT NULL
)
;

-- ----------------------------
-- Table structure for profiles_expiredtoken
-- ----------------------------
DROP TABLE IF EXISTS "public"."profiles_expiredtoken";
CREATE TABLE "public"."profiles_expiredtoken" (
  "key" varchar(40) COLLATE "pg_catalog"."default" NOT NULL,
  "created_at" timestamptz(6) NOT NULL,
  "user_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for profiles_user
-- ----------------------------
DROP TABLE IF EXISTS "public"."profiles_user";
CREATE TABLE "public"."profiles_user" (
  "id" int4 NOT NULL DEFAULT nextval('profiles_user_id_seq'::regclass),
  "password" varchar(128) COLLATE "pg_catalog"."default" NOT NULL,
  "last_login" timestamptz(6),
  "is_superuser" bool NOT NULL,
  "username" varchar(150) COLLATE "pg_catalog"."default" NOT NULL,
  "first_name" varchar(30) COLLATE "pg_catalog"."default" NOT NULL,
  "last_name" varchar(30) COLLATE "pg_catalog"."default" NOT NULL,
  "email" varchar(254) COLLATE "pg_catalog"."default" NOT NULL,
  "is_staff" bool NOT NULL,
  "is_active" bool NOT NULL,
  "date_joined" timestamptz(6) NOT NULL,
  "company_id" int4,
  "picture" varchar(100) COLLATE "pg_catalog"."default",
  "role" varchar(16) COLLATE "pg_catalog"."default",
  "phone" varchar(32) COLLATE "pg_catalog"."default",
  "created_at" timestamptz(6) NOT NULL,
  "modified_at" timestamptz(6) NOT NULL,
  "timezone" int2 NOT NULL,
  "is_deleted" bool NOT NULL,
  "successor_id" int4,
  "upn" varchar(155) COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for profiles_user_allowed_areas
-- ----------------------------
DROP TABLE IF EXISTS "public"."profiles_user_allowed_areas";
CREATE TABLE "public"."profiles_user_allowed_areas" (
  "id" int4 NOT NULL DEFAULT nextval('profiles_user_allowed_areas_id_seq'::regclass),
  "user_id" int4 NOT NULL,
  "area_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for profiles_user_areas
-- ----------------------------
DROP TABLE IF EXISTS "public"."profiles_user_areas";
CREATE TABLE "public"."profiles_user_areas" (
  "id" int4 NOT NULL DEFAULT nextval('profiles_user_areas_id_seq'::regclass),
  "user_id" int4 NOT NULL,
  "area_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for profiles_user_groups
-- ----------------------------
DROP TABLE IF EXISTS "public"."profiles_user_groups";
CREATE TABLE "public"."profiles_user_groups" (
  "id" int4 NOT NULL DEFAULT nextval('profiles_user_groups_id_seq'::regclass),
  "user_id" int4 NOT NULL,
  "group_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for profiles_user_user_permissions
-- ----------------------------
DROP TABLE IF EXISTS "public"."profiles_user_user_permissions";
CREATE TABLE "public"."profiles_user_user_permissions" (
  "id" int4 NOT NULL DEFAULT nextval('profiles_user_user_permissions_id_seq'::regclass),
  "user_id" int4 NOT NULL,
  "permission_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for properties
-- ----------------------------
DROP TABLE IF EXISTS "public"."properties";
CREATE TABLE "public"."properties" (
  "id" int4 NOT NULL DEFAULT nextval('properties_id_seq'::regclass),
  "propertygroup_id" int4 NOT NULL,
  "propertyvaluekind_id" int4,
  "propertyvalue_id" int4,
  "name" varchar(250) COLLATE "pg_catalog"."default" NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "shortname" varchar(100) COLLATE "pg_catalog"."default",
  "field_type" int4 NOT NULL,
  "value_type" int4 NOT NULL,
  "display_value_type" int4,
  "display_type" int4,
  "type" int4 NOT NULL,
  "resource_key_name" varchar(250) COLLATE "pg_catalog"."default",
  "is_customer_specific" bool NOT NULL DEFAULT false,
  "is_system" bool NOT NULL DEFAULT false,
  "is_active" bool NOT NULL DEFAULT true,
  "created_at" timestamp(6) NOT NULL DEFAULT now(),
  "modified_at" timestamp(6) NOT NULL DEFAULT now()
)
;

-- ----------------------------
-- Table structure for propertygroups
-- ----------------------------
DROP TABLE IF EXISTS "public"."propertygroups";
CREATE TABLE "public"."propertygroups" (
  "id" int4 NOT NULL DEFAULT nextval('propertygroups_id_seq'::regclass),
  "name" varchar(250) COLLATE "pg_catalog"."default" NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "is_active" bool NOT NULL DEFAULT true,
  "created_at" timestamp(6) NOT NULL DEFAULT now(),
  "modified_at" timestamp(6) NOT NULL DEFAULT now()
)
;

-- ----------------------------
-- Table structure for propertyvalue
-- ----------------------------
DROP TABLE IF EXISTS "public"."propertyvalue";
CREATE TABLE "public"."propertyvalue" (
  "id" int4 NOT NULL DEFAULT nextval('propertyvalue_id_seq'::regclass),
  "propertyvaluekind_id" int4 NOT NULL,
  "name" varchar(250) COLLATE "pg_catalog"."default" NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "value_symbol" varchar(100) COLLATE "pg_catalog"."default",
  "value_abbreviation" varchar(100) COLLATE "pg_catalog"."default",
  "default_value_type" int4,
  "resource_key_name" varchar(250) COLLATE "pg_catalog"."default",
  "is_active" bool NOT NULL DEFAULT true,
  "created_at" timestamp(6) NOT NULL DEFAULT now(),
  "modified_at" timestamp(6) NOT NULL DEFAULT now()
)
;

-- ----------------------------
-- Table structure for propertyvaluekind
-- ----------------------------
DROP TABLE IF EXISTS "public"."propertyvaluekind";
CREATE TABLE "public"."propertyvaluekind" (
  "id" int4 NOT NULL DEFAULT nextval('propertyvaluekind_id_seq'::regclass),
  "name" varchar(250) COLLATE "pg_catalog"."default" NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "resource_key_name" varchar(250) COLLATE "pg_catalog"."default",
  "is_active" bool NOT NULL DEFAULT true,
  "created_at" timestamp(6) NOT NULL DEFAULT now(),
  "modified_at" timestamp(6) NOT NULL DEFAULT now()
)
;

-- ----------------------------
-- Table structure for resource_languages
-- ----------------------------
DROP TABLE IF EXISTS "public"."resource_languages";
CREATE TABLE "public"."resource_languages" (
  "id" int4 NOT NULL DEFAULT nextval('resource_languages_id_seq'::regclass),
  "resource_key" varchar(255) COLLATE "pg_catalog"."default",
  "resource_guid" varchar(40) COLLATE "pg_catalog"."default",
  "description" text COLLATE "pg_catalog"."default",
  "en_us" text COLLATE "pg_catalog"."default",
  "en_gb" text COLLATE "pg_catalog"."default",
  "nl_nl" text COLLATE "pg_catalog"."default",
  "de_de" text COLLATE "pg_catalog"."default",
  "fr_fr" text COLLATE "pg_catalog"."default",
  "es_es" text COLLATE "pg_catalog"."default",
  "pt_pt" text COLLATE "pg_catalog"."default",
  "it_it" text COLLATE "pg_catalog"."default",
  "el_gr" text COLLATE "pg_catalog"."default",
  "nb_no" text COLLATE "pg_catalog"."default",
  "fi_fi" text COLLATE "pg_catalog"."default",
  "da_dk" text COLLATE "pg_catalog"."default",
  "sv_se" text COLLATE "pg_catalog"."default",
  "is_is" text COLLATE "pg_catalog"."default",
  "pl_pl" text COLLATE "pg_catalog"."default",
  "lt_lt" text COLLATE "pg_catalog"."default",
  "lv_lv" text COLLATE "pg_catalog"."default",
  "et_ee" text COLLATE "pg_catalog"."default",
  "ro_ro" text COLLATE "pg_catalog"."default",
  "bg_bg" text COLLATE "pg_catalog"."default",
  "cs_cz" text COLLATE "pg_catalog"."default",
  "hr_hr" text COLLATE "pg_catalog"."default",
  "hu_hu" text COLLATE "pg_catalog"."default",
  "hy_am" text COLLATE "pg_catalog"."default",
  "ka_ge" text COLLATE "pg_catalog"."default",
  "mk_mk" text COLLATE "pg_catalog"."default",
  "sk_sk" text COLLATE "pg_catalog"."default",
  "sl_si" text COLLATE "pg_catalog"."default",
  "sq_al" text COLLATE "pg_catalog"."default",
  "uk_ua" text COLLATE "pg_catalog"."default",
  "af_za" text COLLATE "pg_catalog"."default",
  "ar_sa" text COLLATE "pg_catalog"."default",
  "he_il" text COLLATE "pg_catalog"."default",
  "id_id" text COLLATE "pg_catalog"."default",
  "ja_jp" text COLLATE "pg_catalog"."default",
  "ko_kr" text COLLATE "pg_catalog"."default",
  "ru_ru" text COLLATE "pg_catalog"."default",
  "tr_tr" text COLLATE "pg_catalog"."default",
  "zh_cn" text COLLATE "pg_catalog"."default",
  "hi_in" text COLLATE "pg_catalog"."default",
  "gd_gb" text COLLATE "pg_catalog"."default",
  "ga_ie" text COLLATE "pg_catalog"."default",
  "fy_nl" text COLLATE "pg_catalog"."default",
  "my_mm" text COLLATE "pg_catalog"."default",
  "vi_vn" text COLLATE "pg_catalog"."default",
  "th_th" text COLLATE "pg_catalog"."default",
  "lo_la" text COLLATE "pg_catalog"."default",
  "ms_my" text COLLATE "pg_catalog"."default",
  "ms_sg" text COLLATE "pg_catalog"."default",
  "fil_ph" text COLLATE "pg_catalog"."default",
  "bn_bd" text COLLATE "pg_catalog"."default",
  "si_lk" text COLLATE "pg_catalog"."default",
  "km_kh" text COLLATE "pg_catalog"."default",
  "type" int4 DEFAULT 1
)
;

-- ----------------------------
-- Table structure for resource_settings
-- ----------------------------
DROP TABLE IF EXISTS "public"."resource_settings";
CREATE TABLE "public"."resource_settings" (
  "id" int4 NOT NULL DEFAULT nextval('resource_settings_id_seq'::regclass),
  "name" varchar(100) COLLATE "pg_catalog"."default" NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "settingskey" varchar(100) COLLATE "pg_catalog"."default" NOT NULL,
  "settingstype" int4 NOT NULL,
  "settingvalue" text COLLATE "pg_catalog"."default"
)
;
COMMENT ON TABLE "public"."resource_settings" IS 'SETTINGSKEY: Must be UNIQUE, will be used within code. SETTINGSTYPE: 1) General Setting | 2) Feature Setting | 3) Company Specific Setting | 4) User Specific Setting';

-- ----------------------------
-- Table structure for sequences_sequence
-- ----------------------------
DROP TABLE IF EXISTS "public"."sequences_sequence";
CREATE TABLE "public"."sequences_sequence" (
  "name" varchar(100) COLLATE "pg_catalog"."default" NOT NULL,
  "last" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for tasks_properties
-- ----------------------------
DROP TABLE IF EXISTS "public"."tasks_properties";
CREATE TABLE "public"."tasks_properties" (
  "id" int4 NOT NULL DEFAULT nextval('taskproperty_id_seq'::regclass),
  "company_id" int4 NOT NULL,
  "task_id" int4 NOT NULL,
  "property_id" int4 NOT NULL,
  "template_property_id" int4 NOT NULL,
  "user_id" int4 NOT NULL,
  "value_int" int4,
  "value_string" text COLLATE "pg_catalog"."default",
  "value_decimal" numeric(32,5),
  "value_time" time(6),
  "value_date" timestamp(6),
  "value_bool" bool,
  "created_at" timestamp(6) NOT NULL DEFAULT now(),
  "modified_at" timestamp(6) NOT NULL DEFAULT now()
)
;

-- ----------------------------
-- Table structure for tasks_task
-- ----------------------------
DROP TABLE IF EXISTS "public"."tasks_task";
CREATE TABLE "public"."tasks_task" (
  "id" int4 NOT NULL DEFAULT nextval('tasks_task_id_seq'::regclass),
  "status" varchar(32) COLLATE "pg_catalog"."default" NOT NULL,
  "signed_at" timestamptz(6),
  "comment" text COLLATE "pg_catalog"."default",
  "signed_by_id" int4,
  "template_id" int4 NOT NULL,
  "company_id" int4 NOT NULL,
  "recurrency_id" int4,
  "score" int4,
  "created_at" timestamptz(6) NOT NULL,
  "modified_at" timestamptz(6) NOT NULL,
  "is_active" bool NOT NULL,
  "end_date" date,
  "start_date" date,
  "shift_id" int4,
  "deviance" int4,
  "max_score" int4,
  "total_score" int4,
  "due_at" timestamptz(6),
  "start_at" timestamptz(6),
  "time_realized_by_id" int4,
  "time_taken" int4
)
;

-- ----------------------------
-- Table structure for tasks_taskrecurrency
-- ----------------------------
DROP TABLE IF EXISTS "public"."tasks_taskrecurrency";
CREATE TABLE "public"."tasks_taskrecurrency" (
  "id" int4 NOT NULL DEFAULT nextval('tasks_taskrecurrency_id_seq'::regclass),
  "type" varchar(16) COLLATE "pg_catalog"."default" NOT NULL,
  "date" date,
  "week" int4,
  "day" int4,
  "month" int4,
  "company_id" int4 NOT NULL,
  "shift_id" int4,
  "template_id" int4 NOT NULL,
  "area_id" int4,
  "end_date" date,
  "start_date" date,
  "weekday0" bool NOT NULL,
  "weekday1" bool NOT NULL,
  "weekday2" bool NOT NULL,
  "weekday3" bool NOT NULL,
  "weekday4" bool NOT NULL,
  "weekday5" bool NOT NULL,
  "weekday6" bool NOT NULL,
  "month_recurrency" varchar(16) COLLATE "pg_catalog"."default",
  "weekday" int4,
  "weekday_number" int4,
  "is_once_per_month" bool NOT NULL,
  "is_once_per_week" bool NOT NULL,
  "created_at" timestamptz(6) NOT NULL,
  "modified_at" timestamptz(6) NOT NULL,
  "is_active" bool NOT NULL,
  "last_generated_date" date,
  "last_signed_at" timestamptz(6)
)
;

-- ----------------------------
-- Table structure for tasks_taskrecurrency_one_time_shifts
-- ----------------------------
DROP TABLE IF EXISTS "public"."tasks_taskrecurrency_one_time_shifts";
CREATE TABLE "public"."tasks_taskrecurrency_one_time_shifts" (
  "id" int4 NOT NULL DEFAULT nextval('tasks_taskrecurrency_one_time_shifts_id_seq'::regclass),
  "taskrecurrency_id" int4 NOT NULL,
  "shift_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for tasks_taskrecurrency_shifts
-- ----------------------------
DROP TABLE IF EXISTS "public"."tasks_taskrecurrency_shifts";
CREATE TABLE "public"."tasks_taskrecurrency_shifts" (
  "id" int4 NOT NULL DEFAULT nextval('tasks_taskrecurrency_shifts_id_seq'::regclass),
  "taskrecurrency_id" int4 NOT NULL,
  "shift_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for tasks_taskstatusrecord
-- ----------------------------
DROP TABLE IF EXISTS "public"."tasks_taskstatusrecord";
CREATE TABLE "public"."tasks_taskstatusrecord" (
  "id" int4 NOT NULL DEFAULT nextval('tasks_taskstatusrecord_id_seq'::regclass),
  "status" varchar(32) COLLATE "pg_catalog"."default" NOT NULL,
  "signed_at" timestamptz(6) NOT NULL,
  "signed_by_id" int4 NOT NULL,
  "task_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for tasks_tasktemplate
-- ----------------------------
DROP TABLE IF EXISTS "public"."tasks_tasktemplate";
CREATE TABLE "public"."tasks_tasktemplate" (
  "id" int4 NOT NULL DEFAULT nextval('tasks_tasktemplate_id_seq'::regclass),
  "name" varchar(255) COLLATE "pg_catalog"."default" NOT NULL,
  "area_id" int4,
  "company_id" int4 NOT NULL,
  "picture" varchar(100) COLLATE "pg_catalog"."default",
  "description_file" varchar(100) COLLATE "pg_catalog"."default",
  "description" text COLLATE "pg_catalog"."default",
  "type" varchar(16) COLLATE "pg_catalog"."default" NOT NULL,
  "deeplink_id" int4,
  "deeplink_to" varchar(16) COLLATE "pg_catalog"."default",
  "role" varchar(16) COLLATE "pg_catalog"."default",
  "index" int4 NOT NULL,
  "created_at" timestamptz(6) NOT NULL,
  "modified_at" timestamptz(6) NOT NULL,
  "is_active" bool NOT NULL,
  "tags" text COLLATE "pg_catalog"."default",
  "weight" numeric(9,1) NOT NULL,
  "video" varchar(200) COLLATE "pg_catalog"."default",
  "video_thumbnail" varchar(100) COLLATE "pg_catalog"."default",
  "planned_time" int4,
  "machine_status" varchar(16) COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for tasks_tasktemplate_properties
-- ----------------------------
DROP TABLE IF EXISTS "public"."tasks_tasktemplate_properties";
CREATE TABLE "public"."tasks_tasktemplate_properties" (
  "id" int4 NOT NULL DEFAULT nextval('tasktemplateproperty_id_seq'::regclass),
  "company_id" int4 NOT NULL,
  "tasktemplate_id" int4 NOT NULL,
  "property_id" int4 NOT NULL,
  "propertyvalue_id" int4,
  "primary_int_value" int4,
  "secondary_int_value" int4,
  "primary_decimal_value" numeric(32,5),
  "secondary_decimal_value" numeric(32,5),
  "primary_datetime_value" timestamp(6),
  "secondary_datetime_value" timestamp(6),
  "primary_time_value" time(6),
  "secondary_time_value" time(6),
  "primary_string_value" text COLLATE "pg_catalog"."default",
  "secondary_string_value" text COLLATE "pg_catalog"."default",
  "bool_value" bool,
  "custom_value_type_display" varchar COLLATE "pg_catalog"."default",
  "custom_title_display" varchar COLLATE "pg_catalog"."default",
  "custom_display_type" varchar COLLATE "pg_catalog"."default",
  "display_type" int4,
  "is_required" bool DEFAULT false,
  "index" int4 NOT NULL DEFAULT 0,
  "is_active" bool NOT NULL DEFAULT true,
  "created_at" timestamp(6) NOT NULL DEFAULT now(),
  "modified_at" timestamp(6) NOT NULL DEFAULT now()
)
;

-- ----------------------------
-- Table structure for tasks_tasktemplate_tags_links
-- ----------------------------
DROP TABLE IF EXISTS "public"."tasks_tasktemplate_tags_links";
CREATE TABLE "public"."tasks_tasktemplate_tags_links" (
  "id" int4 NOT NULL DEFAULT nextval('tasks_tasktemplate_tags_links_id_seq'::regclass),
  "tasktemplate_id" int4 NOT NULL,
  "tasktemplatetag_id" int4 NOT NULL
)
;

-- ----------------------------
-- Table structure for tasks_tasktemplatestep
-- ----------------------------
DROP TABLE IF EXISTS "public"."tasks_tasktemplatestep";
CREATE TABLE "public"."tasks_tasktemplatestep" (
  "id" int4 NOT NULL DEFAULT nextval('tasks_tasktemplatestep_id_seq'::regclass),
  "index" int4 NOT NULL,
  "description" text COLLATE "pg_catalog"."default",
  "picture" varchar(100) COLLATE "pg_catalog"."default",
  "template_id" int4 NOT NULL,
  "created_at" timestamptz(6) NOT NULL,
  "modified_at" timestamptz(6) NOT NULL,
  "is_active" bool NOT NULL,
  "video" varchar(200) COLLATE "pg_catalog"."default",
  "video_thumbnail" varchar(100) COLLATE "pg_catalog"."default"
)
;

-- ----------------------------
-- Table structure for tasks_tasktemplatetag
-- ----------------------------
DROP TABLE IF EXISTS "public"."tasks_tasktemplatetag";
CREATE TABLE "public"."tasks_tasktemplatetag" (
  "id" int4 NOT NULL DEFAULT nextval('tasks_tasktemplatetag_id_seq'::regclass),
  "name" varchar(255) COLLATE "pg_catalog"."default" NOT NULL,
  "company_id" int4
)
;

-- ----------------------------
-- Table structure for uploads_requesteds3link
-- ----------------------------
DROP TABLE IF EXISTS "public"."uploads_requesteds3link";
CREATE TABLE "public"."uploads_requesteds3link" (
  "id" int4 NOT NULL DEFAULT nextval('uploads_requesteds3link_id_seq'::regclass),
  "url" varchar(200) COLLATE "pg_catalog"."default" NOT NULL,
  "created_at" timestamptz(6) NOT NULL,
  "company_id" int4 NOT NULL,
  "user_id" int4 NOT NULL
)
;

-- ----------------------------
-- Function structure for add_action
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_action"("_duedate" timestamp, "_comment" text, "_description" text, "_image0" varchar, "_image1" varchar, "_image2" varchar, "_image3" varchar, "_image4" varchar, "_image5" varchar, "_createdbyid" int4, "_taskid" int4, "_companyid" int4, "_tasktemplateid" int4, "_video0" varchar, "_video1" varchar, "_video2" varchar, "_video3" varchar, "_video4" varchar, "_video5" varchar, "_videothumbnail0" varchar, "_videothumbnail1" varchar, "_videothumbnail2" varchar, "_videothumbnail3" varchar, "_videothumbnail4" varchar, "_videothumbnail5" varchar);
CREATE OR REPLACE FUNCTION "public"."add_action"("_duedate" timestamp, "_comment" text, "_description" text, "_image0" varchar, "_image1" varchar, "_image2" varchar, "_image3" varchar, "_image4" varchar, "_image5" varchar, "_createdbyid" int4, "_taskid" int4, "_companyid" int4, "_tasktemplateid" int4, "_video0" varchar, "_video1" varchar, "_video2" varchar, "_video3" varchar, "_video4" varchar, "_video5" varchar, "_videothumbnail0" varchar, "_videothumbnail1" varchar, "_videothumbnail2" varchar, "_videothumbnail3" varchar, "_videothumbnail4" varchar, "_videothumbnail5" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO actions_action
(id, created_at, due_date, is_resolved, comment, description, image_0, image_1, image_2, image_3, image_4, image_5, created_by_id, task_id, resolved_at, company_id, modified_at, is_active, task_template_id, video_0, video_1, video_2, video_3, video_4, video_5, video_thumbnail_0, video_thumbnail_1, video_thumbnail_2, video_thumbnail_3, video_thumbnail_4, video_thumbnail_5) 
VALUES (
DEFAULT, 
now()::timestamp, 
_duedate, 
false, 
_comment, 
_description, 
_image0, 
_image1, 
_image2, 
_image3, 
_image4, 
_image5, 
_createdbyid, 
_taskid, 
NULL, 
_companyid, 
now()::timestamp, 
true, 
_tasktemplateid, 
_video0, 
_video1, 
_video2, 
_video3, 
_video4, 
_video5, 
_videothumbnail0, 
_videothumbnail1, 
_videothumbnail2, 
_videothumbnail3, 
_videothumbnail4, 
_videothumbnail5
) 
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_action
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_action"("_duedate" timestamp, "_comment" text, "_description" text, "_createdbyid" int4, "_taskid" int4, "_companyid" int4, "_tasktemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."add_action"("_duedate" timestamp, "_comment" text, "_description" text, "_createdbyid" int4, "_taskid" int4, "_companyid" int4, "_tasktemplateid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO actions_action
(id, created_at, due_date, is_resolved, comment, description, created_by_id, task_id, resolved_at, company_id, modified_at, is_active, task_template_id) 
VALUES (
DEFAULT, 
now()::timestamp, 
_duedate, 
false, 
_comment, 
_description,  
_createdbyid, 
_taskid, 
NULL, 
_companyid, 
now()::timestamp, 
true, 
_tasktemplateid
) 
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_action
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_action"("_duedate" timestamp, "_comment" text, "_description" text, "_image0" varchar, "_image1" varchar, "_image2" varchar, "_image3" varchar, "_image4" varchar, "_image5" varchar, "_createdbyid" int4, "_taskid" int4, "_companyid" int4, "_tasktemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."add_action"("_duedate" timestamp, "_comment" text, "_description" text, "_image0" varchar, "_image1" varchar, "_image2" varchar, "_image3" varchar, "_image4" varchar, "_image5" varchar, "_createdbyid" int4, "_taskid" int4, "_companyid" int4, "_tasktemplateid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO actions_action
(id, created_at, due_date, is_resolved, comment, description, image_0, image_1, image_2, image_3, image_4, image_5, created_by_id, task_id, resolved_at, company_id, modified_at, is_active, task_template_id) 
VALUES (
DEFAULT, 
now()::timestamp, 
_duedate, 
false, 
_comment, 
_description, 
_image0, 
_image1, 
_image2, 
_image3, 
_image4, 
_image5, 
_createdbyid, 
_taskid, 
NULL, 
_companyid, 
now()::timestamp, 
true, 
_tasktemplateid
) 
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_action_assigned_area
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_action_assigned_area"("_actionid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."add_action_assigned_area"("_actionid" int4, "_areaid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	SELECT aaas."id" INTO _id FROM actions_action_assigned_areas aaas WHERE area_id = _areaid AND action_id = _actionid;
	IF _id IS NULL OR _id < 1 THEN
		INSERT INTO actions_action_assigned_areas (id, action_id, area_id)
		VALUES (DEFAULT, _actionid, _areaid) 
		RETURNING id INTO _id;
	END IF;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_action_assigned_user
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_action_assigned_user"("_actionid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."add_action_assigned_user"("_actionid" int4, "_userid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	SELECT aaas."id" INTO _id FROM actions_action_assigned_users aaas WHERE user_id = _userid AND action_id = _actionid;
	IF _id IS NULL OR _id < 1 THEN
		INSERT INTO actions_action_assigned_users (id, action_id, user_id)
		VALUES (DEFAULT, _actionid, _userid) 
		RETURNING id INTO _id;
	END IF;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_actioncomment
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_actioncomment"("_comment" text, "_actionid" int4, "_userid" int4, "_companyid" int4, "_video" varchar, "_videothumbnail" varchar);
CREATE OR REPLACE FUNCTION "public"."add_actioncomment"("_comment" text, "_actionid" int4, "_userid" int4, "_companyid" int4, "_video" varchar, "_videothumbnail" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO actions_actioncomment (id, comment, action_id, user_id, created_at, company_id, modified_at, is_active, video, video_thumbnail) 
VALUES (
DEFAULT, 
_comment,  
_actionid, 
_userid, 
now()::timestamp, 
_companyid, 
now()::timestamp, 
true, 
_video, 
_videothumbnail
) 
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_actioncomment
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_actioncomment"("_comment" text, "_image0" varchar, "_image1" varchar, "_image2" varchar, "_image3" varchar, "_image4" varchar, "_actionid" int4, "_userid" int4, "_companyid" int4, "_video" varchar, "_videothumbnail" varchar);
CREATE OR REPLACE FUNCTION "public"."add_actioncomment"("_comment" text, "_image0" varchar, "_image1" varchar, "_image2" varchar, "_image3" varchar, "_image4" varchar, "_actionid" int4, "_userid" int4, "_companyid" int4, "_video" varchar, "_videothumbnail" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO actions_actioncomment (id, comment, image_0, image_1, image_2, image_3, image_4, action_id, user_id, created_at, company_id, modified_at, is_active, video, video_thumbnail) 
VALUES (
DEFAULT, 
_comment, 
_image0, 
_image1, 
_image2, 
_image3, 
_image4, 
_actionid, 
_userid, 
now()::timestamp, 
_companyid, 
now()::timestamp, 
true, 
_video, 
_videothumbnail
) 
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_announcement
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_announcement"("_title" varchar, "_description" text, "_announcementdate" timestamp, "_announcementtype" int4);
CREATE OR REPLACE FUNCTION "public"."add_announcement"("_title" varchar, "_description" text, "_announcementdate" timestamp, "_announcementtype" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO announcement (id, title, description, announcement_date, created_on, announcement_type) 
	VALUES (DEFAULT, _title, _description, _announcementdate, NOW()::timestamp, _announcementtype) 
	RETURNING id INTO _id;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_area
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_area"("_name" varchar, "_description" text, "_companyid" int4, "_picture" varchar, "_parentid" int4, "_systemrole" varchar);
CREATE OR REPLACE FUNCTION "public"."add_area"("_name" varchar, "_description" text, "_companyid" int4, "_picture" varchar, "_parentid" int4, "_systemrole" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
		_level int4;
		_lft int4;
		_rght int4;
		_treeid int4;
		_daystogetdata int4;
		_customshifts bool; 
		_issystem bool;
	BEGIN
	_issystem = false;
	_customshifts = false;
	_daystogetdata = 30; --default days to get data
	_level = 0; --default level
	_lft = 1; --default lft value
	_rght = 2;
	IF _parentid IS NOT NULL AND _parentid > 0 THEN
		-- Generate level, if parent use parents above to generate level.
		SELECT COUNT(CN.id)::int4 INTO _level FROM get_area_nodes_from_leaf_to_root(_companyid, _parentid) CN;
		SELECT CA.tree_id INTO _treeid FROM companies_area CA WHERE CA.id = _parentid AND CA.company_id = _companyid;
		-- Generate lft value
		-- NOTE! will need to change to specific other value; 
		SELECT (MAX(T.cnt) + 1)::int4 INTO _lft FROM (
			SELECT CA1.rght AS cnt FROM companies_area CA1 WHERE tree_id = _treeid AND company_id = _companyid
			UNION 
			SELECT CA2.lft AS cnt FROM companies_area CA2 WHERE tree_id = _treeid AND company_id = _companyid
		) AS T;
		-- Generate rght value
		-- NOTE! will need to change to specific other value; 
		_rght = (_lft + 1)::int4;
	ELSE
	  -- Set tree id for new tree (e.g. new primary item at level 0)
		SELECT (MAX(tree_id) + 1)::int4 INTO _treeid FROM companies_area CA;
	END IF;
	INSERT INTO companies_area (id, name, description, company_id, picture, level, lft, parent_id, rght, tree_id, is_active, system_role, days_to_get_data,created_at, modified_at, custom_shifts, is_system) 
VALUES(
DEFAULT, 
_name, 
_description, 
_companyid, 
_picture, 
_level, 
_lft, 
_parentid, 
_rght, 
_treeid, 
true, 
_systemrole, 
_daystogetdata, 
now()::timestamp, 
now()::timestamp, 
_customshifts, 
_issystem) 
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_area
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_area"("_name" varchar, "_description" text, "_companyid" int4, "_picture" varchar, "_level" int4, "_lft" int4, "_parentid" int4, "_rght" int4, "_treeid" int4, "_systemrole" varchar, "_daystogetdata" int4, "_customshifts" bool, "_issystem" bool);
CREATE OR REPLACE FUNCTION "public"."add_area"("_name" varchar, "_description" text, "_companyid" int4, "_picture" varchar, "_level" int4, "_lft" int4, "_parentid" int4, "_rght" int4, "_treeid" int4, "_systemrole" varchar, "_daystogetdata" int4, "_customshifts" bool, "_issystem" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO companies_area (id, name, description, company_id, picture, level, lft, parent_id, rght, tree_id, is_active, system_role, days_to_get_data,created_at, modified_at, custom_shifts, is_system) 
VALUES(
DEFAULT, 
_name, 
_description, 
_companyid, 
_picture, 
_level, 
_lft, 
_parentid, 
_rght, 
_treeid, 
true, 
_systemrole, 
_daystogetdata, 
now()::timestamp, 
now()::timestamp, 
_customshifts, 
_issystem) 
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_audit
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_audit"("_companyid" int4, "_templateid" int4, "_totalscore" int2, "_signature1" varchar, "_signature2" varchar, "_signedat1" timestamptz, "_signedat2" timestamptz, "_signedbyid1" int4, "_signedby2" varchar, "_iscompleted" bool);
CREATE OR REPLACE FUNCTION "public"."add_audit"("_companyid" int4, "_templateid" int4, "_totalscore" int2, "_signature1" varchar, "_signature2" varchar, "_signedat1" timestamptz, "_signedat2" timestamptz, "_signedbyid1" int4, "_signedby2" varchar, "_iscompleted" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO audits_audit (id, company_id, template_id, total_score, signature_1, signature_2, signed_at_1, signed_at_2, signed_by_1_id, signed_by_2, created_at, modified_at, is_active, is_complete) 
VALUES (
DEFAULT, 
_companyid, 
_templateid, 
_totalscore, 
_signature1, 
_signature2, 
_signedat1,
_signedat2, 
_signedbyid1, 
_signedby2, 
now()::timestamp, 
now()::timestamp, 
true,
_iscompleted)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_audit
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_audit"("_companyid" int4, "_templateid" int4, "_totalscore" int2, "_signature1" varchar, "_signature2" varchar, "_signedat1" timestamptz, "_signedat2" timestamptz, "_signedbyid1" int4, "_signedby2" varchar);
CREATE OR REPLACE FUNCTION "public"."add_audit"("_companyid" int4, "_templateid" int4, "_totalscore" int2, "_signature1" varchar, "_signature2" varchar, "_signedat1" timestamptz, "_signedat2" timestamptz, "_signedbyid1" int4, "_signedby2" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO audits_audit (id, company_id, template_id, is_complete, total_score, signature_1, signature_2, signed_at_1, signed_at_2, signed_by_1_id, signed_by_2, created_at, modified_at, is_active ) 
VALUES (
DEFAULT, 
_companyid, 
_templateid, 
false, 
_totalscore, 
_signature1, 
_signature2, 
_signedat1,
_signedat2, 
_signedbyid1, 
_signedby2, 
now()::timestamp, 
now()::timestamp, 
true)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_audit_property
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_audit_property"("_companyid" int4, "_auditid" int4, "_propertyid" int4, "_templatepropertyid" int4, "_userid" int4, "_value_int" int4, "_value_string" text, "_value_decimal" numeric, "_value_time" time, "_value_date" timestamp, "_value_bool" bool);
CREATE OR REPLACE FUNCTION "public"."add_audit_property"("_companyid" int4, "_auditid" int4, "_propertyid" int4, "_templatepropertyid" int4, "_userid" int4, "_value_int" int4, "_value_string" text, "_value_decimal" numeric, "_value_time" time, "_value_date" timestamp, "_value_bool" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO audits_properties (
	"id",
	"company_id", 
	"audit_id", 
	"property_id", 
	"template_property_id",
	"user_id", 
	"value_int", 
	"value_string", 
	"value_decimal", 
	"value_time", 
	"value_date", 
	"value_bool",
	"created_at",
	"modified_at"
) 
VALUES (
	DEFAULT, 
	_companyid, 
	_auditid, 
	_propertyid, 
	_templatepropertyid,
	_userid, 
	_value_int,
	_value_string, 
	_value_decimal,
	_value_time, 
	_value_date, 
	_value_bool,
	NOW(),
	NOW()
)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_audit_task_relation
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_audit_task_relation"("_companyid" int4, "_auditid" int4, "_taskid" int4);
CREATE OR REPLACE FUNCTION "public"."add_audit_task_relation"("_companyid" int4, "_auditid" int4, "_taskid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
	 INSERT INTO audits_audit_tasks(audit_id, task_id) SELECT _auditid, TT.id AS task_id FROM tasks_task TT WHERE TT.company_id = _companyid AND TT.id = _taskid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_audittemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_audittemplate"("_name" varchar, "_doublesignaturerequired" bool, "_scoretype" varchar, "_areaid" int4, "_companyid" int4, "_signaturerequired" bool, "_description" text, "_picture" varchar, "_role" varchar, "_mintaskscore" int4, "_maxtaskscore" int4);
CREATE OR REPLACE FUNCTION "public"."add_audittemplate"("_name" varchar, "_doublesignaturerequired" bool, "_scoretype" varchar, "_areaid" int4, "_companyid" int4, "_signaturerequired" bool, "_description" text=NULL::text, "_picture" varchar=NULL::character varying, "_role" varchar=NULL::character varying, "_mintaskscore" int4=NULL::integer, "_maxtaskscore" int4=NULL::integer)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO audits_audittemplate (id, name, description, picture, double_signature_required, score_type, min_task_score, max_task_score, area_id, company_id, role, signature_required, created_at, modified_at, is_active) 
VALUES (
DEFAULT, 
_name, 
_description, 
_picture, 
_doublesignaturerequired, 
_scoretype, 
_mintaskscore, 
_maxtaskscore, 
_areaid, 
_companyid, 
_role, 
_signaturerequired, 
now()::timestamp, 
now()::timestamp, 
true)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_audittemplate_property
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_audittemplate_property"("_companyid" int4, "_audittemplateid" int4, "_propertyid" int4, "_propertyvalueid" int4, "_primary_int_value" int4, "_secondary_int_value" int4, "_primary_decimal_value" numeric, "_secondary_decimal_value" numeric, "_primary_datetime_value" timestamp, "_secondary_datetime_value" timestamp, "_primary_time_value" time, "_secondary_time_value" time, "_primary_string_value" text, "_secondary_string_value" text, "_bool_value" bool, "_custom_value_type_display" varchar, "_custom_title_display" varchar, "_custom_display_type" varchar, "_display_type" int4, "_is_required" bool, "_index" int4);
CREATE OR REPLACE FUNCTION "public"."add_audittemplate_property"("_companyid" int4, "_audittemplateid" int4, "_propertyid" int4, "_propertyvalueid" int4, "_primary_int_value" int4, "_secondary_int_value" int4, "_primary_decimal_value" numeric, "_secondary_decimal_value" numeric, "_primary_datetime_value" timestamp, "_secondary_datetime_value" timestamp, "_primary_time_value" time, "_secondary_time_value" time, "_primary_string_value" text, "_secondary_string_value" text, "_bool_value" bool, "_custom_value_type_display" varchar, "_custom_title_display" varchar, "_custom_display_type" varchar, "_display_type" int4, "_is_required" bool, "_index" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO audits_audittemplate_properties (
	"id", 
	"company_id" ,
	"audittemplate_id",
	"property_id",
	"propertyvalue_id",
	"primary_int_value",
	"secondary_int_value",
	"primary_decimal_value",
	"secondary_decimal_value",
	"primary_datetime_value",
	"secondary_datetime_value",
	"primary_time_value",
	"secondary_time_value",
	"primary_string_value",
	"secondary_string_value",
	"bool_value",
	"custom_value_type_display",
	"custom_title_display",
	"custom_display_type",
	"display_type",
	"is_required",
	"index",
	"created_at",
	"modified_at") 
VALUES (
DEFAULT, 
	_companyid,
	_audittemplateid,
	_propertyid,
	_propertyvalueid,
	_primary_int_value,
	_secondary_int_value,
	_primary_decimal_value,
	_secondary_decimal_value,
	_primary_datetime_value,
	_secondary_datetime_value,
	_primary_time_value,
	_secondary_time_value,
	_primary_string_value,
	_secondary_string_value,
	_bool_value,
	_custom_value_type_display,
	_custom_title_display,
	_custom_display_type,
	_display_type,
	_is_required,
	_index,
	NOW(),
	NOW()
)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_checklist
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_checklist"("_companyid" int4, "_templateid" int4, "_signedbyid1" int4, "_signature1" varchar, "_signedat1" timestamptz, "_signature2" varchar, "_signedby2" varchar, "_signedat2" timestamptz, "_iscompleted" bool);
CREATE OR REPLACE FUNCTION "public"."add_checklist"("_companyid" int4, "_templateid" int4, "_signedbyid1" int4, "_signature1" varchar, "_signedat1" timestamptz, "_signature2" varchar, "_signedby2" varchar, "_signedat2" timestamptz, "_iscompleted" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO checklists_checklist (id, company_id, template_id, signed_by_1_id, signature_1, signed_at_1,signature_2, signed_by_2, signed_at_2, is_complete, created_at, modified_at, is_active) 
VALUES (
DEFAULT, 
_companyid, 
_templateid, 
_signedbyid1, 
_signature1, 
_signedat1, 
_signature2, 
_signedby2, 
_signedat2, 
_iscompleted, 
now()::timestamp, 
now()::timestamp, 
true) 
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_checklist_property
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_checklist_property"("_companyid" int4, "_checklistid" int4, "_propertyid" int4, "_templatepropertyid" int4, "_userid" int4, "_value_int" int4, "_value_string" text, "_value_decimal" numeric, "_value_time" time, "_value_date" timestamp, "_value_bool" bool);
CREATE OR REPLACE FUNCTION "public"."add_checklist_property"("_companyid" int4, "_checklistid" int4, "_propertyid" int4, "_templatepropertyid" int4, "_userid" int4, "_value_int" int4, "_value_string" text, "_value_decimal" numeric, "_value_time" time, "_value_date" timestamp, "_value_bool" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO checklists_properties (
	"id",
	"company_id", 
	"checklist_id", 
	"property_id", 
	"template_property_id",
	"user_id", 
	"value_int", 
	"value_string", 
	"value_decimal", 
	"value_time", 
	"value_date", 
	"value_bool",
	"created_at",
	"modified_at"
) 
VALUES (
	DEFAULT, 
	_companyid, 
	_checklistid, 
	_propertyid, 
	_templatepropertyid,
	_userid, 
	_value_int,
	_value_string, 
	_value_decimal,
	_value_time, 
	_value_date, 
	_value_bool,
	NOW(),
	NOW()
)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_checklist_task_relation
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_checklist_task_relation"("_companyid" int4, "_checklistid" int4, "_taskid" int4);
CREATE OR REPLACE FUNCTION "public"."add_checklist_task_relation"("_companyid" int4, "_checklistid" int4, "_taskid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
	 INSERT INTO checklists_checklist_tasks(checklist_id, task_id) SELECT _checklistid, TT.id AS task_id FROM tasks_task TT WHERE TT.company_id = _companyid AND TT.id = _taskid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_checklisttemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_checklisttemplate"("_name" varchar, "_areaid" int4, "_companyid" int4, "_doublesignaturerequired" bool, "_signaturerequired" bool, "_role" varchar, "_description" text, "_picture" varchar);
CREATE OR REPLACE FUNCTION "public"."add_checklisttemplate"("_name" varchar, "_areaid" int4, "_companyid" int4, "_doublesignaturerequired" bool, "_signaturerequired" bool, "_role" varchar=NULL::character varying, "_description" text=NULL::text, "_picture" varchar=NULL::character varying)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO checklists_checklisttemplate (id, name, description, picture, area_id, company_id, double_signature_required, role, created_at, modified_at, is_active, signature_required) 
VALUES (
DEFAULT, 
_name, 
_description, 
_picture, 
_areaid, 
_companyid, 
_doublesignaturerequired, 
_role, 
now()::timestamp, 
now()::timestamp, 
true,
_signaturerequired)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_checklisttemplate_property
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_checklisttemplate_property"("_companyid" int4, "_checklisttemplateid" int4, "_propertyid" int4, "_propertyvalueid" int4, "_primary_int_value" int4, "_secondary_int_value" int4, "_primary_decimal_value" numeric, "_secondary_decimal_value" numeric, "_primary_datetime_value" timestamp, "_secondary_datetime_value" timestamp, "_primary_time_value" time, "_secondary_time_value" time, "_primary_string_value" text, "_secondary_string_value" text, "_bool_value" bool, "_custom_value_type_display" varchar, "_custom_title_display" varchar, "_custom_display_type" varchar, "_display_type" int4, "_is_required" bool, "_index" int4);
CREATE OR REPLACE FUNCTION "public"."add_checklisttemplate_property"("_companyid" int4, "_checklisttemplateid" int4, "_propertyid" int4, "_propertyvalueid" int4, "_primary_int_value" int4, "_secondary_int_value" int4, "_primary_decimal_value" numeric, "_secondary_decimal_value" numeric, "_primary_datetime_value" timestamp, "_secondary_datetime_value" timestamp, "_primary_time_value" time, "_secondary_time_value" time, "_primary_string_value" text, "_secondary_string_value" text, "_bool_value" bool, "_custom_value_type_display" varchar, "_custom_title_display" varchar, "_custom_display_type" varchar, "_display_type" int4, "_is_required" bool, "_index" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO checklists_checklisttemplate_properties (
	"id", 
	"company_id" ,
	"checklisttemplate_id",
	"property_id",
	"propertyvalue_id",
	"primary_int_value",
	"secondary_int_value",
	"primary_decimal_value",
	"secondary_decimal_value",
	"primary_datetime_value",
	"secondary_datetime_value",
	"primary_time_value",
	"secondary_time_value",
	"primary_string_value",
	"secondary_string_value",
	"bool_value",
	"custom_value_type_display",
	"custom_title_display",
	"custom_display_type",
	"display_type",
	"is_required",
	"index",
	"created_at",
	"modified_at") 
VALUES (
DEFAULT, 
	_companyid,
	_checklisttemplateid,
	_propertyid,
	_propertyvalueid,
	_primary_int_value,
	_secondary_int_value,
	_primary_decimal_value,
	_secondary_decimal_value,
	_primary_datetime_value,
	_secondary_datetime_value,
	_primary_time_value,
	_secondary_time_value,
	_primary_string_value,
	_secondary_string_value,
	_bool_value,
	_custom_value_type_display,
	_custom_title_display,
	_custom_display_type,
	_display_type,
	_is_required,
	_index,
	NOW(),
	NOW()
)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_comment
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_comment"("_companyid" int4, "_userid" int4, "_taskid" int4, "_tasktemplateid" int4, "_comment" text, "_commentdate" timestamp, "_description" text, "_attachments" text);
CREATE OR REPLACE FUNCTION "public"."add_comment"("_companyid" int4, "_userid" int4, "_taskid" int4, "_tasktemplateid" int4, "_comment" text, "_commentdate" timestamp, "_description" text, "_attachments" text)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO comments (id, company_id, user_id, task_id, tasktemplate_id, comment, comment_date, description, attachments, is_active, created_at, modified_at) 
	VALUES (DEFAULT, _companyid, _userid, _taskid, _tasktemplateid, _comment, _commentdate, _description, _attachments, true, NOW(), NOW())
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_company"("_name" varchar, "_description" text, "_picture" varchar, "_managerid" int4);
CREATE OR REPLACE FUNCTION "public"."add_company"("_name" varchar, "_description" text, "_picture" varchar, "_managerid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO companies_company (id, name, description, picture,  manager_id, created_at, modified_at, is_active, logoff_after) 
VALUES (
DEFAULT, 
_name, 
_description, 
_picture, 
_managerid, 
now()::timestamp, 
now()::timestamp, 
true, 
60)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_factoryfeed
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_factoryfeed"("_companyid" int4, "_name" varchar, "_description" text, "_attachments" text, "_data" text, "_feedtype" int4);
CREATE OR REPLACE FUNCTION "public"."add_factoryfeed"("_companyid" int4, "_name" varchar, "_description" text, "_attachments" text, "_data" text, "_feedtype" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO factoryfeeds (id, company_id, name, description, attachments, data, feed_type, is_active) VALUES (DEFAULT, _companyid, _name, _description, _attachments, _data, _feedtype, true)
	RETURNING id INTO _id;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_factoryfeed_message
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_factoryfeed_message"("_companyid" int4, "_factoryfeedid" int4, "_userid" int4, "_title" varchar, "_description" text, "_attachments" text, "_issticky" bool, "_ishighlighted" bool, "_messagetype" int4, "_data" text, "_messagedate" timestamp, "_parentid" int4);
CREATE OR REPLACE FUNCTION "public"."add_factoryfeed_message"("_companyid" int4, "_factoryfeedid" int4, "_userid" int4, "_title" varchar, "_description" text, "_attachments" text, "_issticky" bool, "_ishighlighted" bool, "_messagetype" int4, "_data" text, "_messagedate" timestamp, "_parentid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO factoryfeed_messages ("id","company_id","factoryfeed_id","user_id","title","description","attachments","is_sticky","is_highlighted","message_type","data","message_date","created_at","modified_at", "is_active", "parent_id")
	VALUES (DEFAULT, _companyid, _factoryfeedid, _userid, _title, _description, _attachments, _issticky, _ishighlighted, _messagetype, _data, _messagedate, NOW(), NOW(), true, _parentid) 
	RETURNING id INTO _id;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_factoryfeed_message
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_factoryfeed_message"("_companyid" int4, "_factoryfeedid" int4, "_userid" int4, "_title" varchar, "_description" text, "_attachments" text, "_issticky" bool, "_ishighlighted" bool, "_messagetype" int4, "_data" text, "_messagedate" timestamp);
CREATE OR REPLACE FUNCTION "public"."add_factoryfeed_message"("_companyid" int4, "_factoryfeedid" int4, "_userid" int4, "_title" varchar, "_description" text, "_attachments" text, "_issticky" bool, "_ishighlighted" bool, "_messagetype" int4, "_data" text, "_messagedate" timestamp)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO factoryfeed_messages ("id","company_id","factoryfeed_id","user_id","title","description","attachments","is_sticky","is_highlighted","message_type","data","message_date","created_at","modified_at", "is_active")
	VALUES (DEFAULT, _companyid, _factoryfeedid, _userid, _title, _description, _attachments, _issticky, _ishighlighted, _messagetype, _data, _messagedate, NOW(), NOW(), true) 
	RETURNING id INTO _id;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_log
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_log"("_message" varchar, "_type" varchar, "_eventid" varchar, "_eventname" varchar, "_description" text);
CREATE OR REPLACE FUNCTION "public"."add_log"("_message" varchar, "_type" varchar, "_eventid" varchar, "_eventname" varchar, "_description" text)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO logging_log (id, message, type, eventid, eventname, description, created_on)
	VALUES (DEFAULT, _message, _type, _eventid, _eventname, _description, now()::timestamp) 
	RETURNING id INTO _id;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_log
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_log"("_message" varchar, "_type" varchar, "_eventid" varchar, "_eventname" varchar, "_description" text, "_source" varchar);
CREATE OR REPLACE FUNCTION "public"."add_log"("_message" varchar, "_type" varchar, "_eventid" varchar, "_eventname" varchar, "_description" text, "_source" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO logging_log (id, message, type, eventid, eventname, description, source, created_on)
	VALUES (DEFAULT, _message, _type, _eventid, _eventname, _description, _source, now()::timestamp) 
	RETURNING id INTO _id;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_log_data_auditing
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_log_data_auditing"("_original_object" text, "_mutated_object" text, "_object_type" varchar, "_object_id" int4, "_company_id" int4, "_user_id" int4, "_description" text);
CREATE OR REPLACE FUNCTION "public"."add_log_data_auditing"("_original_object" text, "_mutated_object" text, "_object_type" varchar, "_object_id" int4, "_company_id" int4, "_user_id" int4, "_description" text)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO logging_data_auditing (id, original_object, mutated_object, object_type, object_id, company_id, user_id, description, created_on)
	VALUES (DEFAULT, _original_object, _mutated_object, _object_type, _object_id, _company_id, _user_id, _description, now()::timestamp) 
	RETURNING id INTO _id;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_log_requestresponse
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_log_requestresponse"("_domain" varchar, "_path" varchar, "_query" varchar, "_status" varchar, "_header" varchar, "_request" varchar, "_response" varchar);
CREATE OR REPLACE FUNCTION "public"."add_log_requestresponse"("_domain" varchar, "_path" varchar, "_query" varchar, "_status" varchar, "_header" varchar, "_request" varchar, "_response" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO logging_requestresponse (id,domain,path,query,status,header,request,response, created_on)
	VALUES (DEFAULT, _domain, _path, _query, _status, _header, _request, _response, now()::timestamp) 
	RETURNING id INTO _id;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_profile_user_areas
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_profile_user_areas"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."add_profile_user_areas"("_companyid" int4, "_userid" int4, "_areaid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	INSERT INTO profiles_user_areas (user_id, area_id) SELECT _userid, CA.id FROM companies_area CA WHERE CA.id =  _areaid AND CA.company_id = _companyid;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_resource_language_key
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_resource_language_key"("_key" varchar, "_guid" varchar, "_description" varchar);
CREATE OR REPLACE FUNCTION "public"."add_resource_language_key"("_key" varchar, "_guid" varchar, "_description" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	SELECT RC."id" INTO _id FROM resource_languages RC WHERE resource_key = _key;
	IF _id IS NULL OR _id < 1 THEN
		INSERT INTO resource_languages(resource_key, resource_guid, description) VALUES (_key, _guid, _description)
		RETURNING id INTO _id;
	END IF;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_resource_language_key
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_resource_language_key"("_key" varchar, "_guid" varchar, "_description" varchar, "_culture" varchar, "_value" varchar);
CREATE OR REPLACE FUNCTION "public"."add_resource_language_key"("_key" varchar, "_guid" varchar, "_description" varchar, "_culture" varchar, "_value" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	SELECT RC."id" INTO _id FROM resource_languages RC WHERE resource_key = _key;
	IF _id IS NULL OR _id < 1 THEN
		EXECUTE format('INSERT INTO resource_languages(id, resource_key, resource_guid, description, %I) VALUES (DEFAULT, %L, %L, %L, %L) RETURNING id', _culture, _key, _guid, _description, _value)
		INTO _id;
	END IF;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_resource_setting_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_resource_setting_company"("_companyid" int4, "_description" text, "_resourceid" int4, "_value" text);
CREATE OR REPLACE FUNCTION "public"."add_resource_setting_company"("_companyid" int4, "_description" text, "_resourceid" int4, "_value" text)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO companies_setting (id, company_id, description, resource_setting_id, value)
	VALUES (DEFAULT, _companyid, _description, _resourceid, _value) 
	RETURNING id INTO _id;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_shift
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_shift"("_companyid" int4, "_day" int2, "_start" time, "_end" time, "_areaid" int4, "_weekday" int2);
CREATE OR REPLACE FUNCTION "public"."add_shift"("_companyid" int4, "_day" int2, "_start" time, "_end" time, "_areaid" int4, "_weekday" int2)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO companies_shift (id, "day", "start", "end", company_id, area_id, created_at, modified_at, is_active, weekday) 
VALUES (
DEFAULT, 
_day, 
_start, 
_end, 
_companyid, 
_areaid, 
now()::timestamp, 
now()::timestamp, 
true, 
_weekday
)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_task
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_task"("_status" varchar, "_signedat" timestamptz, "_comment" text, "_signedbyid" int4, "_templateid" int4, "_companyid" int4, "_recurrencyid" int4, "_score" int4, "_enddate" date, "_startdate" date, "_deviance" int4, "_maxscore" int4, "_totalscore" int4, "_dueat" timestamptz, "_startat" timestamptz, "_shiftid" int4, "_time_realized_by_id" int4, "_time_taken" int4);
CREATE OR REPLACE FUNCTION "public"."add_task"("_status" varchar, "_signedat" timestamptz, "_comment" text, "_signedbyid" int4, "_templateid" int4, "_companyid" int4, "_recurrencyid" int4, "_score" int4, "_enddate" date, "_startdate" date, "_deviance" int4, "_maxscore" int4, "_totalscore" int4, "_dueat" timestamptz, "_startat" timestamptz, "_shiftid" int4, "_time_realized_by_id" int4, "_time_taken" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO tasks_task (id, status, signed_at, comment, signed_by_id, template_id, company_id, recurrency_id, score, created_at, modified_at, is_active, end_date, start_date, shift_id, deviance, max_score, total_score, due_at, start_at, time_realized_by_id, time_taken) 
VALUES (
DEFAULT, 
_status, 
_signedat, 
_comment, 
_signedbyid, 
_templateid, 
_companyid, 
_recurrencyid, 
_score, 
now()::timestamp, 
now()::timestamp, 
true, 
_enddate, 
_startdate, 
_shiftid, 
_deviance, 
_maxscore, 
_totalscore, 
_dueat, 
_startat,
_time_realized_by_id,
_time_taken
)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_task
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_task"("_status" varchar, "_signedat" timestamptz, "_comment" text, "_signedbyid" int4, "_templateid" int4, "_companyid" int4, "_recurrencyid" int4, "_score" int4, "_enddate" date, "_startdate" date, "_deviance" int4, "_maxscore" int4, "_totalscore" int4, "_dueat" timestamptz, "_startat" timestamptz, "_shiftid" int4);
CREATE OR REPLACE FUNCTION "public"."add_task"("_status" varchar, "_signedat" timestamptz, "_comment" text, "_signedbyid" int4, "_templateid" int4, "_companyid" int4, "_recurrencyid" int4, "_score" int4, "_enddate" date, "_startdate" date, "_deviance" int4, "_maxscore" int4, "_totalscore" int4, "_dueat" timestamptz, "_startat" timestamptz, "_shiftid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO tasks_task (id, status, signed_at, comment, signed_by_id, template_id, company_id, recurrency_id, score, created_at, modified_at, is_active, end_date, start_date, shift_id, deviance, max_score, total_score, due_at, start_at) 
VALUES (
DEFAULT, 
_status, 
_signedat, 
_comment, 
_signedbyid, 
_templateid, 
_companyid, 
_recurrencyid, 
_score, 
now()::timestamp, 
now()::timestamp, 
true, 
_enddate, 
_startdate, 
_shiftid, 
_deviance, 
_maxscore, 
_totalscore, 
_dueat, 
_startat
)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_task_property
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_task_property"("_companyid" int4, "_taskid" int4, "_propertyid" int4, "_tasktemplatepropertyid" int4, "_userid" int4, "_value_int" int4, "_value_string" text, "_value_decimal" numeric, "_value_time" time, "_value_date" timestamp, "_value_bool" bool);
CREATE OR REPLACE FUNCTION "public"."add_task_property"("_companyid" int4, "_taskid" int4, "_propertyid" int4, "_tasktemplatepropertyid" int4, "_userid" int4, "_value_int" int4, "_value_string" text, "_value_decimal" numeric, "_value_time" time, "_value_date" timestamp, "_value_bool" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO tasks_properties (
	"id",
	"company_id", 
	"task_id", 
	"property_id", 
	"template_property_id",
	"user_id", 
	"value_int", 
	"value_string", 
	"value_decimal", 
	"value_time", 
	"value_date", 
	"value_bool",
	"created_at",
	"modified_at"
) 
VALUES (
	DEFAULT, 
	_companyid, 
	_taskid, 
	_propertyid, 
	_tasktemplatepropertyid,
	_userid, 
	_value_int,
	_value_string, 
	_value_decimal,
	_value_time, 
	_value_date, 
	_value_bool,
	NOW(),
	NOW()
)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_taskrecurrency
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_taskrecurrency"("_type" varchar, "_date" date, "_week" int4, "_day" int4, "_month" int4, "_companyid" int4, "_shiftid" int4, "_templateid" int4, "_areaid" int4, "_enddate" date, "_startdate" date, "_weekday0" bool, "_weekday1" bool, "_weekday2" bool, "_weekday3" bool, "_weekday4" bool, "_weekday5" bool, "_weekday6" bool, "_monthrecurrency" varchar, "_weekday" int4, "_weekdaynumber" int4, "_isoncepermonth" bool, "_isonceperweek" bool, "_lastsignedat" date);
CREATE OR REPLACE FUNCTION "public"."add_taskrecurrency"("_type" varchar, "_date" date, "_week" int4, "_day" int4, "_month" int4, "_companyid" int4, "_shiftid" int4, "_templateid" int4, "_areaid" int4, "_enddate" date, "_startdate" date, "_weekday0" bool, "_weekday1" bool, "_weekday2" bool, "_weekday3" bool, "_weekday4" bool, "_weekday5" bool, "_weekday6" bool, "_monthrecurrency" varchar, "_weekday" int4, "_weekdaynumber" int4, "_isoncepermonth" bool, "_isonceperweek" bool, "_lastsignedat" date)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO tasks_taskrecurrency (id, type, date, week, day, month, company_id, shift_id, template_id, area_id, end_date, start_date, weekday0, weekday1, weekday2, weekday3, weekday4, weekday5, weekday6, month_recurrency, weekday, weekday_number, is_once_per_month, is_once_per_week, created_at, modified_at, is_active, last_signed_at) 
VALUES (
DEFAULT, 
_type, 
_date, 
_week, 
_day, 
_month, 
_companyid, 
_shiftid, 
_templateid, 
_areaid, 
_enddate, 
_startdate, 
_weekday0, 
_weekday1, 
_weekday2, 
_weekday3, 
_weekday4, 
_weekday5, 
_weekday6, 
_monthrecurrency, 
_weekday, 
_weekdaynumber, 
_isoncepermonth, 
_isonceperweek, 
now()::timestamp, 
now()::timestamp, 
true, 
_lastsignedat 
)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_taskrecurrencyshift_onetimeonly
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_taskrecurrencyshift_onetimeonly"("_recurrencyid" int4, "_shiftid" int4);
CREATE OR REPLACE FUNCTION "public"."add_taskrecurrencyshift_onetimeonly"("_recurrencyid" int4, "_shiftid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	SELECT TTO."id" INTO _id FROM tasks_taskrecurrency_one_time_shifts TTO WHERE taskrecurrency_id = _recurrencyid AND shift_id = _shiftid;
	IF _id IS NULL OR _id < 1 THEN
		INSERT INTO tasks_taskrecurrency_one_time_shifts(taskrecurrency_id, shift_id) VALUES (_recurrencyid, _shiftid)
		RETURNING id INTO _id;
	END IF;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_taskrecurrencyshift_shifts
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_taskrecurrencyshift_shifts"("_recurrencyid" int4, "_shiftid" int4);
CREATE OR REPLACE FUNCTION "public"."add_taskrecurrencyshift_shifts"("_recurrencyid" int4, "_shiftid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	SELECT TTO."id" INTO _id FROM tasks_taskrecurrency_shifts TTO WHERE taskrecurrency_id = _recurrencyid AND shift_id = _shiftid;
	IF _id IS NULL OR _id < 1 THEN
		INSERT INTO tasks_taskrecurrency_shifts(taskrecurrency_id, shift_id) VALUES (_recurrencyid, _shiftid)
		RETURNING id INTO _id;
	END IF;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_tasktemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_tasktemplate"("_name" varchar, "_areaid" int4, "_companyid" int4, "_picture" varchar, "_description" text, "_descriptionfile" varchar, "_type" varchar, "_role" varchar, "_index" int4, "_weight" numeric, "_video" varchar, "_videothumbnail" varchar, "_deeplinkid" int4, "_deeplinkto" varchar, "_plannedtime" int4, "_machinestatus" varchar);
CREATE OR REPLACE FUNCTION "public"."add_tasktemplate"("_name" varchar, "_areaid" int4, "_companyid" int4, "_picture" varchar, "_description" text, "_descriptionfile" varchar, "_type" varchar, "_role" varchar, "_index" int4, "_weight" numeric, "_video" varchar, "_videothumbnail" varchar, "_deeplinkid" int4, "_deeplinkto" varchar, "_plannedtime" int4, "_machinestatus" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO tasks_tasktemplate (id, name, area_id, company_id, picture, description, description_file, type, role, index, created_at, modified_at, is_active, weight, video, video_thumbnail, deeplink_id, deeplink_to, planned_time, machine_status) 
VALUES (
DEFAULT, 
_name, 
_areaid, 
_companyid, 
_picture, 
_description, 
_descriptionfile, 
_type, 
_role, 
_index, 
now()::timestamp, 
now()::timestamp, 
true, 
_weight, 
_video, 
_videothumbnail,
_deeplinkid,
_deeplinkto,
_plannedtime,
_machinestatus
)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_tasktemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_tasktemplate"("_name" varchar, "_areaid" int4, "_companyid" int4, "_picture" varchar, "_description" text, "_descriptionfile" varchar, "_type" varchar, "_role" varchar, "_index" int4, "_weight" numeric, "_video" varchar, "_videothumbnail" varchar);
CREATE OR REPLACE FUNCTION "public"."add_tasktemplate"("_name" varchar, "_areaid" int4, "_companyid" int4, "_picture" varchar, "_description" text, "_descriptionfile" varchar, "_type" varchar, "_role" varchar, "_index" int4, "_weight" numeric, "_video" varchar, "_videothumbnail" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO tasks_tasktemplate (id, name, area_id, company_id, picture, description, description_file, type, role, index, created_at, modified_at, is_active, weight, video, video_thumbnail) 
VALUES (
DEFAULT, 
_name, 
_areaid, 
_companyid, 
_picture, 
_description, 
_descriptionfile, 
_type, 
_role, 
_index, 
now()::timestamp, 
now()::timestamp, 
true, 
_weight, 
_video, 
_videothumbnail
)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_tasktemplate_property
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_tasktemplate_property"("_companyid" int4, "_taskttemplateid" int4, "_propertyid" int4, "_propertyvalueid" int4, "_primary_int_value" int4, "_secondary_int_value" int4, "_primary_decimal_value" numeric, "_secondary_decimal_value" numeric, "_primary_datetime_value" timestamp, "_secondary_datetime_value" timestamp, "_primary_time_value" time, "_secondary_time_value" time, "_primary_string_value" text, "_secondary_string_value" text, "_bool_value" bool, "_custom_value_type_display" varchar, "_custom_title_display" varchar, "_custom_display_type" varchar, "_display_type" int4, "_is_required" bool, "_index" int4);
CREATE OR REPLACE FUNCTION "public"."add_tasktemplate_property"("_companyid" int4, "_taskttemplateid" int4, "_propertyid" int4, "_propertyvalueid" int4, "_primary_int_value" int4, "_secondary_int_value" int4, "_primary_decimal_value" numeric, "_secondary_decimal_value" numeric, "_primary_datetime_value" timestamp, "_secondary_datetime_value" timestamp, "_primary_time_value" time, "_secondary_time_value" time, "_primary_string_value" text, "_secondary_string_value" text, "_bool_value" bool, "_custom_value_type_display" varchar, "_custom_title_display" varchar, "_custom_display_type" varchar, "_display_type" int4, "_is_required" bool, "_index" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO tasks_tasktemplate_properties (
	"id", 
	"company_id" ,
	"tasktemplate_id",
	"property_id",
	"propertyvalue_id",
	"primary_int_value",
	"secondary_int_value",
	"primary_decimal_value",
	"secondary_decimal_value",
	"primary_datetime_value",
	"secondary_datetime_value",
	"primary_time_value",
	"secondary_time_value",
	"primary_string_value",
	"secondary_string_value",
	"bool_value",
	"custom_value_type_display",
	"custom_title_display",
	"custom_display_type",
	"display_type",
	"is_required",
	"index",
	"created_at",
	"modified_at") 
VALUES (
DEFAULT, 
	_companyid,
	_taskttemplateid,
	_propertyid,
	_propertyvalueid,
	_primary_int_value,
	_secondary_int_value,
	_primary_decimal_value,
	_secondary_decimal_value,
	_primary_datetime_value,
	_secondary_datetime_value,
	_primary_time_value,
	_secondary_time_value,
	_primary_string_value,
	_secondary_string_value,
	_bool_value,
	_custom_value_type_display,
	_custom_title_display,
	_custom_display_type,
	_display_type,
	_is_required,
	_index,
	NOW(),
	NOW()
)
RETURNING id INTO _id;
RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_tasktemplatestep
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_tasktemplatestep"("_index" int4, "_description" varchar, "_picture" varchar, "_templateid" int4, "_video" varchar, "_videothumbnail" varchar);
CREATE OR REPLACE FUNCTION "public"."add_tasktemplatestep"("_index" int4, "_description" varchar, "_picture" varchar, "_templateid" int4, "_video" varchar, "_videothumbnail" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO tasks_tasktemplatestep (id, index, description, picture, template_id, created_at, modified_at, is_active, video, video_thumbnail)
  VALUES (DEFAULT, _index, _description, _picture, _templateid, now()::timestamp,now()::timestamp, true, _video, _videothumbnail)
	RETURNING id INTO _id;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_tasktemplatestep
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_tasktemplatestep"("_index" int4, "_description" varchar, "_picture" varchar, "_templateid" int4, "_video" varchar, "_videothumbnail" varchar, "_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."add_tasktemplatestep"("_index" int4, "_description" varchar, "_picture" varchar, "_templateid" int4, "_video" varchar, "_videothumbnail" varchar, "_companyid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	INSERT INTO tasks_tasktemplatestep (id, index, description, picture, template_id, created_at, modified_at, is_active, video, video_thumbnail)
  VALUES (DEFAULT, _index, _description, _picture, _templateid, now()::timestamp,now()::timestamp, true, _video, _videothumbnail)
	RETURNING id INTO _id;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for add_userprofile
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."add_userprofile"("_companyid" int4, "_email" varchar, "_firstname" varchar, "_lastname" varchar, "_picture" varchar, "_username" varchar, "_password" varchar, "_role" varchar, "_upn" varchar);
CREATE OR REPLACE FUNCTION "public"."add_userprofile"("_companyid" int4, "_email" varchar, "_firstname" varchar, "_lastname" varchar, "_picture" varchar, "_username" varchar, "_password" varchar, "_role" varchar, "_upn" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
		_userfound bool;
	BEGIN
	SELECT (COUNT(*) > 0)::bool INTO _userfound FROM profiles_user WHERE LOWER(username) = LOWER(_username);
	IF NOT _userfound THEN
		INSERT INTO profiles_user (id, company_id, email, first_name, last_name, picture, username, password, role, upn, is_active, is_superuser, is_staff, created_at, modified_at, date_joined, is_deleted, timezone) 
		VALUES (DEFAULT, _companyid, _email, _firstname, _lastname, _picture, _username, _password, _role, _upn, true, false, false, NOW(), NOW(), NOW(), false, 0)
		RETURNING id INTO _id;
	ELSE
		_id = 0;
	END IF;
	RETURN _id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for calculate_audit_score
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."calculate_audit_score"("_audit_id" int4);
CREATE OR REPLACE FUNCTION "public"."calculate_audit_score"("_audit_id" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_calculated_value int4;
	BEGIN
		SELECT calculated_audit_score INTO _calculated_value FROM (
			SELECT calculated_total_task_score, calculated_total_max_task_score, ROUND((calculated_total_task_score / calculated_total_max_task_score * 100), 0) AS calculated_audit_score FROM (
				SELECT SUM(T.calculated_task_score) AS calculated_total_task_score, SUM(T.max_score) AS calculated_total_max_task_score FROM (
					SELECT 
					((CASE WHEN ATT.score_type = 'thumbs' THEN 
									(CASE WHEN TT.status = 'ok' THEN
											ATT.max_task_score
										WHEN TT.status = 'not ok' THEN
											ATT.min_task_score
										ELSE
											0::int4
										END)
							ELSE 
								 TT.score
							END) * weight)::decimal AS calculated_task_score,  TT.max_score
					FROM tasks_task TT
					INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
					INNER JOIN audits_audit_tasks AAT ON AAT.task_id = TT.id
					INNER JOIN audits_audit A ON A.id = AAT.audit_id
					INNER JOIN audits_audittemplate ATT ON ATT.id = A.template_id
					WHERE A.id = _audit_id 
				) AS T
			) AS O) AS R;
	 RETURN _calculated_value;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for calculate_audit_total_score
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."calculate_audit_total_score"("_audit_id" int4);
CREATE OR REPLACE FUNCTION "public"."calculate_audit_total_score"("_audit_id" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_calculated_value int4;
	BEGIN
		SELECT calculated_audit_score INTO _calculated_value FROM (
			SELECT calculated_total_task_score, calculated_total_max_task_score, ROUND((calculated_total_task_score / calculated_total_max_task_score * 100), 0) AS calculated_audit_score FROM (
				SELECT SUM(T.calculated_task_score) AS calculated_total_task_score, SUM(T.max_score) AS calculated_total_max_task_score FROM (
					SELECT 
					((CASE WHEN ATT.score_type = 'thumbs' THEN 
									(CASE WHEN TT.status = 'ok' THEN
											ATT.max_task_score
										WHEN TT.status = 'not ok' THEN
											ATT.min_task_score
										ELSE
											0::int4
										END)
							ELSE 
								 TT.score
							END) * weight)::decimal AS calculated_task_score, (ATT.max_task_score * TTT.weight) AS max_score
					FROM tasks_task TT
					INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
					INNER JOIN audits_audit_tasks AAT ON AAT.task_id = TT.id
					INNER JOIN audits_audit A ON A.id = AAT.audit_id
					INNER JOIN audits_audittemplate ATT ON ATT.id = A.template_id
					WHERE A.id = _audit_id 
				) AS T
			) AS O) AS R;
	 RETURN _calculated_value;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_action
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_action"("_id" int4, "_duedate" timestamp, "_comment" text, "_description" text, "_image0" varchar, "_image1" varchar, "_image2" varchar, "_image3" varchar, "_image4" varchar, "_image5" varchar, "_createdbyid" int4, "_taskid" int4, "_companyid" int4, "_tasktemplateid" int4, "_video0" varchar, "_video1" varchar, "_video2" varchar, "_video3" varchar, "_video4" varchar, "_video5" varchar, "_videothumbnail0" varchar, "_videothumbnail1" varchar, "_videothumbnail2" varchar, "_videothumbnail3" varchar, "_videothumbnail4" varchar, "_videothumbnail5" varchar);
CREATE OR REPLACE FUNCTION "public"."change_action"("_id" int4, "_duedate" timestamp, "_comment" text, "_description" text, "_image0" varchar, "_image1" varchar, "_image2" varchar, "_image3" varchar, "_image4" varchar, "_image5" varchar, "_createdbyid" int4, "_taskid" int4, "_companyid" int4, "_tasktemplateid" int4, "_video0" varchar, "_video1" varchar, "_video2" varchar, "_video3" varchar, "_video4" varchar, "_video5" varchar, "_videothumbnail0" varchar, "_videothumbnail1" varchar, "_videothumbnail2" varchar, "_videothumbnail3" varchar, "_videothumbnail4" varchar, "_videothumbnail5" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
UPDATE actions_action SET 
due_date = _duedate, 
comment = _comment, 
description = _description, 
image_0 = _image0, 
image_1 = _image1, 
image_2 = _image2, 
image_3 = _image3, 
image_4 = _image4, 
image_5 = _image5, 
modified_at = now()::timestamp,  
task_template_id = _tasktemplateid, 
video_0 = _video0, 
video_1 = _video1, 
video_2 = _video2, 
video_3 = _video3, 
video_4 = _video4, 
video_5 = _video5, 
video_thumbnail_0 = _videothumbnail0, 
video_thumbnail_1 = _videothumbnail1, 
video_thumbnail_2 = _videothumbnail2, 
video_thumbnail_3 = _videothumbnail3, 
video_thumbnail_4 = _videothumbnail4, 
video_thumbnail_5 = _videothumbnail5 
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_actioncomment
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_actioncomment"("_id" int4, "_companyid" int4, "_comment" text, "_image0" varchar, "_image1" varchar, "_image2" varchar, "_image3" varchar, "_image4" varchar, "_actionid" int4, "_userid" int4, "_video" varchar, "_videothumbnail" varchar);
CREATE OR REPLACE FUNCTION "public"."change_actioncomment"("_id" int4, "_companyid" int4, "_comment" text, "_image0" varchar, "_image1" varchar, "_image2" varchar, "_image3" varchar, "_image4" varchar, "_actionid" int4, "_userid" int4, "_video" varchar, "_videothumbnail" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
  _rowcount integer;
	BEGIN
	UPDATE actions_actioncomment 
SET 
comment = _comment, 
image_0 = _image0, 
image_1 = _image1, 
image_2 = _image2, 
image_3 = _image3, 
image_4 = _image4, 
user_id = _userid, 
modified_at = now()::timestamp, 
video = _video, 
video_thumbnail = _videothumbnail 
FROM actions_action 
WHERE actions_actioncomment.id = _id AND actions_action.id = actions_actioncomment.action_id AND actions_action.company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_announcement
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_announcement"("_id" int4, "_title" varchar, "_description" text, "_announcementdate" timestamp, "_announcementtype" int4);
CREATE OR REPLACE FUNCTION "public"."change_announcement"("_id" int4, "_title" varchar, "_description" text, "_announcementdate" timestamp, "_announcementtype" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE announcement SET title = _title, description = _description, announcement_date = _announcementdate, announcement_type = _announcementtype
	WHERE id = _id;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_area
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_area"("_id" int4, "_name" varchar, "_description" text, "_companyid" int4, "_picture" varchar, "_parentid" int4, "_systemrole" varchar);
CREATE OR REPLACE FUNCTION "public"."change_area"("_id" int4, "_name" varchar, "_description" text, "_companyid" int4, "_picture" varchar, "_parentid" int4, "_systemrole" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_level int4;
		_lft int4;
		_rght int4;
		_treeid int4;
		_daystogetdata int4;
		_customshifts bool; 
		_issystem bool;
		_rowcount int4;
	BEGIN
	UPDATE companies_area SET 
name = _name, 
description = _description, 
picture = _picture, 
parent_id = _parentid, 
system_role = _systemrole, 
modified_at = now()::timestamp 
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_area
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_area"("_id" int4, "_name" varchar, "_description" text, "_companyid" int4, "_picture" varchar, "_level" int4, "_lft" int4, "_parentid" int4, "_rght" int4, "_treeid" int4, "_systemrole" varchar, "_daystogetdata" int4, "_customshifts" bool, "_issystem" bool);
CREATE OR REPLACE FUNCTION "public"."change_area"("_id" int4, "_name" varchar, "_description" text, "_companyid" int4, "_picture" varchar, "_level" int4, "_lft" int4, "_parentid" int4, "_rght" int4, "_treeid" int4, "_systemrole" varchar, "_daystogetdata" int4, "_customshifts" bool, "_issystem" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE companies_area SET 
name = _name, 
description = _description, 
picture = _picture, 
level = _level, 
lft = _lft, 
parent_id = _parentid, 
rght = _rght, 
tree_id = _treeid, 
system_role = _systemrole, 
days_to_get_data =  _daystogetdata, 
modified_at = now()::timestamp, 
custom_shifts = _customshifts, 
is_system =  _issystem 
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_audit
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_audit"("_id" int4, "_companyid" int4, "_templateid" int4, "_totalscore" int2, "_iscompleted" bool, "_signature1" varchar, "_signature2" varchar, "_signedat1" timestamptz, "_signedat2" timestamptz, "_signedbyid1" int4, "_signedby2" varchar);
CREATE OR REPLACE FUNCTION "public"."change_audit"("_id" int4, "_companyid" int4, "_templateid" int4, "_totalscore" int2, "_iscompleted" bool, "_signature1" varchar, "_signature2" varchar, "_signedat1" timestamptz, "_signedat2" timestamptz, "_signedbyid1" int4, "_signedby2" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE audits_audit SET 
template_id = _templateid, 
total_score = _totalscore, 
signature_1 = _signature1, 
signature_2 = _signature2, 
signed_at_1 = _signedAt1, 
signed_at_2 = _signedAt2, 
signed_by_1_id = _signedbyid1 , 
signed_by_2 = _signedby2, 
is_complete = _iscompleted,
modified_at = now()::timestamp  
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_audit
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_audit"("_id" int4, "_companyid" int4, "_templateid" int4, "_totalscore" int2, "_signature1" varchar, "_signature2" varchar, "_signedat1" timestamptz, "_signedat2" timestamptz, "_signedbyid1" int4, "_signedby2" varchar);
CREATE OR REPLACE FUNCTION "public"."change_audit"("_id" int4, "_companyid" int4, "_templateid" int4, "_totalscore" int2, "_signature1" varchar, "_signature2" varchar, "_signedat1" timestamptz, "_signedat2" timestamptz, "_signedbyid1" int4, "_signedby2" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE audits_audit SET 
template_id = _templateid, 
total_score = _totalscore, 
signature_1 = _signature1, 
signature_2 = _signature2, 
signed_at_1 = _signedAt1, 
signed_at_2 = _signedAt2, 
signed_by_1_id = _signedbyid1 , 
signed_by_2 = _signedby2, 
modified_at = now()::timestamp  
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_audittemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_audittemplate"("_id" int4, "_name" varchar, "_doublesignaturerequired" bool, "_scoretype" varchar, "_areaid" int4, "_companyid" int4, "_signaturerequired" bool, "_description" text, "_picture" varchar, "_role" varchar, "_mintaskscore" int4, "_maxtaskscore" int4);
CREATE OR REPLACE FUNCTION "public"."change_audittemplate"("_id" int4, "_name" varchar, "_doublesignaturerequired" bool, "_scoretype" varchar, "_areaid" int4, "_companyid" int4, "_signaturerequired" bool, "_description" text=NULL::text, "_picture" varchar=NULL::character varying, "_role" varchar=NULL::character varying, "_mintaskscore" int4=NULL::integer, "_maxtaskscore" int4=NULL::integer)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE audits_audittemplate SET 
name = _name, 
description = _description, 
picture = _picture, 
double_signature_required = _doublesignaturerequired, 
score_type = _scoretype, 
min_task_score = _mintaskscore, 
max_task_score = _maxtaskscore, 
area_id = _areaid, 
role = _role, 
signature_required = _signaturerequired, 
modified_at = now()::timestamp  
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_audittemplate_property
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_audittemplate_property"("_id" int4, "_companyid" int4, "_audittemplateid" int4, "_propertyid" int4, "_propertyvalueid" int4, "_primary_int_value" int4, "_secondary_int_value" int4, "_primary_decimal_value" numeric, "_secondary_decimal_value" numeric, "_primary_datetime_value" timestamp, "_secondary_datetime_value" timestamp, "_primary_time_value" time, "_secondary_time_value" time, "_primary_string_value" text, "_secondary_string_value" text, "_bool_value" bool, "_custom_value_type_display" varchar, "_custom_title_display" varchar, "_custom_display_type" varchar, "_display_type" int4, "_is_required" bool, "_index" int4);
CREATE OR REPLACE FUNCTION "public"."change_audittemplate_property"("_id" int4, "_companyid" int4, "_audittemplateid" int4, "_propertyid" int4, "_propertyvalueid" int4, "_primary_int_value" int4, "_secondary_int_value" int4, "_primary_decimal_value" numeric, "_secondary_decimal_value" numeric, "_primary_datetime_value" timestamp, "_secondary_datetime_value" timestamp, "_primary_time_value" time, "_secondary_time_value" time, "_primary_string_value" text, "_secondary_string_value" text, "_bool_value" bool, "_custom_value_type_display" varchar, "_custom_title_display" varchar, "_custom_display_type" varchar, "_display_type" int4, "_is_required" bool, "_index" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE audits_audittemplate_properties SET
	"audittemplate_id" = _audittemplateid,
	"property_id" = _propertyid,
	"propertyvalue_id" = _propertyvalueid,
	"primary_int_value" = _primary_int_value,
	"secondary_int_value" = _secondary_int_value,
	"primary_decimal_value" = _primary_decimal_value,
	"secondary_decimal_value" = _secondary_decimal_value,
	"primary_datetime_value" = _primary_datetime_value,
	"secondary_datetime_value" = _secondary_datetime_value,
	"primary_time_value" = _primary_time_value,
	"secondary_time_value" = _secondary_time_value,
	"primary_string_value" = _primary_string_value,
	"secondary_string_value" = _secondary_string_value,
	"bool_value" = _bool_value,
	"custom_value_type_display" = _custom_value_type_display,
	"custom_title_display" = _custom_title_display,
	"custom_display_type" = _custom_display_type,
	"display_type" = _display_type,
	"is_required" = _is_required, 
	"index" = _index,
	"modified_at" = NOW()
	WHERE "company_id" = _companyid AND "id" = _id;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_checklist
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_checklist"("_id" int4, "_companyid" int4, "_templateid" int4, "_signedbyid1" int4, "_signature1" varchar, "_signedat1" timestamptz, "_signature2" varchar, "_signedby2" varchar, "_signedat2" timestamptz, "_iscompleted" bool);
CREATE OR REPLACE FUNCTION "public"."change_checklist"("_id" int4, "_companyid" int4, "_templateid" int4, "_signedbyid1" int4, "_signature1" varchar, "_signedat1" timestamptz, "_signature2" varchar, "_signedby2" varchar, "_signedat2" timestamptz, "_iscompleted" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE checklists_checklist SET 
is_complete = _iscompleted,
template_id = _templateid, 
signature_1 = _signature1, 
signature_2 = _signature2, 
signed_at_1 = _signedat1, 
signed_at_2 = _signedat2, 
signed_by_1_id = _signedbyid1, 
signed_by_2 = _signedby2, 
modified_at = now()::timestamp  
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_checklisttemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_checklisttemplate"("_id" int4, "_name" varchar, "_areaid" int4, "_companyid" int4, "_doublesignaturerequired" bool, "_signaturerequired" bool, "_role" varchar, "_description" text, "_picture" varchar);
CREATE OR REPLACE FUNCTION "public"."change_checklisttemplate"("_id" int4, "_name" varchar, "_areaid" int4, "_companyid" int4, "_doublesignaturerequired" bool, "_signaturerequired" bool, "_role" varchar=NULL::character varying, "_description" text=NULL::text, "_picture" varchar=NULL::character varying)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE checklists_checklisttemplate SET 
name = _name, 
description = _description, 
picture = _picture, 
area_id = _areaid, 
double_signature_required = _doublesignaturerequired, 
signature_required = _signaturerequired,
role = _role, 
modified_at = now()::timestamp 
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_checklisttemplate_property
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_checklisttemplate_property"("_id" int4, "_companyid" int4, "_checklisttemplateid" int4, "_propertyid" int4, "_propertyvalueid" int4, "_primary_int_value" int4, "_secondary_int_value" int4, "_primary_decimal_value" numeric, "_secondary_decimal_value" numeric, "_primary_datetime_value" timestamp, "_secondary_datetime_value" timestamp, "_primary_time_value" time, "_secondary_time_value" time, "_primary_string_value" text, "_secondary_string_value" text, "_bool_value" bool, "_custom_value_type_display" varchar, "_custom_title_display" varchar, "_custom_display_type" varchar, "_display_type" int4, "_is_required" bool, "_index" int4);
CREATE OR REPLACE FUNCTION "public"."change_checklisttemplate_property"("_id" int4, "_companyid" int4, "_checklisttemplateid" int4, "_propertyid" int4, "_propertyvalueid" int4, "_primary_int_value" int4, "_secondary_int_value" int4, "_primary_decimal_value" numeric, "_secondary_decimal_value" numeric, "_primary_datetime_value" timestamp, "_secondary_datetime_value" timestamp, "_primary_time_value" time, "_secondary_time_value" time, "_primary_string_value" text, "_secondary_string_value" text, "_bool_value" bool, "_custom_value_type_display" varchar, "_custom_title_display" varchar, "_custom_display_type" varchar, "_display_type" int4, "_is_required" bool, "_index" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE checklists_checklisttemplate_properties SET
	"checklisttemplate_id" = _checklisttemplateid,
	"property_id" = _propertyid,
	"propertyvalue_id" = _propertyvalueid,
	"primary_int_value" = _primary_int_value,
	"secondary_int_value" = _secondary_int_value,
	"primary_decimal_value" = _primary_decimal_value,
	"secondary_decimal_value" = _secondary_decimal_value,
	"primary_datetime_value" = _primary_datetime_value,
	"secondary_datetime_value" = _secondary_datetime_value,
	"primary_time_value" = _primary_time_value,
	"secondary_time_value" = _secondary_time_value,
	"primary_string_value" = _primary_string_value,
	"secondary_string_value" = _secondary_string_value,
	"bool_value" = _bool_value,
	"custom_value_type_display" = _custom_value_type_display,
	"custom_title_display" = _custom_title_display,
	"custom_display_type" = _custom_display_type,
	"display_type" = _display_type,
	"is_required" = _is_required, 
	"index" = _index,
	"modified_at" = NOW()
	WHERE "company_id" = _companyid AND "id" = _id;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_comment
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_comment"("_id" int4, "_companyid" int4, "_userid" int4, "_taskid" int4, "_tasktemplateid" int4, "_comment" text, "_commentdate" timestamp, "_description" text, "_attachments" text);
CREATE OR REPLACE FUNCTION "public"."change_comment"("_id" int4, "_companyid" int4, "_userid" int4, "_taskid" int4, "_tasktemplateid" int4, "_comment" text, "_commentdate" timestamp, "_description" text, "_attachments" text)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE comments SET 
	user_id = _userid, 
	--task_id = _taskid, 
	--tasktemplate_id = _tasktemplateid,
	comment = _comment, 
	comment_date = _commentdate, 
	description = _description, 
	attachments = _attachments,
	modified_at = NOW()
	WHERE id = _id AND company_id = _companyid;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_company"("_id" int4, "_name" varchar, "_description" text, "_picture" varchar, "_managerid" int4);
CREATE OR REPLACE FUNCTION "public"."change_company"("_id" int4, "_name" varchar, "_description" text, "_picture" varchar, "_managerid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE companies_company 
SET 
name = _name, 
description = _description, 
picture = _picture,  
manager_id = _managerid, 
modified_at = now()::timestamp 
WHERE id = _id;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_factoryfeed
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_factoryfeed"("_id" int4, "_companyid" int4, "_name" varchar, "_description" text, "_attachments" text, "_data" text);
CREATE OR REPLACE FUNCTION "public"."change_factoryfeed"("_id" int4, "_companyid" int4, "_name" varchar, "_description" text, "_attachments" text, "_data" text)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE factoryfeeds SET name = _name, description = _description, attachments = _attachments, data = _data WHERE id = _id AND company_id = _companyid;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_factoryfeed_message
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_factoryfeed_message"("_id" int4, "_companyid" int4, "_factoryfeedid" int4, "_userid" int4, "_title" varchar, "_description" text, "_attachments" text, "_issticky" bool, "_ishighlighted" bool, "_messagetype" int4, "_data" text, "_messagedate" timestamp, "_parentid" int4);
CREATE OR REPLACE FUNCTION "public"."change_factoryfeed_message"("_id" int4, "_companyid" int4, "_factoryfeedid" int4, "_userid" int4, "_title" varchar, "_description" text, "_attachments" text, "_issticky" bool, "_ishighlighted" bool, "_messagetype" int4, "_data" text, "_messagedate" timestamp, "_parentid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE factoryfeed_messages SET user_id = _userid, title = _title, description = _description, attachments = _attachments, is_sticky = _issticky, is_highlighted = _ishighlighted, data = _data, message_date = _messagedate, modified_at = NOW(), parent_id = _parentid WHERE id = _id AND company_id = _companyid;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_factoryfeed_message
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_factoryfeed_message"("_id" int4, "_companyid" int4, "_factoryfeedid" int4, "_userid" int4, "_title" varchar, "_description" text, "_attachments" text, "_issticky" bool, "_ishighlighted" bool, "_messagetype" int4, "_data" text, "_messagedate" timestamp);
CREATE OR REPLACE FUNCTION "public"."change_factoryfeed_message"("_id" int4, "_companyid" int4, "_factoryfeedid" int4, "_userid" int4, "_title" varchar, "_description" text, "_attachments" text, "_issticky" bool, "_ishighlighted" bool, "_messagetype" int4, "_data" text, "_messagedate" timestamp)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE factoryfeed_messages SET user_id = _userid, title = _title, description = _description, attachments = _attachments, is_sticky = _issticky, is_highlighted = _ishighlighted, data = _data, message_date = _messagedate, modified_at = NOW() WHERE id = _id AND company_id = _companyid;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_resource_language_description
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_resource_language_description"("_key" varchar, "_description" varchar);
CREATE OR REPLACE FUNCTION "public"."change_resource_language_description"("_key" varchar, "_description" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE resource_languages SET 
	description = _description 
	WHERE resource_key = _key;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_resource_language_key_value
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_resource_language_key_value"("_key" varchar, "_culture" varchar, "_value" varchar);
CREATE OR REPLACE FUNCTION "public"."change_resource_language_key_value"("_key" varchar, "_culture" varchar, "_value" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	-- NOTE BECAUSE THIS METHOD USES 
	 EXECUTE format('UPDATE resource_languages SET %I = %L WHERE resource_key = %L;', _culture, _value, _key);
   GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_resource_setting
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_resource_setting"("_id" int4, "_value" text);
CREATE OR REPLACE FUNCTION "public"."change_resource_setting"("_id" int4, "_value" text)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE resource_settings SET settingvalue = _value WHERE id = _id;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_resource_setting_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_resource_setting_company"("_id" int4, "_companyid" int4, "_description" text, "_resourceid" int4, "_value" text);
CREATE OR REPLACE FUNCTION "public"."change_resource_setting_company"("_id" int4, "_companyid" int4, "_description" text, "_resourceid" int4, "_value" text)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE companies_setting SET description = _description, value = _value WHERE id = _id AND resource_setting_id = _resourceid AND company_id = _companyid;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_resource_setting_company_by_resource
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_resource_setting_company_by_resource"("_companyid" int4, "_resourceid" int4, "_value" text);
CREATE OR REPLACE FUNCTION "public"."change_resource_setting_company_by_resource"("_companyid" int4, "_resourceid" int4, "_value" text)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	IF (SELECT COUNT(CS.*) FROM companies_setting CS WHERE resource_setting_id =  _resourceid AND company_id = _companyid) > 0 THEN 
		UPDATE companies_setting SET value = _value WHERE resource_setting_id = _resourceid AND company_id = _companyid;
	ELSE 
		INSERT INTO companies_setting (company_id, value, resource_setting_id) VALUES (_companyid, _value, _resourceid);
	END IF;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_shift
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_shift"("_id" int4, "_companyid" int4, "_day" int2, "_start" time, "_end" time, "_areaid" int4, "_weekday" int2);
CREATE OR REPLACE FUNCTION "public"."change_shift"("_id" int4, "_companyid" int4, "_day" int2, "_start" time, "_end" time, "_areaid" int4, "_weekday" int2)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE companies_shift SET 
"day" = _day, 
"start" = _start, 
"end" = _end, 
area_id = _areaId, 
weekday = _weekday, 
modified_at = now()::timestamp 
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_task
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_task"("_id" int4, "_status" varchar, "_signedat" timestamptz, "_comment" text, "_signedbyid" int4, "_templateid" int4, "_companyid" int4, "_recurrencyid" int4, "_score" int4, "_enddate" date, "_startdate" date, "_deviance" int4, "_maxscore" int4, "_totalscore" int4, "_dueat" timestamptz, "_startat" timestamptz, "_shiftid" int4, "_time_realized_by_id" int4, "_time_taken" int4);
CREATE OR REPLACE FUNCTION "public"."change_task"("_id" int4, "_status" varchar, "_signedat" timestamptz, "_comment" text, "_signedbyid" int4, "_templateid" int4, "_companyid" int4, "_recurrencyid" int4, "_score" int4, "_enddate" date, "_startdate" date, "_deviance" int4, "_maxscore" int4, "_totalscore" int4, "_dueat" timestamptz, "_startat" timestamptz, "_shiftid" int4, "_time_realized_by_id" int4, "_time_taken" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE tasks_task SET 
status = _status, 
signed_at = _signedat, 
comment = _comment, 
signed_by_id = _signedbyid, 
template_id = _templateid, 
recurrency_id = _recurrencyid, 
score = _score, 
modified_at = now()::timestamp , 
end_date = _enddate, 
start_date = _startdate, 
shift_id = _shiftid, 
deviance = _deviance, 
max_score = _maxscore, 
total_score = _totalscore, 
due_at = _dueat, 
start_at = _startat,
time_realized_by_id = _time_realized_by_id,
time_taken = _time_taken
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_task
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_task"("_id" int4, "_status" varchar, "_signedat" timestamptz, "_comment" text, "_signedbyid" int4, "_templateid" int4, "_companyid" int4, "_recurrencyid" int4, "_score" int4, "_enddate" date, "_startdate" date, "_deviance" int4, "_maxscore" int4, "_totalscore" int4, "_dueat" timestamptz, "_startat" timestamptz, "_shiftid" int4);
CREATE OR REPLACE FUNCTION "public"."change_task"("_id" int4, "_status" varchar, "_signedat" timestamptz, "_comment" text, "_signedbyid" int4, "_templateid" int4, "_companyid" int4, "_recurrencyid" int4, "_score" int4, "_enddate" date, "_startdate" date, "_deviance" int4, "_maxscore" int4, "_totalscore" int4, "_dueat" timestamptz, "_startat" timestamptz, "_shiftid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE tasks_task SET 
status = _status, 
signed_at = _signedat, 
comment = _comment, 
signed_by_id = _signedbyid, 
template_id = _templateid, 
recurrency_id = _recurrencyid, 
score = _score, 
modified_at = now()::timestamp , 
end_date = _enddate, 
start_date = _startdate, 
shift_id = _shiftid, 
deviance = _deviance, 
max_score = _maxscore, 
total_score = _totalscore, 
due_at = _dueat, 
start_at = _startat 
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_task_property
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_task_property"("_id" int4, "_companyid" int4, "_taskid" int4, "_propertyid" int4, "_tasktemplatepropertyid" int4, "_userid" int4, "_value_int" int4, "_value_string" text, "_value_decimal" numeric, "_value_time" time, "_value_date" timestamp, "_value_bool" bool);
CREATE OR REPLACE FUNCTION "public"."change_task_property"("_id" int4, "_companyid" int4, "_taskid" int4, "_propertyid" int4, "_tasktemplatepropertyid" int4, "_userid" int4, "_value_int" int4, "_value_string" text, "_value_decimal" numeric, "_value_time" time, "_value_date" timestamp, "_value_bool" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE tasks_properties
	SET
		"user_id" = _userid, 
		"value_int" = _value_int, 
		"value_string" = _value_string, 
		"value_decimal" = _value_decimal, 
		"value_time" = _value_time, 
		"value_date" = _value_date, 
		"value_bool" = _value_bool,
		"modified_at" = NOW()
	WHERE "id" = _id AND "company_id" = _companyid AND "property_id" = _propertyid AND "task_id" = _taskid AND "template_property_id" = _tasktemplatepropertyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_task_status
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_task_status"("_id" int4, "_status" varchar, "_signedat" timestamptz, "_signedbyid" int4, "_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."change_task_status"("_id" int4, "_status" varchar, "_signedat" timestamptz, "_signedbyid" int4, "_companyid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE tasks_task SET 
status = _status, 
signed_at = _signedat, 
signed_by_id = _signedbyid, 
modified_at = now()::timestamp 
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_taskrecurrency
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_taskrecurrency"("_id" int4, "_type" varchar, "_date" date, "_week" int4, "_day" int4, "_month" int4, "_companyid" int4, "_shiftid" int4, "_templateid" int4, "_areaid" int4, "_enddate" date, "_startdate" date, "_weekday0" bool, "_weekday1" bool, "_weekday2" bool, "_weekday3" bool, "_weekday4" bool, "_weekday5" bool, "_weekday6" bool, "_monthrecurrency" varchar, "_weekday" int4, "_weekdaynumber" int4, "_isoncepermonth" bool, "_isonceperweek" bool, "_lastsignedat" date);
CREATE OR REPLACE FUNCTION "public"."change_taskrecurrency"("_id" int4, "_type" varchar, "_date" date, "_week" int4, "_day" int4, "_month" int4, "_companyid" int4, "_shiftid" int4, "_templateid" int4, "_areaid" int4, "_enddate" date, "_startdate" date, "_weekday0" bool, "_weekday1" bool, "_weekday2" bool, "_weekday3" bool, "_weekday4" bool, "_weekday5" bool, "_weekday6" bool, "_monthrecurrency" varchar, "_weekday" int4, "_weekdaynumber" int4, "_isoncepermonth" bool, "_isonceperweek" bool, "_lastsignedat" date)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
UPDATE tasks_taskrecurrency  SET 
type = _type, 
date = _date, 
week = _week, 
day = _day, 
month = _month, 
shift_id = _shiftid, 
template_id = _templateid, 
area_id = _areaid, 
end_date = _enddate, 
start_date =  _startdate, 
weekday0 = _weekday0, 
weekday1 = _weekday1, 
weekday2 = _weekday2, 
weekday3 = _weekday3, 
weekday4 = _weekday4, 
weekday5 = _weekday5, 
weekday6 = _weekday6, 
month_recurrency = _monthrecurrency, 
weekday = _weekday, 
weekday_number = _weekdayNumber, 
is_once_per_month = _isoncepermonth, 
is_once_per_week = _isonceperweek, 
modified_at = now()::timestamp, 
last_signed_at = _lastsignedat 
WHERE id = _id AND company_id = _companyid
;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_tasktemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_tasktemplate"("_id" int4, "_name" varchar, "_areaid" int4, "_companyid" int4, "_picture" varchar, "_description" text, "_descriptionfile" varchar, "_type" varchar, "_role" varchar, "_index" int4, "_weight" numeric, "_video" varchar, "_videothumbnail" varchar, "_deeplinkid" int4, "_deeplinkto" varchar, "_plannedtime" int4, "_machinestatus" varchar);
CREATE OR REPLACE FUNCTION "public"."change_tasktemplate"("_id" int4, "_name" varchar, "_areaid" int4, "_companyid" int4, "_picture" varchar, "_description" text, "_descriptionfile" varchar, "_type" varchar, "_role" varchar, "_index" int4, "_weight" numeric, "_video" varchar, "_videothumbnail" varchar, "_deeplinkid" int4, "_deeplinkto" varchar, "_plannedtime" int4, "_machinestatus" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE tasks_tasktemplate 
SET 
name = _name, 
area_id = _areaid, 
picture = _picture, 
description = _description, 
description_file = _descriptionfile, 
type = _type, 
role = _role, 
index = _index, 
weight = _weight, 
video = _video, 
video_thumbnail = _videothumbnail, 
modified_at = now()::timestamp,
deeplink_id = _deeplinkid, 
deeplink_to = _deeplinkto, 
planned_time = _plannedtime, 
machine_status = _machinestatus 
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_tasktemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_tasktemplate"("_id" int4, "_name" varchar, "_areaid" int4, "_companyid" int4, "_picture" varchar, "_description" text, "_descriptionfile" varchar, "_type" varchar, "_role" varchar, "_index" int4, "_weight" numeric, "_video" varchar, "_videothumbnail" varchar);
CREATE OR REPLACE FUNCTION "public"."change_tasktemplate"("_id" int4, "_name" varchar, "_areaid" int4, "_companyid" int4, "_picture" varchar, "_description" text, "_descriptionfile" varchar, "_type" varchar, "_role" varchar, "_index" int4, "_weight" numeric, "_video" varchar, "_videothumbnail" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE tasks_tasktemplate 
SET 
name = _name, 
area_id = _areaid, 
picture = _picture, 
description = _description, 
description_file = _descriptionfile, 
type = _type, 
role = _role, 
index = _index, 
weight = _weight, 
video = _video, 
video_thumbnail = _videothumbnail, 
modified_at = now()::timestamp 
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_tasktemplate_property
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_tasktemplate_property"("_id" int4, "_companyid" int4, "_taskttemplateid" int4, "_propertyid" int4, "_propertyvalueid" int4, "_primary_int_value" int4, "_secondary_int_value" int4, "_primary_decimal_value" numeric, "_secondary_decimal_value" numeric, "_primary_datetime_value" timestamp, "_secondary_datetime_value" timestamp, "_primary_time_value" time, "_secondary_time_value" time, "_primary_string_value" text, "_secondary_string_value" text, "_bool_value" bool, "_custom_value_type_display" varchar, "_custom_title_display" varchar, "_custom_display_type" varchar, "_display_type" int4, "_is_required" bool, "_index" int4);
CREATE OR REPLACE FUNCTION "public"."change_tasktemplate_property"("_id" int4, "_companyid" int4, "_taskttemplateid" int4, "_propertyid" int4, "_propertyvalueid" int4, "_primary_int_value" int4, "_secondary_int_value" int4, "_primary_decimal_value" numeric, "_secondary_decimal_value" numeric, "_primary_datetime_value" timestamp, "_secondary_datetime_value" timestamp, "_primary_time_value" time, "_secondary_time_value" time, "_primary_string_value" text, "_secondary_string_value" text, "_bool_value" bool, "_custom_value_type_display" varchar, "_custom_title_display" varchar, "_custom_display_type" varchar, "_display_type" int4, "_is_required" bool, "_index" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE tasks_tasktemplate_properties SET
	"tasktemplate_id" = _taskttemplateid,
	"property_id" = _propertyid,
	"propertyvalue_id" = _propertyvalueid,
	"primary_int_value" = _primary_int_value,
	"secondary_int_value" = _secondary_int_value,
	"primary_decimal_value" = _primary_decimal_value,
	"secondary_decimal_value" = _secondary_decimal_value,
	"primary_datetime_value" = _primary_datetime_value,
	"secondary_datetime_value" = _secondary_datetime_value,
	"primary_time_value" = _primary_time_value,
	"secondary_time_value" = _secondary_time_value,
	"primary_string_value" = _primary_string_value,
	"secondary_string_value" = _secondary_string_value,
	"bool_value" = _bool_value,
	"custom_value_type_display" = _custom_value_type_display,
	"custom_title_display" = _custom_title_display,
	"custom_display_type" = _custom_display_type,
	"display_type" = _display_type,
	"is_required" = _is_required, 
	"index" = _index,
	"modified_at" = NOW()
	WHERE "company_id" = _companyid AND "id" = _id;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_tasktemplatestep
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_tasktemplatestep"("_id" int4, "_index" int4, "_description" varchar, "_picture" varchar, "_templateid" int4, "_video" varchar, "_videothumbnail" varchar);
CREATE OR REPLACE FUNCTION "public"."change_tasktemplatestep"("_id" int4, "_index" int4, "_description" varchar, "_picture" varchar, "_templateid" int4, "_video" varchar, "_videothumbnail" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
  _rowcount integer;
	BEGIN
	UPDATE tasks_tasktemplatestep 
	SET 
	index = _index, 
	description = _description,
	picture = _picture, 
	template_id = _templateid, 
	video = _video, 
	video_thumbnail = _videothumbnail
	WHERE id = _id;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_tasktemplatestep
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_tasktemplatestep"("_id" int4, "_index" int4, "_description" varchar, "_picture" varchar, "_templateid" int4, "_video" varchar, "_videothumbnail" varchar, "_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."change_tasktemplatestep"("_id" int4, "_index" int4, "_description" varchar, "_picture" varchar, "_templateid" int4, "_video" varchar, "_videothumbnail" varchar, "_companyid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
  _rowcount integer;
	BEGIN
	UPDATE tasks_tasktemplatestep 
	SET 
	index = _index, 
	description = _description,
	picture = _picture, 
	video = _video, 
	video_thumbnail = _videothumbnail
	FROM tasks_tasktemplate
	WHERE tasks_tasktemplatestep.id = _id AND tasks_tasktemplate.id =tasks_tasktemplatestep.template_id AND tasks_tasktemplate.company_id = _companyid ;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for change_userprofile
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."change_userprofile"("_companyid" int4, "_id" int4, "_email" varchar, "_firstname" varchar, "_lastname" varchar, "_picture" varchar, "_username" varchar, "_role" varchar, "_upn" varchar);
CREATE OR REPLACE FUNCTION "public"."change_userprofile"("_companyid" int4, "_id" int4, "_email" varchar, "_firstname" varchar, "_lastname" varchar, "_picture" varchar, "_username" varchar, "_role" varchar, "_upn" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  _rowcount integer;
	_userfound bool;
BEGIN
	SELECT (COUNT(*) > 0)::bool INTO _userfound FROM profiles_user WHERE LOWER(username) = LOWER(_username) AND id <> _id;
	IF NOT _userfound THEN
		UPDATE profiles_user SET email = _email, first_name = _firstname, last_name = _lastname, picture = _picture, username = _username, role = _role, upn = _upn, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
		GET DIAGNOSTICS _rowcount = ROW_COUNT;
     RETURN _rowcount;
	 ELSE
		_rowcount = 0;
		RETURN _rowcount;
	END IF;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_and_get_username_external_login
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_and_get_username_external_login"("_useridentifier" varchar, "_externalkey" varchar);
CREATE OR REPLACE FUNCTION "public"."check_and_get_username_external_login"("_useridentifier" varchar, "_externalkey" varchar)
  RETURNS "pg_catalog"."varchar" AS $BODY$
DECLARE
  _externalsystem varchar(100);
BEGIN
   SELECT CS."value"::varchar into _externalsystem 
	 FROM companies_setting CS  
	 INNER JOIN profiles_user PU ON PU.company_id = CS.company_id AND CS.resource_setting_id = 2 AND lower(PU.upn) = lower(_useridentifier);
   RETURN _externalsystem;
	 -- TODO add _externalkey for now disabled until clear how to implement
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_changes
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_changes"("_companyid" int4, "_timestamp" timestamp, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."check_changes"("_companyid" int4, "_timestamp" timestamp=NULL::timestamp without time zone, "_userid" int4=0, "_areaid" int4=0)
  RETURNS TABLE("nr" int4, "check_type" varchar) AS $BODY$
	DECLARE 
		_current_check_date timestamp;
		_current_check_future_date timestamp;
	BEGIN
	IF _timestamp IS NULL THEN
			_current_check_date = NOW()::timestamp;
	ELSE
			_current_check_date = _timestamp;
	END IF;
	_current_check_future_date = NOW()::timestamp; --Buildin-margin
	RETURN QUERY 
	SELECT * FROM (
	SELECT SUM(T.Nr)::int4 AS Nr, T.check_type FROM (
		
		SELECT 'ACTIONS'::varchar AS check_type, 1 AS Nr WHERE EXISTS (
			SELECT I.id FROM actions_action I 
			WHERE ((I.created_at > _current_check_date AND I.created_at < _current_check_future_date) OR (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date)) 
			AND I.company_id = _companyid
		)
		
	UNION
		SELECT 'ACTIONS'::varchar AS check_type, 1 AS Nr WHERE EXISTS (
			SELECT I.id FROM actions_actioncomment I 
			INNER JOIN actions_action A ON A.id = I.action_id 
			WHERE ((I.created_at > _current_check_date AND I.created_at < _current_check_future_date) OR (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date)) 
			AND A.company_id = _companyid 
		)
		
	UNION
		SELECT 'AUDITS'::varchar AS check_type, 1 AS Nr WHERE EXISTS (
			SELECT I.id FROM audits_audit I 
			INNER JOIN audits_audittemplate AAT ON AAT.id = I.template_id AND AAT.company_id = _companyid AND AAT.is_active = true
			WHERE ((I.created_at > _current_check_date AND I.created_at < _current_check_future_date) OR (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date)) AND I.company_id = _companyid
			AND (I.signed_by_1_id <> _userid OR _userid = 0)
			AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = AAT.area_id) OR _areaid= 0)
		)	
		
	UNION
		SELECT 'AUDITS'::varchar AS check_type, 1 AS Nr WHERE EXISTS (
			SELECT I.id FROM tasks_task I 
			INNER JOIN tasks_tasktemplate TT ON TT.id = I.template_id AND TT.company_id = _companyid AND TT.is_active = true --AND TT.type = 'audit'
			INNER JOIN audits_audittemplate_tasks AATT ON AATT.tasktemplate_id = TT.id
			INNER JOIN audits_audittemplate AAT ON AAT.id = AATT.audittemplate_id AND AAT.company_id = _companyid AND AAT.is_active = true
			INNER JOIN audits_audit_tasks AAATTT ON AAATTT.task_id = I.id
			INNER JOIN audits_audit A ON A.id = AAATTT.audit_id AND A.is_active = true AND A.company_id = _companyid
			WHERE (I.created_at > _current_check_date AND I.created_at < _current_check_future_date) AND I.company_id = _companyid AND I.is_active = true
			AND (A.signed_by_1_id <> _userid OR _userid = 0)
			AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = AAT.area_id) OR _areaid= 0)
		)
		
	UNION
		SELECT 'AUDITS'::varchar AS check_type, 1 AS Nr WHERE EXISTS (
			SELECT I.id FROM tasks_task I 
			INNER JOIN tasks_tasktemplate TT ON TT.id = I.template_id AND TT.company_id = _companyid AND TT.is_active = true --AND TT.type = 'audit'
			INNER JOIN audits_audittemplate_tasks AATT ON AATT.tasktemplate_id = TT.id
			INNER JOIN audits_audittemplate AAT ON AAT.id = AATT.audittemplate_id AND AAT.company_id = _companyid AND AAT.is_active = true
			INNER JOIN audits_audit_tasks AAATTT ON AAATTT.task_id = I.id
			INNER JOIN audits_audit A ON A.id = AAATTT.audit_id AND A.is_active = true AND A.company_id = _companyid
			WHERE (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date) AND I.company_id = _companyid AND I.is_active = true
			AND (A.signed_by_1_id <> _userid OR _userid = 0)
			AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = AAT.area_id) OR _areaid= 0) 
		)
		
  UNION
		SELECT 'AUDITTEMPLATES'::varchar AS check_type, 1 AS Nr WHERE EXISTS (
			SELECT I.id FROM audits_audittemplate I 
			WHERE ((I.created_at > _current_check_date AND I.created_at < _current_check_future_date) OR (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date)) AND I.company_id = _companyid 
			AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = I.area_id) OR _areaid= 0)
		)	
			
	UNION
		SELECT 'CHECKLISTS'::varchar AS check_type, 1 AS Nr WHERE EXISTS (
			SELECT I.id FROM checklists_checklist I 
			INNER JOIN checklists_checklisttemplate CCT ON CCT.id = I.template_id AND CCT.company_id = _companyid AND CCT.is_active = true
			WHERE ((I.created_at > _current_check_date AND I.created_at < _current_check_future_date) OR (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date)) AND I.company_id = _companyid
			AND (I.signed_by_1_id <> _userid OR _userid = 0)
			AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = CCT.area_id) OR _areaid= 0) 
		)
		
	UNION
		SELECT 'CHECKLISTS'::varchar AS check_type, 1 AS Nr WHERE EXISTS (
			SELECT I.id FROM tasks_task I 
			INNER JOIN tasks_tasktemplate TT ON TT.id = I.template_id AND TT.company_id = _companyid AND TT.is_active = true --AND TT.type = 'checklist'
			INNER JOIN checklists_checklisttemplate_tasks CCTT ON CCTT.tasktemplate_id = TT.id
			INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CCTT.checklisttemplate_id AND CCT.company_id = _companyid AND CCT.is_active = true
			INNER JOIN checklists_checklist_tasks CCCTTT ON CCCTTT.task_id = I.id
			INNER JOIN checklists_checklist C ON C.id = CCCTTT.checklist_id AND C.is_active = true AND C.company_id = _companyid
			WHERE (I.created_at > _current_check_date AND I.created_at < _current_check_future_date) AND I.company_id = _companyid AND I.is_active = true
			AND (C.signed_by_1_id <> _userid OR _userid = 0)
			AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = CCT.area_id) OR _areaid= 0) 
		)
		
	UNION
		SELECT 'CHECKLISTS'::varchar AS check_type, 1 AS Nr WHERE EXISTS (
			SELECT I.id FROM tasks_task I 
			INNER JOIN tasks_tasktemplate TT ON TT.id = I.template_id AND TT.company_id = _companyid AND TT.is_active = true --AND TT.type = 'checklist'
			INNER JOIN checklists_checklisttemplate_tasks CCTT ON CCTT.tasktemplate_id = TT.id
			INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CCTT.checklisttemplate_id AND CCT.company_id = _companyid AND CCT.is_active = true
			INNER JOIN checklists_checklist_tasks CCCTTT ON CCCTTT.task_id = I.id
			INNER JOIN checklists_checklist C ON C.id = CCCTTT.checklist_id AND C.is_active = true AND C.company_id = _companyid
			WHERE (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date) AND I.company_id = _companyid AND I.is_active = true
			AND (C.signed_by_1_id <> _userid OR _userid = 0)
			AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = CCT.area_id) OR _areaid= 0) 
		)
		
  UNION
		SELECT 'CHECKLISTTEMPLATES'::varchar AS check_type, 1 AS Nr WHERE EXISTS (	
			SELECT I.id FROM checklists_checklisttemplate I 
			WHERE ((I.created_at > _current_check_date AND I.created_at < _current_check_future_date) OR (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date)) AND I.company_id = _companyid 
			AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = I.area_id) OR _areaid= 0) 
		)
		
	UNION 	
		SELECT 'COMPANY'::varchar AS check_type, 1 AS Nr WHERE EXISTS (		
			SELECT I.id FROM companies_company I 
			WHERE ((I.created_at > _current_check_date AND I.created_at < _current_check_future_date) OR (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date)) AND I.id = _companyid
		)
		
	UNION 	
		SELECT 'SHIFTS'::varchar AS check_type, 1 AS Nr WHERE EXISTS (			
			SELECT I.id FROM companies_shift I 
			WHERE ((I.created_at > _current_check_date AND I.created_at < _current_check_future_date) OR (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date)) AND I.company_id = _companyid
		)
		
	UNION 
		SELECT 'USERS'::varchar AS check_type, 1 AS Nr WHERE EXISTS (			
			SELECT I.id FROM profiles_user I  
			WHERE ((I.created_at > _current_check_date AND I.created_at < _current_check_future_date) OR (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date)) AND I.company_id = _companyid
		)
		
	UNION
		SELECT 'TASKS'::varchar AS check_type, 1 AS Nr WHERE EXISTS (	
			SELECT I.id FROM tasks_task I 
			INNER JOIN tasks_tasktemplate TT ON TT.id = I.template_id AND TT.company_id = _companyid --AND TT.type = 'task' 
			INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TT.id AND TTR.company_id = _companyid
			WHERE (I.created_at > _current_check_date AND I.created_at < _current_check_future_date) AND I.company_id = _companyid AND I.is_active = true
			AND (I.signed_by_id <> _userid OR I.signed_by_id IS NULL OR _userid = 0)
			AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id) OR _areaid= 0) 
		)
		
	UNION
		SELECT 'TASKS'::varchar AS check_type, 1 AS Nr WHERE EXISTS (		
			SELECT I.id FROM tasks_task I 
			INNER JOIN tasks_tasktemplate TT ON TT.id = I.template_id AND TT.company_id = _companyid --AND TT.type = 'task' 
			INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TT.id AND TTR.company_id = _companyid
			WHERE (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date) AND I.company_id = _companyid AND I.is_active = true
			AND (I.signed_by_id <> _userid OR I.signed_by_id IS NULL OR _userid = 0)
			AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id) OR _areaid= 0) 
		)
		
	UNION
		SELECT 'TASKTEMPLATES'::varchar AS check_type, 1 AS Nr WHERE EXISTS (		
			SELECT I.id FROM tasks_tasktemplate I 
			INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = I.id AND TTR.company_id = _companyid
			WHERE ((I.created_at > _current_check_date AND I.created_at < _current_check_future_date) OR (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date)) AND I.company_id = _companyid
			AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id) OR _areaid= 0) 
		)	
		
	UNION
		SELECT 'TASKTEMPLATES'::varchar AS check_type, 1 AS Nr WHERE EXISTS (	
			SELECT I.id FROM tasks_tasktemplatestep I 
			INNER JOIN tasks_tasktemplate A ON A.id = I.template_id 
			INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = A.id AND TTR.company_id = _companyid
			WHERE ((I.created_at > _current_check_date AND I.created_at < _current_check_future_date) OR (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date)) AND A.company_id = _companyid 
			AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id) OR _areaid= 0) 
		)
		
	UNION
		SELECT 'PROPERTYVALUES'::varchar AS check_type, 1 AS Nr WHERE EXISTS (	
			SELECT I.id FROM tasks_properties I 
			WHERE ((I.created_at > _current_check_date AND I.created_at < _current_check_future_date) 
			OR (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date)) AND I.company_id = _companyid
		)
		
	UNION
		SELECT 'PROPERTYVALUES'::varchar AS check_type, 1 AS Nr WHERE EXISTS (	
			SELECT I.id FROM tasks_task I 
			WHERE (I.created_at > _current_check_date AND I.created_at < _current_check_future_date)
			AND I.time_realized_by_id IS NOT NULL
			AND I.company_id = _companyid
		)
		
  UNION
		SELECT 'PROPERTYVALUES'::varchar AS check_type, 1 AS Nr WHERE EXISTS (		
			SELECT I.id FROM tasks_task I 
			WHERE (I.modified_at > _current_check_date AND I.modified_at < _current_check_future_date)
			AND I.time_realized_by_id IS NOT NULL
			AND I.company_id = _companyid
		)
		
	) AS T 
GROUP BY T.check_type
) AS T2	WHERE T2.Nr > 0;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for check_changes_actioncomments
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_changes_actioncomments"("_companyid" int4, "_actionid" int4, "_timestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."check_changes_actioncomments"("_companyid" int4, "_actionid" int4=NULL::integer, "_timestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("nr" int4, "action_id" int4) AS $BODY$
	DECLARE 
		_current_check_date timestamp;
	BEGIN
	IF _timestamp IS NULL THEN
			_current_check_date = NOW()::timestamp - interval '1 minute';
	ELSE
			_current_check_date = _timestamp::timestamp - interval '1 minute';
	END IF;
	RETURN QUERY
	SELECT COUNT(*)::int4 AS nr, AA.id AS action_id FROM actions_actioncomment AAC 
	INNER JOIN actions_action AA ON AA.id = AAC.action_id
	WHERE AA.company_id = _companyid 
	AND (AA.id = _actionid OR _actionid IS NULL)
	AND AAC.modified_at > (get_timestamp_without_companytimezone(_companyid , _current_check_date::timestamp))
	GROUP BY AA.id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for check_email
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_email"("_companyid" int4, "_id" int4, "_email" varchar);
CREATE OR REPLACE FUNCTION "public"."check_email"("_companyid" int4, "_id" int4, "_email" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  total integer;
BEGIN
   SELECT COUNT(*) into total FROM profiles_user  WHERE id <> _id  AND lower(email) = lower(_email);
     RETURN total;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_email
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_email"("_email" varchar);
CREATE OR REPLACE FUNCTION "public"."check_email"("_email" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  total integer;
BEGIN
   SELECT COUNT(*) into total FROM profiles_user WHERE lower(email) = lower(_email);
     RETURN total;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_action
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_action"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_action"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM actions_action S
		INNER JOIN companies_company CC ON CC.id = S.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_actioncomment
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_actioncomment"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_actioncomment"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM actions_actioncomment S
		INNER JOIN actions_action AA ON AA.id = S.action_id
		INNER JOIN companies_company CC ON CC.id = AA.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_area
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_area"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_area"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM companies_area S
		INNER JOIN companies_company CC ON CC.id = S.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_audit
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_audit"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_audit"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM audits_audit S
		INNER JOIN companies_company CC ON CC.id = S.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_audittemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_audittemplate"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_audittemplate"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM audits_audittemplate S
		INNER JOIN companies_company CC ON CC.id = S.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_checklist
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_checklist"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_checklist"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM checklists_checklist S
		INNER JOIN companies_company CC ON CC.id = S.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_checklisttemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_checklisttemplate"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_checklisttemplate"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM checklists_checklisttemplate S
		INNER JOIN companies_company CC ON CC.id = S.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_comment
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_comment"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_comment"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM comments S
		INNER JOIN companies_company CC ON CC.id = S.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_factoryfeed
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_factoryfeed"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_factoryfeed"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM factoryfeeds S
		INNER JOIN companies_company CC ON CC.id = S.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_factoryfeedmessage
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_factoryfeedmessage"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_factoryfeedmessage"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM factoryfeed_messages S
		INNER JOIN companies_company CC ON CC.id = S.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_profileusers
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_profileusers"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_profileusers"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM profiles_user S
		INNER JOIN companies_company CC ON CC.id = S.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_shift
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_shift"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_shift"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM companies_shift S
		INNER JOIN companies_company CC ON CC.id = S.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_task
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_task"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_task"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM tasks_task S
		INNER JOIN companies_company CC ON CC.id = S.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_taskrecurrency
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_taskrecurrency"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_taskrecurrency"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM tasks_taskrecurrency S
		INNER JOIN companies_company CC ON CC.id = S.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_tasktemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_tasktemplate"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_tasktemplate"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM tasks_tasktemplate S
		INNER JOIN companies_company CC ON CC.id = S.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_object_rights_tasktemplatestep
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_object_rights_tasktemplatestep"("_id" int4, "_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_object_rights_tasktemplatestep"("_id" int4, "_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the object may be accessed by this user.  
	SELECT succes INTO outcome FROM (
		SELECT (COUNT(S.id) > 0) AS succes FROM tasks_tasktemplatestep S
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = S.template_id
		INNER JOIN companies_company CC ON CC.id = TTT.company_id
		INNER JOIN profiles_user PU ON PU.company_id = CC.id 
		WHERE S.id = _id AND CC.id = _companyid AND PU.id = _userid
	) AS T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_open_audits
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_open_audits"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."check_open_audits"("_companyid" int4)
  RETURNS TABLE("id" int4, "name" varchar, "template_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
AA.id, 
AAT.name, 
AA.template_id 
FROM audits_audit AA 
INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id AND AA.company_id = AAT.company_id AND AAT.is_active = true 
WHERE AA.company_id = _companyid AND AA.is_active = true;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for check_open_audits
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_open_audits"("_companyid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."check_open_audits"("_companyid" int4, "_audittemplateid" int4)
  RETURNS TABLE("id" int4, "name" varchar, "template_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
AA.id, 
AAT.name, 
AA.template_id 
FROM audits_audit AA 
INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id AND AA.company_id = AAT.company_id AND AAT.is_active = true 
LEFT JOIN profiles_user PU ON PU.id = AA.signed_by_1_id
WHERE AA.company_id = _companyid AND AA.template_id = _audittemplateid AND AA.is_active = true;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for check_open_checklists
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_open_checklists"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."check_open_checklists"("_companyid" int4)
  RETURNS TABLE("id" int4, "name" varchar, "template_id" int4) AS $BODY$BEGIN
	RETURN QUERY
SELECT 
CC.id, 
CCT.name, 
CC.template_id
FROM checklists_checklist CC 
INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id AND CC.company_id = CCT.company_id AND CCT.is_active = true 
WHERE CC.is_active = true AND CC.company_id = _companyid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for check_open_checklists
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_open_checklists"("_companyid" int4, "_checklisttemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."check_open_checklists"("_companyid" int4, "_checklisttemplateid" int4)
  RETURNS TABLE("id" int4, "name" varchar, "template_id" int4) AS $BODY$BEGIN
	RETURN QUERY
SELECT 
CC.id, 
CCT.name, 
CC.template_id
FROM checklists_checklist CC 
INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id AND CC.company_id = CCT.company_id AND CCT.is_active = true 
LEFT JOIN profiles_user PU ON PU.id = CC.signed_by_1_id
WHERE CC.is_active = true AND CC.company_id = _companyid AND CC.template_id = _checklisttemplateid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for check_token_expired_longer_than_day
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_token_expired_longer_than_day"("_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."check_token_expired_longer_than_day"("_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the last time a token was set to expired (happend on login) if this was more than a day ago, if not a other message can be returned
	-- and a possible new login has been done on a other system. 
  SELECT (EXTRACT (EPOCH FROM (token_created_at - token_expired_at)) < 86400)::bool INTO outcome FROM (
		SELECT MAX(AT.created) AS token_created_at, MAX(PET.created_at) AS token_expired_at, AT.user_id FROM authtoken_token AT 
		INNER JOIN profiles_expiredtoken PET ON PET.user_id = AT.user_id
		INNER JOIN profiles_user PU ON PU.id = AT.user_id
		WHERE AT.key <> PET.key AND AT.user_id = _userid AND PU.company_id = _companyid 
		GROUP BY AT.user_id
	) T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_token_expired_longer_than_day
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_token_expired_longer_than_day"("_token" varchar);
CREATE OR REPLACE FUNCTION "public"."check_token_expired_longer_than_day"("_token" varchar)
  RETURNS "pg_catalog"."bool" AS $BODY$
DECLARE
  outcome bool;
BEGIN
	-- check if the last time a token was set to expired (happend on login) if this was more than a day ago, if not a other message can be returned
	-- and a possible new login has been done on a other system. 
  SELECT (EXTRACT (EPOCH FROM (token_created_at - token_expired_at)) < 86400)::bool INTO outcome FROM (
		SELECT MAX(AT.created) AS token_created_at, MAX(PET.created_at) AS token_expired_at, AT.user_id FROM authtoken_token AT 
		INNER JOIN profiles_expiredtoken PET ON PET.user_id = AT.user_id
		INNER JOIN profiles_user PU ON PU.id = AT.user_id
		WHERE AT.key <> PET.key AND PET.key = _token
		GROUP BY AT.user_id
	) T;
	RETURN outcome;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_upn
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_upn"("_upn" varchar);
CREATE OR REPLACE FUNCTION "public"."check_upn"("_upn" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  total integer;
BEGIN
   SELECT COUNT(*) into total FROM profiles_user WHERE  lower(upn) = lower(_upn);
   RETURN total;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_upn
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_upn"("_companyid" int4, "_id" int4, "_upn" varchar);
CREATE OR REPLACE FUNCTION "public"."check_upn"("_companyid" int4, "_id" int4, "_upn" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  total integer;
BEGIN
   SELECT COUNT(*) into total FROM profiles_user WHERE id <> _id AND lower(upn) = lower(_upn);
   RETURN total;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_username
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_username"("_username" varchar);
CREATE OR REPLACE FUNCTION "public"."check_username"("_username" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  total integer;
BEGIN
   SELECT COUNT(*) into total FROM profiles_user WHERE  lower(username) = lower(_username);
   RETURN total;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for check_username
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."check_username"("_companyid" int4, "_id" int4, "_username" varchar);
CREATE OR REPLACE FUNCTION "public"."check_username"("_companyid" int4, "_id" int4, "_username" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  total integer;
BEGIN
   SELECT COUNT(*) into total FROM profiles_user  WHERE id <> _id AND lower(username) = lower(_username);
   RETURN total;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for consistent_shuffle
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."consistent_shuffle"("alphabet" text, "salt" text);
CREATE OR REPLACE FUNCTION "public"."consistent_shuffle"("alphabet" text, "salt" text)
  RETURNS "pg_catalog"."text" AS $BODY$
DECLARE
    SALT_LENGTH INT := length(salt);
    integer INT = 0;
    temp TEXT = '';
    j INT = 0;
    v INT := 0;
    p INT := 0;
    i INT := length(alphabet) - 1;
    output TEXT := alphabet;
BEGIN
		------------------------------
		-- BASED ON hashids.org functionality https://hashids.org/ & https://stackoverflow.com/questions/41970461/how-to-generate-a-random-unique-alphanumeric-id-of-length-n-in-postgres-9-6
		-- Functionality created a alfabeth shuffle method based on salt
		------------------------------
    IF salt IS NULL OR length(LTRIM(RTRIM(salt))) = 0 THEN
        RETURN alphabet;
    END IF;
    WHILE i > 0 LOOP
        v := v % SALT_LENGTH;
        integer := ASCII(substr(salt, v + 1, 1));
        p := p + integer;
        j := (integer + v + p) % i;

        temp := substr(output, j + 1, 1);
        output := substr(output, 1, j) || substr(output, i + 1, 1) || substr(output, j + 2);
        output := substr(output, 1, i) || temp || substr(output, i + 2);

        i := i - 1;
        v := v + 1;
    END LOOP;
    RETURN output;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for create_audit
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."create_audit"("_company_id" int4, "_audittemplate_id" int4, "_tasktemplate_id" int4, "_status" varchar);
CREATE OR REPLACE FUNCTION "public"."create_audit"("_company_id" int4, "_audittemplate_id" int4, "_tasktemplate_id" int4, "_status" varchar)
  RETURNS TABLE("audit_id" int4, "task_id" int4) AS $BODY$
	DECLARE
		_rowcount int4;
		_audit_id int4;
		_task_id int4;
		_inserted_task_id int4;
		_temprow record;
	BEGIN
	 --Adding audit item and return the just created id to _audit_id variable 
	 INSERT INTO audits_audit ("company_id", "template_id", "is_complete", "created_at", "modified_at", "is_active")
	 SELECT "company_id", "id" AS template_id, false, now()::timestamp, now()::timestamp, true FROM "audits_audittemplate" WHERE "id" = _audittemplate_id AND "company_id" = _company_id
	 RETURNING id INTO _audit_id;
	 --Adding audit tasks--------------------------------------------------------------
	 FOR _temprow IN
			 --Get basic information from the task_template based on the audit template that is chosen
       SELECT 'todo' AS _status, TT.id AS _template_id, TT.company_id AS _company_id, now()::timestamp AS _created_at, now()::timestamp AS _modified_at, true AS _is_active  FROM audits_audittemplate_tasks CCT 
			 INNER JOIN tasks_tasktemplate TT ON TT.id = CCT.tasktemplate_id AND TT.is_active = true
			 WHERE CCT.audittemplate_id = _audittemplate_id  AND TT."company_id" = _company_id
   LOOP
			 --Add a task and retirn the just created id to _inserted_task_id
			 INSERT INTO tasks_task (id, status, template_id, company_id , created_at, modified_at, is_active) VALUES (DEFAULT, _temprow._status, _temprow._template_id, _temprow._company_id , _temprow._created_at, _temprow._modified_at, _temprow._is_active)
		   RETURNING id INTO _inserted_task_id;
			 --Set possible task_id that is being set.
			 IF _temprow._template_id = _tasktemplate_id THEN
					_task_id = _inserted_task_id;
			 END IF;
			 --Add the task-audit relation based on the _audit_id and _inserted_task_id variables
			 INSERT INTO audits_audit_tasks (audit_id, task_id) VALUES (_audit_id, _inserted_task_id);	
   END LOOP;
	 IF _task_id > 0 THEN
			UPDATE tasks_task SET status = _status WHERE id = _task_id;
	 END IF;
	 
	 RETURN QUERY SELECT _audit_id::int4 AS audit_id, _task_id::int4 AS task_id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for create_audit
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."create_audit"("_company_id" int4, "_audittemplate_id" int4, "_tasktemplate_id" int4, "_status" varchar, "_score" int4);
CREATE OR REPLACE FUNCTION "public"."create_audit"("_company_id" int4, "_audittemplate_id" int4, "_tasktemplate_id" int4, "_status" varchar, "_score" int4)
  RETURNS TABLE("audit_id" int4, "task_id" int4) AS $BODY$
	DECLARE
		_rowcount int4;
		_audit_id int4;
		_task_id int4;
		_inserted_task_id int4;
		_temprow record;
		_task_weight numeric(9,1);
	BEGIN
	 --Adding audit item and return the just created id to _audit_id variable 
	 INSERT INTO audits_audit ("company_id", "template_id", "is_complete", "created_at", "modified_at", "is_active")
	 SELECT "company_id", "id" AS template_id, false, now()::timestamp, now()::timestamp, true FROM "audits_audittemplate" WHERE "id" = _audittemplate_id AND "company_id" = _company_id
	 RETURNING id INTO _audit_id;
	 --Adding audit tasks--------------------------------------------------------------
	 FOR _temprow IN
			 --Get basic information from the task_template based on the audit template that is chosen
       SELECT 'todo' AS _status, TT.id AS _template_id, TT.company_id AS _company_id, now()::timestamp AS _created_at, now()::timestamp AS _modified_at, true AS _is_active, 
			 AA.max_task_score AS _max_task_score, AA.min_task_score AS _min_task_score, TT.weight AS _weight, (AA.max_task_score *  TT.weight)::int AS _maxscore FROM audits_audittemplate_tasks CCT 
			 INNER JOIN tasks_tasktemplate TT ON TT.id = CCT.tasktemplate_id AND TT.is_active = true
			 INNER JOIN audits_audittemplate AA ON AA.id = CCT.audittemplate_id
			 WHERE CCT.audittemplate_id = _audittemplate_id  AND TT."company_id" = _company_id
   LOOP
			 --Add a task and retirn the just created id to _inserted_task_id
			 INSERT INTO tasks_task (id, status, template_id, company_id , created_at, modified_at, is_active, max_score) VALUES (DEFAULT, _temprow._status, _temprow._template_id, _temprow._company_id , _temprow._created_at, _temprow._modified_at, _temprow._is_active, _temprow._maxscore)
		   RETURNING id INTO _inserted_task_id;
			 --Set possible task_id that is being set.
			 IF _temprow._template_id = _tasktemplate_id THEN
					_task_id = _inserted_task_id;
					_task_weight = _temprow._weight;
			 END IF;
			 --Add the task-audit relation based on the _audit_id and _inserted_task_id variables
			 INSERT INTO audits_audit_tasks (audit_id, task_id) VALUES (_audit_id, _inserted_task_id);	
   END LOOP;
	 IF _task_id > 0 THEN
			UPDATE tasks_task SET status = _status, score = _score, total_score = (_score * _task_weight)::int WHERE id = _task_id;
	 END IF;
	 
	 RETURN QUERY SELECT _audit_id::int4 AS audit_id, _task_id::int4 AS task_id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for create_checklist
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."create_checklist"("_company_id" int4, "_checklisttemplate_id" int4, "_tasktemplate_id" int4, "_status" varchar);
CREATE OR REPLACE FUNCTION "public"."create_checklist"("_company_id" int4, "_checklisttemplate_id" int4, "_tasktemplate_id" int4, "_status" varchar)
  RETURNS TABLE("checklist_id" int4, "task_id" int4) AS $BODY$
	DECLARE
		_rowcount int4;
		_checklist_id int4;
		_task_id int4;
		_inserted_task_id int4;
		_temprow record;
	BEGIN
	 --Adding checklist item and return the just created id to _checklist_id variable 
	 INSERT INTO checklists_checklist ("company_id", "template_id", "is_complete", "created_at", "modified_at", "is_active")
	 SELECT "company_id", "id" AS template_id, false, now()::timestamp, now()::timestamp, true FROM "checklists_checklisttemplate" WHERE "id" = _checklisttemplate_id AND "company_id" = _company_id
	 RETURNING id INTO _checklist_id;
	 --Adding checklist tasks--------------------------------------------------------------
	 FOR _temprow IN
			 --Get basic information from the task_template based on the checklist template that is chosen
       SELECT 'todo' AS _status, TT.id AS _template_id, TT.company_id AS _company_id, now()::timestamp AS _created_at, now()::timestamp AS _modified_at, true AS _is_active  FROM checklists_checklisttemplate_tasks CCT 
			 INNER JOIN tasks_tasktemplate TT ON TT.id = CCT.tasktemplate_id AND TT.is_active = true
			 WHERE CCT.checklisttemplate_id = _checklisttemplate_id  AND TT."company_id" = _company_id
   LOOP
			 --Add a task and retirn the just created id to _inserted_task_id
			 INSERT INTO tasks_task (id, status, template_id, company_id , created_at, modified_at, is_active) VALUES (DEFAULT, _temprow._status, _temprow._template_id, _temprow._company_id , _temprow._created_at, _temprow._modified_at, _temprow._is_active)
		   RETURNING id INTO _inserted_task_id;
			 --Set possible task_id that is being set.
			 IF _temprow._template_id = _tasktemplate_id THEN
					_task_id = _inserted_task_id;
			 END IF;
			 --Add the task-checklist relation based on the _checklist_id and _inserted_task_id variables
			 INSERT INTO checklists_checklist_tasks (checklist_id, task_id) VALUES (_checklist_id, _inserted_task_id);	
   END LOOP;
	 IF _task_id > 0 THEN
			UPDATE tasks_task SET status = _status WHERE id = _task_id;
	 END IF;
	 
	 RETURN QUERY SELECT _checklist_id::int4 AS checklist_id, _task_id::int4 AS task_id;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for create_setup_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."create_setup_company"("company_name" varchar);
CREATE OR REPLACE FUNCTION "public"."create_setup_company"("company_name" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	BEGIN
	-- Generate company records
	-- Generate company areas
	-- Generate company users
	-- Generate company shifts
	-- Generate checklists templates
	-- Generate audits templates
	-- Generate task templates weekly
	-- Generate task_templates monthly
	-- Generate task_templates one_time_only
	-- Generate task_templates shift
	-- Generate random tasks, actions, checklists, audits
	RETURN 1::int4;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for create_setup_users
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."create_setup_users"("_company_id" int4);
CREATE OR REPLACE FUNCTION "public"."create_setup_users"("_company_id" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
		-- NOTE this is a setup function; can be optimezed and refactored but seeing it's only for internal use....
	 SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('User.Basic.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('User.Basic.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'basic', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'000000000000000','BASIC'), now()::timestamp, _id);
	 END IF;
	 
	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																													 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																													 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																													 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
	 
	 SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('User.ShiftLeader.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('User.ShiftLeader.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'shift_leader', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'000000000000000','SHIFT'), now()::timestamp, _id);
	 END IF;
	 
	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																												 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																												 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																												 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
	 
	 SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('User.Manager.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('User.Manager.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'manager', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'000000000000000','MANAG'), now()::timestamp, _id);
	 END IF;
	 
	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																												 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																												 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																												 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
		 
	 SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('UserA.Basic.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('UserA.Basic.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'basic', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'00000000000000','BASICA'), now()::timestamp, _id);
	 END IF;
	 
	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																												 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																												 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																												 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
	
	 SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('UserA.ShiftLeader.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('UserA.ShiftLeader.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'shift_leader', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'00000000000000','SHIFTA'), now()::timestamp, _id);
	 END IF;
	 
	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																												 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																												 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																												 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
	
	 SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('UserA.Manager.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('UserA.Manager.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'manager', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'00000000000000','MANAGA'), now()::timestamp, _id);
	 END IF;
	 
	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																												 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																												 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																												 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
		 
	  SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('UserB.Basic.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('UserB.Basic.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'basic', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'00000000000000','BASICB'), now()::timestamp, _id);
	 END IF;
 	 
	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																												 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																												 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																												 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
	
	 SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('UserB.ShiftLeader.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('UserB.ShiftLeader.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'shift_leader', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'00000000000000','SHIFTB'), now()::timestamp, _id);
	 END IF;
 	 
	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																												 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																												 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																												 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
	
	 SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('UserB.Manager.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('UserB.Manager.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'manager', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'00000000000000','MANAGB'), now()::timestamp, _id);
	 END IF;
	 
	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																												 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																												 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																												 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
	
	 	  SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('UserC.Basic.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('UserC.Basic.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'basic', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'00000000000000','BASICC'), now()::timestamp, _id);
	 END IF;
 	 
	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																												 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																												 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																												 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
	
	 SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('UserC.ShiftLeader.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('UserC.ShiftLeader.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'shift_leader', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'00000000000000','SHIFTC'), now()::timestamp, _id);
	 END IF;
 	 
	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																												 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																												 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																												 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
	
	 SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('UserC.Manager.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('UserC.Manager.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'manager', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'00000000000000','MANAGC'), now()::timestamp, _id);
	 END IF;
	 	 
	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																												 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																												 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																												 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
	
	 
	 RETURN 0;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for create_test_users
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."create_test_users"("_company_id" int4);
CREATE OR REPLACE FUNCTION "public"."create_test_users"("_company_id" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_id int4;
	BEGIN
	 SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('User.Test1.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('User.Test1.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'basic', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'0000000000001','TEST',_company_id::varchar), now()::timestamp, _id);
	 END IF;
	 
	 	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																													 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																													 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																													 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
																													 
	 SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('User.Test2.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('User.Test2.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'basic', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'0000000000002','TEST',_company_id::varchar), now()::timestamp, _id);
	 END IF;
	 
	 	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																													 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																													 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																													 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
																													 
	 SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('User.Test3.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('User.Test3.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'basic', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'0000000000003','TEST',_company_id::varchar), now()::timestamp, _id);
	 END IF;
	 
	 	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																													 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																													 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																													 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
																													 
	  SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('User.Test4.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('User.Test4.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'basic', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'0000000000004','TEST',_company_id::varchar), now()::timestamp, _id);
	 END IF;
	 
	 	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																													 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																													 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																													 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
																													 
	 SELECT id INTO _id FROM profiles_user WHERE username = CONCAT('User.Test5.',_company_id::varchar);
	 IF _id IS NULL OR _id < 0 THEN
		 INSERT INTO profiles_user (id, password, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, company_id, picture, role, created_at, modified_at, timezone, is_deleted) 
		 VALUES (DEFAULT,'pbkdf2_sha256$36000$k0gBEuafXQUIE0xV$tJ+G0tU4YNP3IRNy11vTuUaGhJ5V85wjARzKLsG+xnI=', false, CONCAT('User.Test5.',_company_id::varchar), 'Firstname', 'Lastname','', false, true, now()::timestamp, _company_id, '', 'basic', now()::timestamp, now()::timestamp, 0, false)
		 RETURNING id INTO _id;
		 INSERT INTO authtoken_token (key, created, user_id) VALUES (CONCAT(REPLACE(REPLACE(REPLACE(REPLACE(now()::timestamp::varchar,' ',''), '.',''),':',''),'-',''),'0000000000005','TEST',_company_id::varchar), now()::timestamp, _id);
	 END IF;
	 
	 	 INSERT INTO profiles_user_allowed_areas (user_id, area_id) SELECT PU.id, CA.id FROM companies_area CA 
																													 INNER JOIN profiles_user PU ON PU.company_id = CA.company_id
																													 WHERE PU.id = _id AND CA.company_id = _company_id and CA.is_active = true 
																													 AND CA.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _id);
	 RETURN 0;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for export_data_audititems_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_audititems_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_audititems_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("AuditID" int4, "Audit Name" varchar, "AreaID" int4, "AreaName" varchar, "DoneBy1" varchar, "DoneBy2" varchar, "DoneDateTime" timestamp, "DoneDate" date, "DoneTime" varchar, "DoneWeekDay" int4, "DoneWeekNr" int4, "DoneMonth" int4, "DoneYear" int4, "Score" varchar, "ItemId" int4, "ItemTemplateId" int4, "ItemName" varchar, "Status" varchar, "ActionId" int4, "ActionComment" varchar, "ActionDescription" varchar, "StartDate" timestamp, "DueDate" timestamp, "Author" varchar) AS $BODY$
DECLARE 
	_timezone varchar;
BEGIN
	SELECT get_timezone_with_company(_companyid) INTO _timezone;
	RETURN QUERY
	SELECT 
		A.template_id AS AuditID,--AuditID	
		AAT.name AS "Audit Name", --Audit Name	
		AAT.area_id AS AreaID, --AreaID	
		CA.name AS AreaName, --AreaName	
		CONCAT(PU.first_name, ' ',PU.last_name)::varchar AS DoneBy1, --DoneBy1	
		A.signed_by_2 AS DoneBy2,--DoneBy2	
		date_trunc('second', timezone(_timezone, A.signed_at_1::timestamptz)::timestamp) AS DoneDateTime, -- DoneDateTime
		timezone(_timezone, A.signed_at_1::timestamptz)::date AS DoneDate,--DoneDate	
		TO_CHAR(timezone(_timezone, A.signed_at_1::timestamptz), 'HH24:MI')::varchar AS DoneTime, --DoneTime
		TO_CHAR(timezone(_timezone, A.signed_at_1::timestamptz), 'D')::int AS DoneWeekDay, -- DoneWeekDay
		TO_CHAR(timezone(_timezone, A.signed_at_1::timestamptz), 'IW')::int As DoneWeekNr, -- DoneWeekNr
		TO_CHAR(timezone(_timezone, A.signed_at_1::timestamptz), 'MM')::int As DoneMonth, -- DoneMonth
		TO_CHAR(timezone(_timezone, A.signed_at_1::timestamptz), 'YYYY')::int As DoneYear, -- DoneYear
		CASE WHEN AAT.score_type = 'score' THEN
			TT.Score::varchar
		ELSE
			CASE WHEN TT.status = 'ok' THEN
				1::varchar
			WHEN TT.status = 'not ok' THEN
				0::varchar
			ELSE
				''::varchar
			END 
		END AS Score,
		TT.id AS ItemID, --ItemID	
		TTT.id AS ItemTemplateID,
		TTT.name AS ItemName,--ItemName	
		CASE WHEN TT.status = 'skipped' THEN
			TT.status::varchar
		WHEN AAT.score_type = 'thumbs' THEN
			TT.status::varchar
		ELSE
			''::varchar
		END AS Status,	
		AA.id AS ActionID,	--ActionID
		AA.comment::varchar AS ActionComment, --ActionComment	
		AA.description::varchar AS ActionDescription, --ActionDescription	
		AA.created_at::timestamp AS StartDate, --StartDate	
		AA.due_date::timestamp AS DueDate, --DueDate	
		CONCAT(PUA.first_name, ' ',PUA.last_name)::varchar AS Author --Author
		FROM audits_audit A
		INNER JOIN audits_audittemplate AAT ON AAT.id = A.template_id
		INNER JOIN audits_audit_tasks AATT ON AATT.audit_id = A.id
		INNER JOIN tasks_task TT ON TT.id = AATT.task_id
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN companies_area CA ON CA.id = AAT.area_id
		LEFT JOIN profiles_user PU ON PU.id = A.signed_by_1_id AND PU.company_id = _companyid
		LEFT JOIN actions_action AA ON AA.task_id = TT.id AND AA.company_id = _companyid --OR AA.task_template_id = TTT.id -> disabled, only on task hookup
		LEFT JOIN profiles_user PUA ON PUA.id = AA.created_by_id AND PUA.company_id = _companyid 
		WHERE AAT.company_id = _companyid AND A.company_id = _companyid AND TT.company_id = _companyid AND TTT.company_id = _companyid AND A.is_complete = true 
		AND (A.signed_at_1 >= timezone(_timezone, _starttimestamp::timestamp) OR _starttimestamp IS NULL)
		AND (A.signed_at_1 <= timezone(_timezone, _endtimestamp::timestamp) OR _endtimestamp IS NULL)
		ORDER BY AAT.name, A.id DESC, TT.id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_audits_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_audits_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_audits_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("AuditID" int4, "Audit Name" varchar, "NrOfItems" int4, "AreaID" int4, "AreaName" varchar, "DoneBy1" varchar, "DoneBy2" varchar, "DoneDateTime" timestamp, "DoneDate" date, "DoneTime" varchar, "DoneWeekDay" int4, "DoneWeekNr" int4, "DoneMonth" int4, "DoneYear" int4, "Score" varchar) AS $BODY$
DECLARE 
	_timezone varchar;
BEGIN
	SELECT get_timezone_with_company(_companyid) INTO _timezone;
	RETURN QUERY
	SELECT 
		AA.template_id AS AuditID,--AuditID	
		AAT.name AS "Audit Name", --Checklist Name	
		(SELECT COUNT(AATT.id) FROM audits_audittemplate_tasks AATT WHERE AATT.audittemplate_id = AAT.id)::int AS NrOfItems, -- NrOfItems
		AAT.area_id AS AreaID, --AreaID	
		CA.name AS AreaName, --AreaName	
		CONCAT(PU.first_name, ' ',PU.last_name)::varchar AS DoneBy1, --DoneBy1	
		AA.signed_by_2 AS DoneBy2,--DoneBy2	
		date_trunc('second', timezone(_timezone, AA.signed_at_1::timestamptz)::timestamp) AS DoneDateTime, -- DoneDateTime
		timezone(_timezone, AA.signed_at_1::timestamptz)::date AS DoneDate,--DoneDate	
		TO_CHAR(timezone(_timezone, AA.signed_at_1::timestamptz), 'HH24:MI')::varchar AS DoneTime, --DoneTime
		TO_CHAR(timezone(_timezone, AA.signed_at_1::timestamptz), 'D')::int AS DoneWeekDay, -- DoneWeekDay
		TO_CHAR(timezone(_timezone, AA.signed_at_1::timestamptz), 'IW')::int AS DoneWeekNr, -- DoneWeekNr
		TO_CHAR(timezone(_timezone, AA.signed_at_1::timestamptz), 'MM')::int AS DoneMonth, -- DoneMonth
		TO_CHAR(timezone(_timezone, AA.signed_at_1::timestamptz), 'YYYY')::int AS DoneYear,
		CONCAT(AA.total_score::varchar, '%')::varchar AS Score
		FROM audits_audit AA
		INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
		INNER JOIN companies_area CA ON CA.id = AAT.area_id
		LEFT JOIN profiles_user PU ON PU.id = AA.signed_by_1_id AND PU.company_id = _companyid
		WHERE AAT.company_id = _companyid AND AA.company_id = _companyid AND CA.company_id = _companyid AND AA.is_complete = true 
		AND (AA.signed_at_1 >= timezone(_timezone, _starttimestamp::timestamp) OR _starttimestamp IS NULL)
		AND (AA.signed_at_1 <= timezone(_timezone, _endtimestamp::timestamp) OR _endtimestamp IS NULL)
		ORDER BY AAT.name, AA.signed_at_1 DESC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_audittemplateitems_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_audittemplateitems_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_audittemplateitems_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("auditid" int4, "auditname" varchar, "areaid" int4, "areaname" varchar, "itemid" int4, "itemname" varchar, "itemdescription" text, "haspicture" bool, "hasvideo" bool, "hasinstructionfile" bool, "instructionnr" int4, "weight" numeric) AS $BODY$
DECLARE 
	_timezone varchar;
BEGIN
	SELECT get_timezone_with_company(_companyid) INTO _timezone;
	RETURN QUERY
	SELECT 
	AAT.id AS AuditId,
	AAT.name AS AuditName,
	CA.id AS AreaId,
	CA.name AS AreaName,
	TTT.id AS ItemId,
	TTT.name AS ItemName,
	TTT.description AS ItemDescription,
	(TTT.picture IS NOT NULL AND TTT.picture <> '')::bool AS HasPicture,
	(TTT.video IS NOT NULL AND TTT.video <> '')::bool AS HasVideo,
	(TTT.description_file IS NOT NULL AND TTT.description_file <> '')::bool AS HasInstructionFile,
	(SELECT COUNT(TTTS.id) FROM tasks_tasktemplatestep TTTS WHERE TTTS.is_active = true AND TTTS.template_id = TTT.id)::int4 AS InstructionNr,
	TTT.weight
	FROM tasks_tasktemplate TTT
	INNER JOIN audits_audittemplate_tasks AATT ON AATT.tasktemplate_id = TTT.id 
	INNER JOIN audits_audittemplate AAT ON AAT.id = audittemplate_id
	INNER JOIN companies_area CA ON CA.id = AAT.area_id
	WHERE TTT.company_id = _companyid AND AAT.company_id = _companyid AND CA.company_id = _companyid AND AAT.is_active = true AND TTT.is_active = true
	ORDER BY AAT.name, TTT.index, TTT.name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_audittemplates_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_audittemplates_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_audittemplates_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("AuditID" int4, "Audit Name" varchar, "NrOfItems" int4, "AreaID" int4, "AreaName" varchar, "ScoreType" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
		AAT.id AS AuditID, --ChecklistID
		AAT.name AS "Audit Name", -- Checklist Name
		(SELECT COUNT(AATT.id) FROM audits_audittemplate_tasks AATT WHERE AATT.audittemplate_id = AAT.id)::int AS NrOfItems, -- NrOfItems
		AAT.area_id AS AreaID, -- AreaID
		CA.name AS AreaName, -- AreaName
		AAT.score_type AS ScoreType
		FROM audits_audittemplate  AAT 
		INNER JOIN companies_area CA ON CA.id = AAT.area_id
		WHERE AAT.company_id = _companyid AND CA.company_id = _companyid
		ORDER BY AAT.name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_checklistitems_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_checklistitems_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_checklistitems_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("ChecklistID" int4, "Checklist Name" varchar, "AreaID" int4, "AreaName" varchar, "DoneBy1" varchar, "DoneBy2" varchar, "DoneDateTime" timestamp, "DoneDate" date, "DoneTime" varchar, "DoneWeekDay" int4, "DoneWeekNr" int4, "DoneMonth" int4, "DoneYear" int4, "ItemId" int4, "ItemTemplateID" int4, "ItemName" varchar, "Status" varchar, "ActionId" int4, "ActionComment" varchar, "ActionDescription" varchar, "StartDate" timestamp, "DueDate" timestamp, "Author" varchar) AS $BODY$
DECLARE 
	_timezone varchar;
BEGIN
	SELECT get_timezone_with_company(_companyid) INTO _timezone;
	RETURN QUERY
	SELECT 
		CC.template_id AS ChecklistID,--ChecklistID	
		CCT.name AS "Checklist Name", --Checklist Name	
		CCT.area_id AS AreaID, --AreaID	
		CA.name AS AreaName, --AreaName	
		CONCAT(PU.first_name, ' ',PU.last_name)::varchar AS DoneBy1, --DoneBy1	
		CC.signed_by_2 AS DoneBy2,--DoneBy2	
		date_trunc('second', timezone(_timezone, CC.signed_at_1::timestamptz)::timestamp) AS DoneDateTime, -- DoneDateTime
		timezone(_timezone, CC.signed_at_1::timestamptz)::date AS DoneDate,--DoneDate	
		TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamptz), 'HH24:MI')::varchar AS DoneTime, --DoneTime
		TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamptz), 'D')::int AS DoneWeekDay, -- DoneWeekDay
		TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamptz), 'IW')::int As DoneWeekNr, -- DoneWeekNr
		TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamptz), 'MM')::int As DoneMonth, -- DoneMonth
		TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamptz), 'YYYY')::int As DoneYear, -- DoneYear
		TT.id AS ItemID, --ItemID	
		TTT.id AS ItemTemplateID,
		TTT.name AS ItemName,--ItemName	
		TT.status AS Status, --Status	
		AA.id AS ActionID,	--ActionID
		AA.comment::varchar AS ActionComment, --ActionComment	
		AA.description::varchar AS ActionDescription, --ActionDescription	
		AA.created_at::timestamp AS StartDate, --StartDate	
		AA.due_date::timestamp AS DueDate, --DueDate	
		CONCAT(PUA.first_name, ' ',PUA.last_name)::varchar AS Author --Author
		FROM checklists_checklist CC
		INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
		INNER JOIN checklists_checklist_tasks CCTT ON CCTT.checklist_id = CC.id
		INNER JOIN tasks_task TT ON TT.id = CCTT.task_id AND TT.status <> 'todo'
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN companies_area CA ON CA.id = CCT.area_id
		LEFT JOIN profiles_user PU ON PU.id = CC.signed_by_1_id AND PU.company_id = _companyid
		LEFT JOIN actions_action AA ON AA.task_id = TT.id AND AA.company_id = _companyid --OR AA.task_template_id = TTT.id disabled only on task hookup
		LEFT JOIN profiles_user PUA ON PUA.id = AA.created_by_id AND PUA.company_id = _companyid
		WHERE CCT.company_id = _companyid AND CC.company_id = _companyid AND TT.company_id = _companyid AND TTT.company_id = _companyid AND CC.is_complete = true
		AND (CC.signed_at_1 >= timezone(_timezone, _starttimestamp::timestamp) OR _starttimestamp IS NULL)
		AND (CC.signed_at_1 <= timezone(_timezone, _endtimestamp::timestamp) OR _endtimestamp IS NULL)	
		ORDER BY CCT.name, CC.id DESC, TT.id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_checklists_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_checklists_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_checklists_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("ChecklistID" int4, "Checklist Name" varchar, "NrOfItems" int4, "AreaID" int4, "AreaName" varchar, "DoneBy1" varchar, "DoneBy2" varchar, "DoneDateTime" timestamp, "DoneDate" date, "DoneTime" varchar, "DoneWeekDay" int4, "DoneWeekNr" int4, "DoneMonth" int4, "DoneYear" int4) AS $BODY$
DECLARE 
	_timezone varchar;
BEGIN
	SELECT get_timezone_with_company(_companyid) INTO _timezone;
	RETURN QUERY
	SELECT 
		CC.template_id AS ChecklistID,--ChecklistID	
		CCT.name AS "Checklist Name", --Checklist Name	
		(SELECT COUNT(CCTT.id) FROM checklists_checklisttemplate_tasks CCTT WHERE CCTT.checklisttemplate_id = CCT.id)::int AS NrOfItems, -- NrOfItems
		CCT.area_id AS AreaID, --AreaID	
		CA.name AS AreaName, --AreaName	
		CONCAT(PU.first_name, ' ',PU.last_name)::varchar AS DoneBy1, --DoneBy1	
		CC.signed_by_2 AS DoneBy2,--DoneBy2	
		date_trunc('second', timezone(_timezone, CC.signed_at_1::timestamptz)::timestamp) AS DoneDateTime, -- DoneDateTime
		timezone(_timezone, CC.signed_at_1::timestamptz)::date AS DoneDate,--DoneDate	
		TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamptz), 'HH24:MI')::varchar AS DoneTime, --DoneTime
		TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamptz), 'D')::int AS DoneWeekDay, -- DoneWeekDay
		TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamptz), 'IW')::int As DoneWeekNr, -- DoneWeekNr
		TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamptz), 'MM')::int As DoneMonth, -- DoneMonth
		TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamptz), 'YYYY')::int As DoneYear
		FROM checklists_checklist CC
		INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
		INNER JOIN companies_area CA ON CA.id = CCT.area_id
		LEFT JOIN profiles_user PU ON PU.id = CC.signed_by_1_id AND PU.company_id = _companyid
		WHERE CCT.company_id = _companyid AND CC.company_id = _companyid AND CA.company_id = _companyid AND CC.is_complete = true 
		AND (CC.signed_at_1 >= timezone(_timezone, _starttimestamp::timestamp) OR _starttimestamp IS NULL)
		AND (CC.signed_at_1 <= timezone(_timezone, _endtimestamp::timestamp) OR _endtimestamp IS NULL)
		ORDER BY CCT.name, CC.signed_at_1 DESC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_checklisttemplateitems_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_checklisttemplateitems_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_checklisttemplateitems_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("checklistid" int4, "checklistname" varchar, "areaid" int4, "areaname" varchar, "itemid" int4, "itemname" varchar, "itemdescription" text, "haspicture" bool, "hasvideo" bool, "hasinstructionfile" bool, "instructionnr" int4) AS $BODY$
DECLARE 
	_timezone varchar;
BEGIN
	SELECT get_timezone_with_company(_companyid) INTO _timezone;
	RETURN QUERY
	SELECT 
		CCT.id AS ChecklistId,
		CCT.name AS ChecklistName,
		CA.id AS AreaId,
		CA.name AS AreaName,
		TTT.id AS ItemId,
		TTT.name AS ItemName,
		TTT.description AS ItemDescription,
		(TTT.picture IS NOT NULL AND TTT.picture <> '')::bool AS HasPicture,
		(TTT.video IS NOT NULL AND TTT.video <> '')::bool AS HasVideo,
		(TTT.description_file IS NOT NULL AND TTT.description_file <> '')::bool AS HasInstructionFile,
		(SELECT COUNT(TTTS.id)::int4 FROM tasks_tasktemplatestep TTTS WHERE TTTS.is_active = true AND TTTS.template_id = TTT.id)::int4 AS InstructionNr
		FROM tasks_tasktemplate TTT
		INNER JOIN checklists_checklisttemplate_tasks CCTT ON CCTT.tasktemplate_id = TTT.id 
		INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CCTT.checklisttemplate_id
		INNER JOIN companies_area CA ON CA.id = CCT.area_id
		WHERE TTT.company_id = _companyid AND CCT.company_id = _companyid AND CA.company_id = _companyid AND CCT.is_active = true AND TTT.is_active = true
	ORDER BY CCT.name, TTT.index, TTT.name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_checklisttemplates_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_checklisttemplates_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_checklisttemplates_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("ChecklistID" int4, "Checklist Name" varchar, "NrOfItems" int4, "AreaID" int4, "AreaName" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
		CCT.id AS ChecklistID, --ChecklistID
		CCT.name AS "Checklist Name", -- Checklist Name
		(SELECT COUNT(CC.id) FROM checklists_checklisttemplate_tasks CC WHERE CC.checklisttemplate_id = CCT.id)::int AS NrOfItems, -- NrOfItems
		CCT.area_id AS AreaID, -- AreaID
		CA.name AS AreaName
		FROM checklists_checklisttemplate  CCT 
		INNER JOIN companies_area CA ON CA.id = CCT.area_id
		WHERE CCT.company_id = _companyid AND CA.company_id = _companyid
		ORDER BY CCT.name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_company_management_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_company_management_overview"("_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_company_management_overview"("_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("id" int4, "name" varchar, "users" int4, "tasks" int4, "checklists" int4, "audits" int4, "actions" int4, "taskplanned" int4, "taskexecuted" int4, "tasksexecperc" int4, "checklistexec" int4, "auditsexec" int4, "newactions" int4, "newcomments" int4, "newfeedmessages" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT companies_company.ID,companies_company.NAME,
	(SELECT COUNT (*)::int4 FROM profiles_user WHERE profiles_user.company_id = companies_company."id" AND profiles_user.is_active = true and profiles_user.is_deleted = false AND profiles_user."role" IS NOT NULL ) AS users,
	(SELECT COUNT	(*)::int4 FROM tasks_tasktemplate WHERE	tasks_tasktemplate.company_id = companies_company."id" AND tasks_tasktemplate.is_active = true AND tasks_tasktemplate."type" = 'task') AS tasks,
	(SELECT COUNT (*)::int4 FROM checklists_checklisttemplate WHERE checklists_checklisttemplate.company_id = companies_company."id" AND checklists_checklisttemplate.is_active = true ) AS checklists,
	(SELECT COUNT (*)::int4 FROM audits_audittemplate WHERE audits_audittemplate.company_id = companies_company."id" AND audits_audittemplate.is_active = true ) AS audits,
	(SELECT COUNT (*)::int4 FROM actions_action WHERE actions_action.company_id = companies_company."id" AND actions_action.is_active = true ) AS actions,
	(SELECT COUNT (*)::int4 FROM "tasks_task" TT INNER JOIN "tasks_tasktemplate" TTT ON TTT.id = TT.template_id AND TTT.is_active = true AND TTT.type <> 'audit' AND type <> 'checklist' WHERE TT."company_id" = companies_company."id" AND TT."is_active" = true AND TT."end_date" BETWEEN _starttimestamp AND _endtimestamp) AS tasksplanned,
	(SELECT COUNT	(*)::int4	FROM "tasks_task" WHERE	tasks_task."company_id" = companies_company."id" AND "is_active" = true AND "end_date" BETWEEN _starttimestamp AND _endtimestamp AND status <> 'todo') AS tasksexec,
	(SELECT COUNT	(*)::int4	FROM "tasks_task" WHERE	tasks_task."company_id" = companies_company."id" AND "is_active" = true AND "due_at" BETWEEN _starttimestamp AND _endtimestamp AND status <> 'todo') AS tasksexecperc,
	(SELECT COUNT	(*)::int4	FROM "checklists_checklist" WHERE	checklists_checklist."company_id" = companies_company."id" AND checklists_checklist."is_active" = true AND checklists_checklist."signed_at_1" BETWEEN _starttimestamp AND _endtimestamp) AS checklistexec,
	(SELECT COUNT	(*)::int4	FROM audits_audit WHERE	audits_audit.company_id = companies_company."id" AND audits_audit.is_active = true AND audits_audit.signed_at_1 BETWEEN _starttimestamp AND _endtimestamp) AS auditsexec, 
	(SELECT COUNT	(*)::int4	FROM actions_action WHERE	actions_action.company_id = companies_company."id" AND actions_action.is_active = true AND actions_action.created_at BETWEEN _starttimestamp AND _endtimestamp) AS newactions,
	(SELECT COUNT (*)::int4 FROM comments WHERE comments.company_id = companies_company."id" and comments.is_active = true AND comments.created_at BETWEEN _starttimestamp AND _endtimestamp) AS newcomments,
	(SELECT COUNT (*)::int4 FROM factoryfeed_messages WHERE factoryfeed_messages.company_id = companies_company."id" AND factoryfeed_messages.is_active = true and factoryfeed_messages.created_at BETWEEN _starttimestamp AND _endtimestamp) AS newfeedmessages 
FROM
	companies_company 
WHERE
	companies_company."name" NOT ILIKE '%test%' 
	AND companies_company."name" NOT ILIKE '%demo%' 
	AND companies_company."name" NOT ILIKE '%poc%' 
	AND companies_company."name" NOT ILIKE '%training' 
	AND companies_company."name" NOT ILIKE '%demcomp%' 
	AND companies_company."name" NOT ILIKE '%devcompany%' 
	AND companies_company."name" NOT ILIKE '%try out%' 
	AND companies_company."name" NOT ILIKE 'Johnson & Johnson' 
  AND companies_company."name" NOT ILIKE 'Villa Anna' 
  AND companies_company."name" NOT ILIKE 'Helnessund Brygger AS'	
	AND companies_company."name" NOT ILIKE 'Visual Workplace' 
	AND companies_company."name" NOT ILIKE 'Yellow Chips Emmeloord'
	AND companies_company."name" NOT ILIKE 'CareB4'	
	AND companies_company."name" NOT ILIKE 'EZ Factory Management'
	AND companies_company.is_active = true;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_task_audit_properties_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_task_audit_properties_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_task_audit_properties_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("AuditTemplateId" int4, "AuditTemplateName" varchar, "AuditId" int4, "TaskTemplateId" int4, "TaskTemplateName" varchar, "TaskId" int4, "AreaId" int4, "AreaName" varchar, "RegisteredBy" varchar, "RegisteredAt" timestamp, "RegisteredAtDate" date, "RegisteredAtTime" varchar, "RegisteredAtDayOfWeek" varchar, "RegisteredAtWeekNr" int4, "RegisteredAtYear" int4, "PropertyName" varchar, "DisplayPropertyTitle" varchar, "DisplayPropertyValueType" varchar, "PropertyValueKind" varchar, "PropertyValueName" varchar, "PropertyValueSymbol" varchar, "DefaultPrimaryValue" text, "DefaultSecondaryValue" text, "Value" text) AS $BODY$
DECLARE
	_timezone varchar;
BEGIN
	SELECT get_timezone_with_company(_companyid) INTO _timezone;
	RETURN QUERY
	SELECT
  CCTT.id AS AuditTemplateId,
	CCTT.name AS AuditTemplateName,
	CC.id AS AuditId,
	TTT.id AS TaskTemplateId,
	TTT.name AS TaskTemplateName,
	PP.task_id AS TaskId,
	CCTT.area_id AS AreaId,
	CA.Name AS AreaName,
	CONCAT(PU.first_name, ' ', PU.last_name)::varchar AS RegisteredBy,
	timezone(_timezone, CC.signed_at_1::timestamp)::timestamp AS RegisteredAt,
	timezone(_timezone, CC.signed_at_1::timestamp)::date AS RegisteredAtDate,
	TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamp), 'HH24:MI')::varchar AS RegisteredAtTime,
	TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamp), 'Day')::varchar AS RegisteredAtDayOfWeek,
	TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamp), 'IW')::int AS RegisteredAtWeekNr,
	TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamp), 'YYYY')::int AS RegisteredAtYear,
	P.name AS PropertyName,
	TTP.custom_title_display AS DisplayPropertyTitle,
	TTP.custom_value_type_display AS DisplayPropertyValueType,
	PVK.name AS PropertyValueKind,
	PV.name AS PropertyValueName,
	PV.value_symbol AS PropertyValueSymbol,
	CASE
	WHEN TTP.primary_int_value IS NOT NULL THEN
		TTP.primary_int_value::text
	WHEN TTP.primary_int_value IS NOT NULL THEN
		TTP.primary_int_value::text
	WHEN TTP.primary_decimal_value IS NOT NULL THEN
		TTP.primary_decimal_value::text
	WHEN TTP.primary_datetime_value IS NOT NULL THEN
		TTP.primary_datetime_value::text
	WHEN TTP.primary_time_value IS NOT NULL THEN
		TTP.primary_time_value::text
	WHEN TTP.primary_string_value IS NOT NULL THEN
		TTP.primary_string_value::text
  ELSE
		''::text
	END AS DefaultPrimaryValue,
	CASE
	WHEN TTP.secondary_int_value IS NOT NULL THEN
		TTP.secondary_int_value::text
	WHEN TTP.secondary_int_value IS NOT NULL THEN
		TTP.secondary_int_value::text
	WHEN TTP.secondary_decimal_value IS NOT NULL THEN
		TTP.secondary_decimal_value::text
	WHEN TTP.secondary_datetime_value IS NOT NULL THEN
		TTP.secondary_datetime_value::text
	WHEN TTP.secondary_time_value IS NOT NULL THEN
		TTP.secondary_time_value::text
	WHEN TTP.secondary_string_value IS NOT NULL THEN
		TTP.secondary_string_value::text
  ELSE
		''::text
	END AS DefaultSecondaryValue,
	CASE
	WHEN PP.value_int IS NOT NULL THEN
		PP.value_int::text
	WHEN PP.value_decimal IS NOT NULL THEN
		PP.value_decimal::text
	WHEN PP.value_time IS NOT NULL THEN
		PP.value_time::text
	WHEN PP.value_date IS NOT NULL THEN
		PP.value_date::text
	WHEN PP.value_bool IS NOT NULL THEN
		PP.value_bool::text
	WHEN PP.value_string IS NOT NULL THEN
		PP.value_string::text
	ELSE
		''::text
	END AS "Value"
	FROM tasks_properties PP
	INNER JOIN tasks_task TT ON TT.id = PP.task_id AND TT.company_id = _companyid AND TT.is_active = true
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.company_id = _companyid AND TTT.is_active = true AND TTT.type = 'audit'
	INNER JOIN audits_audit_tasks CCT ON CCT.task_id = TT.id
	INNER JOIN audits_audit CC ON CC.id = CCT.audit_id AND CC.company_id = _companyid
	INNER JOIN audits_audittemplate CCTT ON CCTT.id = CC.template_id AND CCTT.company_id = _companyid
	INNER JOIN properties P ON P.id = PP.property_id
	INNER JOIN tasks_tasktemplate_properties TTP ON TTP.id = PP.template_property_id AND TTP.company_id = _companyid
	LEFT JOIN propertyvalue PV ON PV.id = TTP.propertyvalue_id
	LEFT JOIN propertyvaluekind PVK ON PVK.id = P.propertyvaluekind_id
	LEFT JOIN profiles_user PU ON PU.id = PP.user_id AND PU.company_id = _companyid
	LEFT JOIN companies_area CA ON CA.id = CCTT.area_id AND CA.company_id = _companyid
  WHERE  ((CC.signed_at_1 >= _starttimestamp::timestamp) OR _starttimestamp IS NULL)
  AND ((CC.signed_at_1 <= _endtimestamp::timestamp) OR _endtimestamp IS NULL);
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_task_checklist_properties_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_task_checklist_properties_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_task_checklist_properties_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("ChecklistTemplateId" int4, "ChecklistTemplateName" varchar, "ChecklistId" int4, "TaskTemplateId" int4, "TaskTemplateName" varchar, "TaskId" int4, "AreaId" int4, "AreaName" varchar, "RegisteredBy" varchar, "RegisteredAt" timestamp, "RegisteredAtDate" date, "RegisteredAtTime" varchar, "RegisteredAtDayOfWeek" varchar, "RegisteredAtWeekNr" int4, "RegisteredAtYear" int4, "PropertyName" varchar, "DisplayPropertyTitle" varchar, "DisplayPropertyValueType" varchar, "PropertyValueKind" varchar, "PropertyValueName" varchar, "PropertyValueSymbol" varchar, "DefaultPrimaryValue" text, "DefaultSecondaryValue" text, "Value" text) AS $BODY$
DECLARE
	_timezone varchar;
BEGIN
	SELECT get_timezone_with_company(_companyid) INTO _timezone;
	RETURN QUERY
	SELECT
  CCTT.id AS ChecklistTemplateId,
	CCTT.name AS ChecklistTemplateName,
	CC.id AS ChecklistId,
	TTT.id AS TaskTemplateId,
	TTT.name AS TaskTemplateName,
	PP.task_id AS TaskId,
	CCTT.area_id AS AreaId,
	CA.Name AS AreaName,
	CONCAT(PU.first_name, ' ', PU.last_name)::varchar AS RegisteredBy,
	timezone(_timezone, CC.signed_at_1::timestamp)::timestamp AS RegisteredAt,
	timezone(_timezone, CC.signed_at_1::timestamp)::date AS RegisteredAtDate,
	TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamp), 'HH24:MI')::varchar AS RegisteredAtTime,
	TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamp), 'Day')::varchar AS RegisteredAtDayOfWeek,
	TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamp), 'IW')::int AS RegisteredAtWeekNr,
	TO_CHAR(timezone(_timezone, CC.signed_at_1::timestamp), 'YYYY')::int AS RegisteredAtYear,
	P.name AS PropertyName,
	TTP.custom_title_display AS DisplayPropertyTitle,
	TTP.custom_value_type_display AS DisplayPropertyValueType,
	PVK.name AS PropertyValueKind,
	PV.name AS PropertyValueName,
	PV.value_symbol AS PropertyValueSymbol,
	CASE
	WHEN TTP.primary_int_value IS NOT NULL THEN
		TTP.primary_int_value::text
	WHEN TTP.primary_int_value IS NOT NULL THEN
		TTP.primary_int_value::text
	WHEN TTP.primary_decimal_value IS NOT NULL THEN
		TTP.primary_decimal_value::text
	WHEN TTP.primary_datetime_value IS NOT NULL THEN
		TTP.primary_datetime_value::text
	WHEN TTP.primary_time_value IS NOT NULL THEN
		TTP.primary_time_value::text
	WHEN TTP.primary_string_value IS NOT NULL THEN
		TTP.primary_string_value::text
  ELSE
		''::text
	END AS DefaultPrimaryValue,
	CASE
	WHEN TTP.secondary_int_value IS NOT NULL THEN
		TTP.secondary_int_value::text
	WHEN TTP.secondary_int_value IS NOT NULL THEN
		TTP.secondary_int_value::text
	WHEN TTP.secondary_decimal_value IS NOT NULL THEN
		TTP.secondary_decimal_value::text
	WHEN TTP.secondary_datetime_value IS NOT NULL THEN
		TTP.secondary_datetime_value::text
	WHEN TTP.secondary_time_value IS NOT NULL THEN
		TTP.secondary_time_value::text
	WHEN TTP.secondary_string_value IS NOT NULL THEN
		TTP.secondary_string_value::text
  ELSE
		''::text
	END AS DefaultSecondaryValue,
	CASE
	WHEN PP.value_int IS NOT NULL THEN
		PP.value_int::text
	WHEN PP.value_decimal IS NOT NULL THEN
		PP.value_decimal::text
	WHEN PP.value_time IS NOT NULL THEN
		PP.value_time::text
	WHEN PP.value_date IS NOT NULL THEN
		PP.value_date::text
	WHEN PP.value_bool IS NOT NULL THEN
		PP.value_bool::text
	WHEN PP.value_string IS NOT NULL THEN
		PP.value_string::text
	ELSE
		''::text
	END AS "Value"
	FROM tasks_properties PP
	INNER JOIN tasks_task TT ON TT.id = PP.task_id AND TT.company_id = _companyid AND TT.is_active = true
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.company_id = _companyid AND TTT.is_active = true AND TTT.type = 'checklist'
	INNER JOIN checklists_checklist_tasks CCT ON CCT.task_id = TT.id
	INNER JOIN checklists_checklist CC ON CC.id = CCT.checklist_id AND CC.company_id = _companyid
	INNER JOIN checklists_checklisttemplate CCTT ON CCTT.id = CC.template_id AND CCTT.company_id = _companyid
	INNER JOIN properties P ON P.id = PP.property_id
	INNER JOIN tasks_tasktemplate_properties TTP ON TTP.id = PP.template_property_id AND TTP.company_id = _companyid
	LEFT JOIN propertyvalue PV ON PV.id = TTP.propertyvalue_id
	LEFT JOIN propertyvaluekind PVK ON PVK.id = P.propertyvaluekind_id
	LEFT JOIN profiles_user PU ON PU.id = PP.user_id AND PU.company_id = _companyid
	LEFT JOIN companies_area CA ON CA.id = CCTT.area_id AND CA.company_id = _companyid
  WHERE  ((CC.signed_at_1 >= _starttimestamp::timestamp) OR _starttimestamp IS NULL)
  AND ((CC.signed_at_1 <= _endtimestamp::timestamp) OR _endtimestamp IS NULL);
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_task_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_task_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_task_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("TaskTemplateId" int4, "TaskName" varchar, "AreaId" int4, "AreaName" varchar, "Status" varchar, "RecurrencyType" varchar, "CompletedBy" varchar, "CompletedAt" timestamp, "CompletedAtDate" date, "CompletedAtTime" varchar, "CompletedAtDayOfWeek" varchar, "CompletedAtShiftDay" varchar, "CompletedAtShiftNr" int4, "CompletedAtWeekNr" int4, "CompletedAtYear" int4, "DueDate" timestamp, "DueDateDate" date, "DueDateTime" varchar, "DueDateDay" varchar, "DueDateShiftDay" varchar, "DueDateShiftNr" int4, "DueDateWeekNr" int4, "DueDateYear" int4, "planned_time" int4, "RealizedTime" int4) AS $BODY$
DECLARE 
	_timezone varchar;
BEGIN
	SELECT get_timezone_with_company(_companyid) INTO _timezone;
	RETURN QUERY
	SELECT 
	TTT.id AS TaskTemplateId,
	TTT.name AS TaskName, 
	CASE WHEN TTT.area_id IS NULL THEN
		TTR.area_id
	ELSE 
		TTT.area_id
	END::int AS AreaId,
	CASE WHEN TTT.area_id IS NULL THEN
		CA.Name
	ELSE 
		CA2.Name
	END AS AreaName,
	TT.status AS Status,
	TTR.type AS RecurrencyType,
	(CONCAT(PU.first_name, ' ', PU.last_name))::varchar AS CompletedBy,
	timezone(_timezone, TT.signed_at::timestamp)::timestamp AS CompletedAt,
	timezone(_timezone, TT.signed_at::timestamp)::date AS CompletedAtDate,
	TO_CHAR(timezone(_timezone, TT.signed_at::timestamp), 'HH24:MI')::varchar AS CompletedAtTime,
	TO_CHAR(timezone(_timezone, TT.signed_at::timestamp), 'Day')::varchar AS CompletedAtDayOfWeek,
	EXTRACT(ISODOW from (timezone(_timezone, TT.signed_at::timestamp)::date))::varchar AS CompletedAtShiftDay,
	CASE WHEN TT.signed_at IS NOT NULL THEN
		S.shiftnr
	ELSE
		NULL
	END AS CompletedAtShiftNr,
	TO_CHAR(timezone(_timezone, TT.signed_at::timestamp), 'IW')::int AS CompletedAtWeekNr,
	TO_CHAR(timezone(_timezone, TT.signed_at::timestamp), 'YYYY')::int AS CompletedAtYear,
	TT.due_at::timestamp AS DueDate,
	TT.start_at::date AS DueDateDate, -- based actual day (tasks belong to)
	TO_CHAR(TT.due_at, 'HH24:MI')::varchar AS DueDateTime, -- time of the 'real' due at
	TO_CHAR(TT.start_at, 'Day')::varchar AS DueDateDay, -- based actual day (tasks belong to)
	EXTRACT(ISODOW from (TT.start_at::date))::varchar AS DueDateShiftDay,
	CASE WHEN TT.due_at IS NOT NULL THEN
		S.shiftnr
	ELSE
		NULL
	END AS DueDateShiftNr,
	TO_CHAR(TT.due_at, 'IW')::int AS DueDateWeekNr,
	TO_CHAR(TT.due_at, 'YYYY')::int AS DueDateYear,
	TTT.planned_time AS PlannedTime,
	TT.time_taken AS RealizedTime
	FROM tasks_task TT
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.type = 'task'
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	LEFT JOIN companies_area CA ON CA.id = TTR.area_id AND CA.company_id = _companyid
	LEFT JOIN companies_area CA2 ON CA2.id = TTT.area_id AND CA2.company_id = _companyid
	LEFT JOIN profiles_user PU ON TT.signed_by_id = PU.id AND PU.company_id = _companyid
	LEFT JOIN (	
							SELECT 
							CS."id", 
							(row_number() OVER (PARTITION BY CS.day, CS.area_id ORDER BY CS.day, CS.area_id DESC, CS.start))::int AS shiftnr	
							FROM companies_shift CS 
							WHERE CS.company_id = _companyid AND CS.is_active = true 
							ORDER BY CS.weekday, CS."start", CS."end"
						)
	AS S ON S.id = TT.shift_id
	--LEFT JOIN companies_area CA ON CA.id = TTR.area_id OR CA.id = TTT.area_id
	WHERE TTT.company_id = _companyid AND TT.company_id = _companyid AND TTR.company_id = _companyid
	AND TT.is_active = true
	--AND (TT.signed_at >= timezone(_timezone, _starttimestamp::timestamp) OR _starttimestamp IS NULL)
  --AND (TT.signed_at <= timezone(_timezone, _endtimestamp::timestamp) OR _endtimestamp IS NULL)
  AND ((TT.start_at >= _starttimestamp::timestamp) OR _starttimestamp IS NULL)
  AND ((TT.due_at <= _endtimestamp::timestamp) OR _endtimestamp IS NULL);
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_task_overview_custom
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_task_overview_custom"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_task_overview_custom"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("TaskTemplateId" int4, "TaskId" int4, "TaskName" varchar, "AreaId" int4, "AreaName" varchar, "AreaFullPath" varchar, "AreaFullPathIds" varchar, "Status" varchar, "RecurrencyType" varchar, "CompletedBy" varchar, "CompletedAt" timestamp, "CompletedAtDate" date, "CompletedAtTime" varchar, "CompletedAtDayOfWeek" varchar, "CompletedAtShiftDay" varchar, "CompletedAtShiftNr" int4, "CompletedAtWeekNr" int4, "CompletedAtYear" int4, "DueDate" timestamp, "DueDateDate" date, "DueDateTime" varchar, "DueDateDay" varchar, "DueDateShiftDay" varchar, "DueDateShiftNr" int4, "DueDateWeekNr" int4, "DueDateYear" int4, "planned_time" int4, "RealizedTime" int4) AS $BODY$
DECLARE 
	_timezone varchar;
BEGIN
	SELECT get_timezone_with_company(_companyid) INTO _timezone;
	RETURN QUERY
	SELECT 
	TTT.id AS TaskTemplateId,
	TT.id AS TaskId,
	TTT.name AS TaskName, 
	CASE WHEN TTT.area_id IS NULL THEN
		TTR.area_id
	ELSE 
		TTT.area_id
	END::int AS AreaId,
	CASE WHEN TTT.area_id IS NULL THEN
		CA.Name
	ELSE 
		CA2.Name
	END AS AreaName,
	CASE WHEN TTT.area_id IS NULL THEN
		get_area_full_path(TTR.area_id)
	ELSE 
		get_area_full_path(TTT.area_id)
	END::varchar AS AreaFullPath,
	CASE WHEN TTT.area_id IS NULL THEN
		get_area_full_path_ids(TTR.area_id)
	ELSE 
		get_area_full_path_ids(TTT.area_id)
	END::varchar AS AreaFullPathIds,
	TT.status AS Status,
	TTR.type AS RecurrencyType,
	(CONCAT(PU.first_name, ' ', PU.last_name))::varchar AS CompletedBy,
	timezone(_timezone, TT.signed_at::timestamp)::timestamp AS CompletedAt,
	timezone(_timezone, TT.signed_at::timestamp)::date AS CompletedAtDate,
	TO_CHAR(timezone(_timezone, TT.signed_at::timestamp), 'HH24:MI')::varchar AS CompletedAtTime,
	TO_CHAR(timezone(_timezone, TT.signed_at::timestamp), 'Day')::varchar AS CompletedAtDayOfWeek,
	EXTRACT(ISODOW from (timezone(_timezone, TT.signed_at::timestamp)::date))::varchar AS CompletedAtShiftDay,
	CASE WHEN TT.signed_at IS NOT NULL THEN
		S.shiftnr
	ELSE
		NULL
	END AS CompletedAtShiftNr,
	TO_CHAR(timezone(_timezone, TT.signed_at::timestamp), 'IW')::int AS CompletedAtWeekNr,
	TO_CHAR(timezone(_timezone, TT.signed_at::timestamp), 'YYYY')::int AS CompletedAtYear,
	TT.due_at::timestamp AS DueDate,
	TT.start_at::date AS DueDateDate, -- based actual day (tasks belong to)
	TO_CHAR(TT.due_at, 'HH24:MI')::varchar AS DueDateTime, -- time of the 'real' due at
	TO_CHAR(TT.start_at, 'Day')::varchar AS DueDateDay, -- based actual day (tasks belong to)
	EXTRACT(ISODOW from (TT.start_at::date))::varchar AS DueDateShiftDay,
	CASE WHEN TT.due_at IS NOT NULL THEN
		S.shiftnr
	ELSE
		NULL
	END AS DueDateShiftNr,
	TO_CHAR(TT.due_at, 'IW')::int AS DueDateWeekNr,
	TO_CHAR(TT.due_at, 'YYYY')::int AS DueDateYear,
	TTT.planned_time AS PlannedTime,
	TT.time_taken AS RealizedTime
	FROM tasks_task TT
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.type = 'task'
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	LEFT JOIN companies_area CA ON CA.id = TTR.area_id AND CA.company_id = _companyid
	LEFT JOIN companies_area CA2 ON CA2.id = TTT.area_id AND CA2.company_id = _companyid
	LEFT JOIN profiles_user PU ON TT.signed_by_id = PU.id AND PU.company_id = _companyid
	LEFT JOIN (	
							SELECT 
							CS."id", 
							(row_number() OVER (PARTITION BY CS.day, CS.area_id ORDER BY CS.day, CS.area_id DESC, CS.start))::int AS shiftnr	
							FROM companies_shift CS 
							WHERE CS.company_id = _companyid AND CS.is_active = true 
							ORDER BY CS.weekday, CS."start", CS."end"
						)
	AS S ON S.id = TT.shift_id
	--LEFT JOIN companies_area CA ON CA.id = TTR.area_id OR CA.id = TTT.area_id
	WHERE TTT.company_id = _companyid AND TT.company_id = _companyid AND TTR.company_id = _companyid
	AND TT.is_active = true
	--AND (TT.signed_at >= timezone(_timezone, _starttimestamp::timestamp) OR _starttimestamp IS NULL)
  --AND (TT.signed_at <= timezone(_timezone, _endtimestamp::timestamp) OR _endtimestamp IS NULL)
  AND ((TT.start_at >= _starttimestamp::timestamp) OR _starttimestamp IS NULL)
  AND ((TT.due_at <= _endtimestamp::timestamp) OR _endtimestamp IS NULL);
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_task_properties_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_task_properties_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_task_properties_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("TaskTemplateId" int4, "TaskTemplateName" varchar, "TaskId" int4, "AreaId" int4, "AreaName" varchar, "RegisteredBy" varchar, "RegisteredAt" timestamp, "RegisteredAtDate" date, "RegisteredAtTime" varchar, "RegisteredAtDayOfWeek" varchar, "RegisteredAtShiftDay" varchar, "RegisteredAtShiftNr" int4, "RegisteredAtWeekNr" int4, "RegisteredAtYear" int4, "PropertyName" varchar, "DisplayPropertyTitle" varchar, "DisplayPropertyValueType" varchar, "PropertyValueKind" varchar, "PropertyValueName" varchar, "PropertyValueSymbol" varchar, "DefaultPrimaryValue" text, "DefaultSecondaryValue" text, "Value" text) AS $BODY$
DECLARE
	_timezone varchar;
BEGIN
	SELECT get_timezone_with_company(_companyid) INTO _timezone;
	RETURN QUERY
	SELECT
		TTT.id AS TaskTemplateId,
	TTT.name AS TaskTemplateName,
	PP.task_id AS TaskId,

	CASE WHEN TTT.area_id IS NULL THEN
		TTR.area_id
	ELSE
		TTT.area_id
	END::int AS AreaId,
	CASE WHEN TTT.area_id IS NULL THEN
		CA.Name
	ELSE
		CA2.Name
	END AS AreaName,
	CONCAT(PU.first_name, ' ', PU.last_name)::varchar AS RegisteredBy,
	timezone(_timezone, TT.signed_at::timestamp)::timestamp AS RegisteredAt,
	timezone(_timezone, TT.signed_at::timestamp)::date AS RegisteredAtDate,
	TO_CHAR(timezone(_timezone, TT.signed_at::timestamp), 'HH24:MI')::varchar AS RegisteredAtTime,
	TO_CHAR(timezone(_timezone, TT.signed_at::timestamp), 'Day')::varchar AS RegisteredAtDayOfWeek,
	EXTRACT(ISODOW from (timezone(_timezone, TT.signed_at::timestamp)::date))::varchar AS RegisteredAtShiftDay,
	CASE WHEN TT.signed_at IS NOT NULL THEN
		S.shiftnr
	ELSE
		NULL
	END AS RegisteredAtShiftNr,
	TO_CHAR(timezone(_timezone, TT.signed_at::timestamp), 'IW')::int AS RegisteredAtWeekNr,
	TO_CHAR(timezone(_timezone, TT.signed_at::timestamp), 'YYYY')::int AS RegisteredAtYear,
	P.name AS PropertyName,
	TTP.custom_title_display AS DisplayPropertyTitle,
	TTP.custom_value_type_display AS DisplayPropertyValueType,
	PVK.name AS PropertyValueKind,
	PV.name AS PropertyValueName,
	PV.value_symbol AS PropertyValueSymbol,
	CASE
	WHEN TTP.primary_int_value IS NOT NULL THEN
		TTP.primary_int_value::text
	WHEN TTP.primary_int_value IS NOT NULL THEN
		TTP.primary_int_value::text
	WHEN TTP.primary_decimal_value IS NOT NULL THEN
		TTP.primary_decimal_value::text
	WHEN TTP.primary_datetime_value IS NOT NULL THEN
		TTP.primary_datetime_value::text
	WHEN TTP.primary_time_value IS NOT NULL THEN
		TTP.primary_time_value::text
	WHEN TTP.primary_string_value IS NOT NULL THEN
		TTP.primary_string_value::text
  ELSE
		''::text
	END AS DefaultPrimaryValue,
	CASE
	WHEN TTP.secondary_int_value IS NOT NULL THEN
		TTP.secondary_int_value::text
	WHEN TTP.secondary_int_value IS NOT NULL THEN
		TTP.secondary_int_value::text
	WHEN TTP.secondary_decimal_value IS NOT NULL THEN
		TTP.secondary_decimal_value::text
	WHEN TTP.secondary_datetime_value IS NOT NULL THEN
		TTP.secondary_datetime_value::text
	WHEN TTP.secondary_time_value IS NOT NULL THEN
		TTP.secondary_time_value::text
	WHEN TTP.secondary_string_value IS NOT NULL THEN
		TTP.secondary_string_value::text
  ELSE
		''::text
	END AS DefaultSecondaryValue,
	CASE
	WHEN PP.value_int IS NOT NULL THEN
		PP.value_int::text
	WHEN PP.value_decimal IS NOT NULL THEN
		PP.value_decimal::text
	WHEN PP.value_time IS NOT NULL THEN
		PP.value_time::text
	WHEN PP.value_date IS NOT NULL THEN
		PP.value_date::text
	WHEN PP.value_bool IS NOT NULL THEN
		PP.value_bool::text
	WHEN PP.value_string IS NOT NULL THEN
		PP.value_string::text
	ELSE
		''::text
	END AS "Value"
	FROM tasks_properties PP
	INNER JOIN tasks_task TT ON TT.id = PP.task_id AND TT.company_id = _companyid AND TT.is_active = true
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.company_id = _companyid AND TTT.is_active = true AND TTT.type = 'task'
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.company_id = _companyid
	INNER JOIN properties P ON P.id = PP.property_id
	INNER JOIN tasks_tasktemplate_properties TTP ON TTP.id = PP.template_property_id AND TTP.company_id = _companyid
	LEFT JOIN propertyvalue PV ON PV.id = TTP.propertyvalue_id
	LEFT JOIN propertyvaluekind PVK ON PVK.id = P.propertyvaluekind_id
	LEFT JOIN profiles_user PU ON PU.id = PP.user_id AND PU.company_id = _companyid
	LEFT JOIN companies_area CA ON CA.id = TTR.area_id AND CA.company_id = _companyid
	LEFT JOIN companies_area CA2 ON CA2.id = TTT.area_id AND CA2.company_id = _companyid
	LEFT JOIN (
							SELECT
							CS."id",
							(row_number() OVER (PARTITION BY CS.day, CS.area_id ORDER BY CS.day, CS.area_id DESC, CS.start))::int AS shiftnr
							FROM companies_shift CS
							WHERE CS.company_id = _companyid AND CS.is_active = true
							ORDER BY CS.weekday, CS."start", CS."end"
						)
	AS S ON S.id = TT.shift_id
  WHERE  ((TT.start_at >= _starttimestamp::timestamp) OR _starttimestamp IS NULL)
  AND ((TT.due_at <= _endtimestamp::timestamp) OR _endtimestamp IS NULL);
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_tasktemplate_nonshifts_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_tasktemplate_nonshifts_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_tasktemplate_nonshifts_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("TaakID" varchar, "TaakTitel" varchar, "AreaID" varchar, "AreaName" text, "RecurrenceType" varchar, "RecurEveryWeekOrMonth" varchar, "Specific" varchar, "DayNumber" varchar, "WeekNumber" varchar, "Ma" varchar, "Di" varchar, "Wo" varchar, "Do" varchar, "Vr" varchar, "Za" varchar, "Zo" varchar, "StartDate" varchar, "EndDate" varchar, "PlannedTime" varchar, "MachineStatus" varchar) AS $BODY$BEGIN
	RETURN QUERY
	/*
		•	TaakID
		•	TaakTitel
		•	AreaID
		•	AreaNaam
		•	RecurrenceType (once, shifts, weeks, months)
		•	En daarna afhankelijk van recurrencetype nog deze exta info in kolommen:
		o	Indien Weekly
					Kol 1: Om de hoeveel weken (wat nu ingevuld is in portal bij “recur every X weeks”)
					Kol 5 t/m 11: Een 1 in de kolom als die weekdag (ma – vr) is aangevinkt: meerdere vinkjes mogelijk dus 1 tot 7 kolommen gevuld met een 1
		o	Indien Monthly
					Kol 1: Om de hoeveel maanden
					Kol 2: Type: specific date of specific week
					Kol 3: Indien specific date: welke maanddag dan (getal 1-31)
					Kol 4: Indien specific week: hoeveelste week (getal 1-4)
					Kol 5 t/m 11: Indien specific week: Een 1 in de kolom van de specifieke weekdag die gekozen is (hier is maar 1 weekdag mogelijk)
	*/		
		SELECT 
		tt.id::varchar AS TaakID, -- TaakTemplateID 
		tt.name AS TaakTitel, -- TaakTitel
		--t.id AS TaskId, -- TaakID
		ca.id::varchar AS AreaID, -- AreaId
		--ca.name AS AreaNaam, -- AreaName
		get_task_area_full(ca.id) AS AreaName,
		ttr.type AS RecurrenceType, -- RecurrenceType
		
		CASE WHEN ttr.type = 'month' THEN ttr.month
				 WHEN ttr.type = 'week' THEN ttr.week
				 ELSE NULL
	  END::varchar AS RecurEveryWeekOrMonth, -- Om de hoeveel weken (wat nu ingevuld is in portal bij “recur every X weeks”) / Om de hoeveel maanden
		
		--	En daarna afhankelijk van recurrencetype nog deze exta info in kolommen:
		
		CASE WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' THEN 'Specific Week'
				 WHEN ttr.type = 'month' AND ttr.month_recurrency = 'day_of_month' THEN 'Specific Date'
				 ELSE NULL
	  END::varchar AS Specific, -- Type: specific date of specific week
		
		CASE WHEN ttr.type = 'month' AND ttr.month_recurrency = 'day_of_month' THEN ttr.day
				 ELSE NULL
	  END::varchar AS DayNumber, -- Indien specific date: welke maanddag dan (getal 1-31)
		
		CASE WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND ttr.weekday_number IS NULL THEN 1
				 WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND ttr.weekday_number IS NOT NULL THEN ttr.weekday_number
				 --WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' THEN ttr.week
				 ELSE NULL
	  END::varchar AS WeekNumber, -- Indien specific week: hoeveelste week (getal 1-4)
		
		-- Indien Weekly Een 1 in de kolom als die weekdag (ma – vr) is aangevinkt: meerdere vinkjes mogelijk dus 1 tot 7 kolommen gevuld met een 1
		-- Indien Monthly En Indien specific week: Een 1 in de kolom van de specifieke weekdag die gekozen is (hier is maar 1 weekdag mogelijk)
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday1 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 2 THEN 1
		WHEN ttr.type = 'week' AND weekday1 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday1 AND weekday = 2 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END::varchar AS Ma, 
		
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday2 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 3 THEN 1
		WHEN ttr.type = 'week' AND weekday2 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday2 AND weekday = 3 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END::varchar AS Di,
		
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday3 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 4 THEN 1
		WHEN ttr.type = 'week' AND weekday3 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday3 AND weekday = 4 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END::varchar AS Wo,
		
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday4 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 5 THEN 1
		WHEN ttr.type = 'week' AND weekday4 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday4 AND weekday = 5 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END::varchar AS Do,
		
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday5 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 6 THEN 1
		WHEN ttr.type = 'week' AND weekday5 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday5 AND weekday = 6 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END::varchar AS Vr,
		
		CASE 	
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday6 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 7 THEN 1
		WHEN ttr.type = 'week' AND weekday6 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday6 AND weekday = 7 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END::varchar AS Za,
		
		CASE 		
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday0 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 1 THEN 1
		WHEN ttr.type = 'week' AND weekday0 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday0 AND weekday = 1 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END::varchar AS Zo,
		-- possible start and end dates.
		CASE 
		WHEN ttr.type = 'month' OR ttr.type = 'week' THEN to_char(ttr.start_date, 'DD-MM-YYYY')::varchar 
		ELSE '' 
		END AS StartDate,
		CASE WHEN ttr.type = 'month' OR ttr.type = 'week' THEN 
		to_char(ttr.end_date, 'DD-MM-YYYY')::varchar 
		ELSE '' 
		END::varchar AS EndDate,
		tt.planned_time::varchar AS PlannedTime,
		tt.machine_status AS MachineStatus
	FROM tasks_tasktemplate tt 
	LEFT JOIN tasks_taskrecurrency ttr ON ttr.template_id = tt.id and ttr.company_id = _companyid
	LEFT JOIN companies_area ca ON ca.id = ttr.area_id and ca.company_id = _companyid
	WHERE tt.company_id = _companyid
	AND tt.type = 'task' AND ttr.type <> 'shifts' AND tt.is_active = true;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_tasktemplate_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_tasktemplate_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_tasktemplate_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("TaakID" varchar, "TaakTitel" varchar, "AreaID" varchar, "AreaName" text, "RecurrenceType" varchar, "RecurEveryWeekOrMonth" varchar, "Specific" varchar, "DayNumber" varchar, "WeekNumber" varchar, "Ma" varchar, "Di" varchar, "Wo" varchar, "Do" varchar, "Vr" varchar, "Za" varchar, "Zo" varchar, "StartDate" varchar, "EndDate" varchar, "PlannedTime" varchar, "MachineStatus" varchar) AS $BODY$BEGIN
	RETURN QUERY
	/*
		•	TaakID
		•	TaakTitel
		•	AreaID
		•	AreaNaam
		•	RecurrenceType (once, shifts, weeks, months)
		•	En daarna afhankelijk van recurrencetype nog deze exta info in kolommen:
		o	Indien Weekly
					Kol 1: Om de hoeveel weken (wat nu ingevuld is in portal bij “recur every X weeks”)
					Kol 5 t/m 11: Een 1 in de kolom als die weekdag (ma – vr) is aangevinkt: meerdere vinkjes mogelijk dus 1 tot 7 kolommen gevuld met een 1
		o	Indien Monthly
					Kol 1: Om de hoeveel maanden
					Kol 2: Type: specific date of specific week
					Kol 3: Indien specific date: welke maanddag dan (getal 1-31)
					Kol 4: Indien specific week: hoeveelste week (getal 1-4)
					Kol 5 t/m 11: Indien specific week: Een 1 in de kolom van de specifieke weekdag die gekozen is (hier is maar 1 weekdag mogelijk)
	*/		
		SELECT 
		tt.id::varchar AS TaakID, -- TaakTemplateID 
		tt.name AS TaakTitel, -- TaakTitel
		--t.id AS TaskId, -- TaakID
		ca.id::varchar AS AreaID, -- AreaId
		--ca.name AS AreaNaam, -- AreaName
		get_task_area_full(ca.id) AS AreaName,
		ttr.type AS RecurrenceType, -- RecurrenceType
		
		CASE WHEN ttr.type = 'month' THEN ttr.month
				 WHEN ttr.type = 'week' THEN ttr.week
				 ELSE NULL
	  END::varchar AS RecurEveryWeekOrMonth, -- Om de hoeveel weken (wat nu ingevuld is in portal bij “recur every X weeks”) / Om de hoeveel maanden
		
		--	En daarna afhankelijk van recurrencetype nog deze exta info in kolommen:
		
		CASE WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' THEN 'Specific Week'
				 WHEN ttr.type = 'month' AND ttr.month_recurrency = 'day_of_month' THEN 'Specific Date'
				 ELSE NULL
	  END::varchar AS Specific, -- Type: specific date of specific week
		
		CASE WHEN ttr.type = 'month' AND ttr.month_recurrency = 'day_of_month' THEN ttr.day
				 ELSE NULL
	  END::varchar AS DayNumber, -- Indien specific date: welke maanddag dan (getal 1-31)
		
		CASE WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND ttr.weekday_number IS NULL THEN 1
				 WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND ttr.weekday_number IS NOT NULL THEN ttr.weekday_number
				 --WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' THEN ttr.week
				 ELSE NULL
	  END::varchar AS WeekNumber, -- Indien specific week: hoeveelste week (getal 1-4)
		
		-- Indien Weekly Een 1 in de kolom als die weekdag (ma – vr) is aangevinkt: meerdere vinkjes mogelijk dus 1 tot 7 kolommen gevuld met een 1
		-- Indien Monthly En Indien specific week: Een 1 in de kolom van de specifieke weekdag die gekozen is (hier is maar 1 weekdag mogelijk)
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday1 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 2 THEN 1
		WHEN ttr.type = 'week' AND weekday1 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday1 AND weekday = 2 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END::varchar AS Ma, 
		
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday2 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 3 THEN 1
		WHEN ttr.type = 'week' AND weekday2 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday2 AND weekday = 3 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END::varchar AS Di,
		
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday3 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 4 THEN 1
		WHEN ttr.type = 'week' AND weekday3 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday3 AND weekday = 4 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END::varchar AS Wo,
		
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday4 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 5 THEN 1
		WHEN ttr.type = 'week' AND weekday4 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday4 AND weekday = 5 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END::varchar AS Do,
		
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday5 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 6 THEN 1
		WHEN ttr.type = 'week' AND weekday5 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday5 AND weekday = 6 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END::varchar AS Vr,
		
		CASE 	
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday6 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 7 THEN 1
		WHEN ttr.type = 'week' AND weekday6 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday6 AND weekday = 7 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END::varchar AS Za,
		
		CASE 		
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday0 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 1 THEN 1
		WHEN ttr.type = 'week' AND weekday0 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday0 AND weekday = 1 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END::varchar AS Zo,
		-- possible start and end dates.
		CASE 
		WHEN ttr.type = 'month' OR ttr.type = 'week' THEN to_char(ttr.start_date, 'DD-MM-YYYY')::varchar 
		ELSE '' 
		END AS StartDate,
		CASE WHEN ttr.type = 'month' OR ttr.type = 'week' THEN 
		to_char(ttr.end_date, 'DD-MM-YYYY')::varchar 
		ELSE '' 
		END::varchar AS EndDate,
		tt.planned_time::varchar AS PlannedTime,
		tt.machine_status AS MachineStatus
	FROM tasks_tasktemplate tt 
	LEFT JOIN tasks_taskrecurrency ttr ON ttr.template_id = tt.id and ttr.company_id = _companyid
	LEFT JOIN companies_area ca ON ca.id = ttr.area_id and ca.company_id = _companyid
	WHERE tt.company_id = _companyid
	AND tt.type = 'task' AND tt.is_active = true;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_data_tasktemplate_shiftsonly_overview
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_data_tasktemplate_shiftsonly_overview"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."export_data_tasktemplate_shiftsonly_overview"("_companyid" int4, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("TaakID" varchar, "TaakTitel" varchar, "AreaID" varchar, "AreaName" varchar, "RecurrenceType" varchar, "StartDate" varchar, "EndDate" varchar, "PlannedTime" varchar, "MachineStatus" varchar) AS $BODY$BEGIN
	RETURN QUERY
	/*
		•	TaakID
		•	TaakTitel
		•	AreaID
		•	AreaNaam
		•	RecurrenceType (once, shifts, weeks, months)
	*/		
		SELECT 
		tt.id::varchar AS TaakID, -- TaakTemplateID 
		tt.name::varchar AS TaakTitel, -- TaakTitel
		--t.id AS TaskId, -- TaakID
		ca.id::varchar AS AreaID, -- AreaId
		--ca.name AS AreaNaam, -- AreaName
		get_task_area_full(ca.id)::varchar AS AreaName,
		ttr.type AS RecurrenceType, -- RecurrenceType
		-- possible start and end dates.
		to_char(ttr.start_date, 'DD-MM-YYYY')::varchar AS StartDate,
		to_char(ttr.end_date, 'DD-MM-YYYY')::varchar AS EndDate,
		tt.planned_time::varchar AS PlannedTime,
		tt.machine_status AS MachineStatus
	FROM tasks_tasktemplate tt 
	LEFT JOIN tasks_taskrecurrency ttr ON ttr.template_id = tt.id and ttr.company_id = _companyid
	LEFT JOIN companies_area ca ON ca.id = ttr.area_id and ca.company_id = _companyid
	WHERE tt.company_id = _companyid
	AND tt.type = 'task' AND tt.is_active = true AND ttr.type = 'shifts';
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_language_resources
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_language_resources"();
CREATE OR REPLACE FUNCTION "public"."export_language_resources"()
  RETURNS TABLE("id" int4, "resource_key" varchar, "resource_guid" varchar, "description" text, "en_us" text, "en_gb" text, "nl_nl" text, "de_de" text, "fr_fr" text, "es_es" text, "pt_pt" text, "it_it" text, "el_gr" text, "nb_no" text, "fi_fi" text, "da_dk" text, "sv_se" text, "is_is" text, "pl_pl" text, "lt_lt" text, "lv_lv" text, "et_ee" text, "ro_ro" text, "bg_bg" text, "cs_cz" text, "hr_hr" text, "hu_hu" text, "hy_am" text, "ka_ge" text, "mk_mk" text, "sk_sk" text, "sl_si" text, "sq_al" text, "uk_ua" text, "af_za" text, "ar_sa" text, "he_il" text, "id_id" text, "ja_jp" text, "ko_kr" text, "ru_ru" text, "tr_tr" text, "zh_cn" text, "hi_in" text, "gd_gb" text, "ga_ie" text, "fy_nl" text, "my_mm" text, "vi_vn" text, "th_th" text, "lo_la" text, "ms_my" text, "ms_sg" text, "fil_ph" text, "bn_bd" text, "si_lk" text, "km_kh" text) AS $BODY$BEGIN
	RETURN QUERY
		SELECT L."id",L."resource_key",L."resource_guid",L."description",L."en_us",L."en_gb",L."nl_nl",L."de_de",L."fr_fr",L."es_es",L."pt_pt",L."it_it",L."el_gr",L."nb_no",L."fi_fi",
  L."da_dk",L."sv_se",L."is_is",L."pl_pl",L."lt_lt",L."lv_lv",L."et_ee",L."ro_ro",L."bg_bg" ,L."cs_cz" ,L."hr_hr" ,L."hu_hu" ,L."hy_am" ,L."ka_ge" ,L."mk_mk" ,L."sk_sk" ,L."sl_si" ,
  L."sq_al" ,L."uk_ua" ,L."af_za" ,L."ar_sa" ,L."he_il" ,L."id_id" ,L."ja_jp",L."ko_kr",L."ru_ru" ,L."tr_tr",L."zh_cn",L."hi_in",L."gd_gb",L."ga_ie",L."fy_nl",L."my_mm",L."vi_vn",
  L."th_th",L."lo_la",L."ms_my",L."ms_sg",L."fil_ph",L."bn_bd",L."si_lk",L."km_kh"
	FROM resource_languages L ORDER BY "id";
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for export_language_resources_update_queries
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."export_language_resources_update_queries"();
CREATE OR REPLACE FUNCTION "public"."export_language_resources_update_queries"()
  RETURNS TABLE("generated_query" text) AS $BODY$BEGIN
	RETURN QUERY
SELECT 
REPLACE(
	CONCAT(
	CONCAT('UPDATE resource_languages SET description = ''',REPLACE(description::varchar,'''' ,'''''' ), 
	''', en_us = ''',REPLACE(en_us::varchar,'''' ,'''''' ), 
	''', en_gb = ''',REPLACE(en_gb::varchar,'''' ,'''''' ), 
	''', nl_nl = ''',REPLACE(nl_nl::varchar,'''' ,'''''' ), 
	''', de_de = ''',REPLACE(de_de::varchar,'''' ,'''''' ), 
	''', fr_fr = ''',REPLACE(fr_fr::varchar,'''' ,'''''' ), 
	''', es_es = ''',REPLACE(es_es::varchar,'''' ,'''''' ), 
	''', pt_pt = ''',REPLACE(pt_pt::varchar,'''' ,'''''' ), 
	''', it_it = ''',REPLACE(it_it::varchar,'''' ,'''''' ), 
	''', el_gr = ''',REPLACE(el_gr::varchar,'''' ,'''''' ), 
	''', nb_no = ''',REPLACE(nb_no::varchar,'''' ,'''''' ),
	''', fi_fi = ''',REPLACE(fi_fi::varchar,'''' ,'''''' ), 
	''', da_dk = ''',REPLACE(da_dk::varchar,'''' ,'''''' ), 
	''', sv_se = ''',REPLACE(sv_se::varchar,'''' ,'''''' ), 
	''', is_is = ''',REPLACE(is_is::varchar,'''' ,'''''' ), 
	''', pl_pl = ''',REPLACE(pl_pl::varchar,'''' ,'''''' ), 
	''', lt_lt = ''',REPLACE(lt_lt::varchar,'''' ,'''''' ), 
	''', lv_lv = ''',REPLACE(lv_lv::varchar,'''' ,'''''' ), 
	''', et_ee = ''',REPLACE(et_ee::varchar,'''' ,'''''' ), 
	''', ro_ro = ''',REPLACE(ro_ro::varchar,'''' ,'''''' ), 
	''', bg_bg = ''',REPLACE(bg_bg::varchar,'''' ,'''''' ), 
	''', cs_cz = ''',REPLACE(cs_cz::varchar,'''' ,'''''' ), 
	''', hr_hr = ''',REPLACE(hr_hr::varchar,'''' ,'''''' ), 
	''', hu_hu = ''',REPLACE(hu_hu::varchar,'''' ,'''''' ), 
	''', hy_am = ''',REPLACE(hy_am::varchar,'''' ,'''''' ), 
	''', ka_ge = ''',REPLACE(ka_ge::varchar,'''' ,'''''' ), 
	''', mk_mk = ''',REPLACE(mk_mk::varchar,'''' ,'''''' )), 
	CONCAT(''', sk_sk = ''',REPLACE(sk_sk::varchar,'''' ,'''''' ), 
	''', sl_si = ''',REPLACE(sl_si::varchar,'''' ,'''''' ), 
	''', sq_al = ''',REPLACE(sq_al::varchar,'''' ,'''''' ), 
	''', uk_ua = ''',REPLACE(uk_ua::varchar,'''' ,'''''' ), 
	''', af_za = ''',REPLACE(af_za::varchar,'''' ,'''''' ), 
	''', ar_sa = ''',REPLACE(ar_sa::varchar,'''' ,'''''' ), 
	''', he_il = ''',REPLACE(he_il::varchar,'''' ,'''''' ), 
	''', id_id = ''',REPLACE(id_id::varchar,'''' ,'''''' ), 
	''', ja_jp = ''',REPLACE(ja_jp::varchar,'''' ,'''''' ), 
	''', ko_kr = ''',REPLACE(ko_kr::varchar,'''' ,'''''' ), 
	''', ru_ru = ''',REPLACE(ru_ru::varchar,'''' ,'''''' ), 
	''', tr_tr = ''',REPLACE(tr_tr::varchar,'''' ,'''''' ), 
	''', zh_cn = ''',REPLACE(zh_cn::varchar,'''' ,'''''' ), 
	''', hi_in = ''',REPLACE(hi_in::varchar,'''' ,'''''' ), 
	''', gd_gb = ''',REPLACE(gd_gb::varchar,'''' ,'''''' ), 
	''', ga_ie = ''',REPLACE(ga_ie::varchar,'''' ,'''''' ), 
	''', fy_nl = ''',REPLACE(fy_nl::varchar,'''' ,'''''' ), 
	''', my_mm = ''',REPLACE(my_mm::varchar,'''' ,'''''' ), 
	''', vi_vn = ''',REPLACE(vi_vn::varchar,'''' ,'''''' ), 
	''', th_th = ''',REPLACE(th_th::varchar,'''' ,'''''' ), 
	''', lo_la = ''',REPLACE(lo_la::varchar,'''' ,'''''' ), 
	''', ms_my = ''',REPLACE(ms_my::varchar,'''' ,'''''' ), 
	''', ms_sg = ''',REPLACE(ms_sg::varchar,'''' ,'''''' ), 
	''', fil_ph = ''',REPLACE(fil_ph::varchar,'''' ,''''''), 
	''', bn_bd = ''',REPLACE(bn_bd::varchar,'''' ,'''''' ), 
	''', si_lk = ''',REPLACE(si_lk::varchar,'''' ,'''''' ), 
	''', km_kh = ''',REPLACE(km_kh::varchar,'''' ,'''''' )), 
	''' WHERE id = ', "id",
	' AND resource_key = ''', "resource_key",
	''' AND resource_guid = ''', "resource_guid",
	''';')::text, '''''','NULL') AS generated_query
FROM resource_languages L
ORDER BY "id"
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for fix_reset_sequence
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."fix_reset_sequence"("_table_schema" text, "_tablename" text, "_columnname" text, "_sequence_name" text);
CREATE OR REPLACE FUNCTION "public"."fix_reset_sequence"("_table_schema" text, "_tablename" text, "_columnname" text, "_sequence_name" text)
  RETURNS "pg_catalog"."void" AS $BODY$
DECLARE
BEGIN
/*
Solution to out of sync sequences
See https://stackoverflow.com/questions/244243/how-to-reset-postgres-primary-key-sequence-when-it-falls-out-of-sync

When function is created use the following query to run. 
NOTE! USE AT OWN RISK
----------------------------------------------------------------
SELECT  fix_reset_sequence(table_schema, table_name, column_name, table_name || '_' || column_name || '_seq')
FROM information_schema.columns
WHERE column_default LIKE 'nextval%';
---------------------------------------------------------------
*/
 PERFORM 1
 FROM information_schema.sequences
 WHERE
  sequence_schema = _table_schema AND
  sequence_name = _sequence_name;
 IF FOUND THEN
  RAISE NOTICE 'Start: %','SELECT setval( ''' || _table_schema || '.' || _sequence_name  || ''', ' || '(SELECT MAX(' || _columnname || ') FROM ' || _table_schema || '.' || _tablename || ')' || '+1)';
	EXECUTE 'SELECT setval( ''' || _table_schema || '.' || _sequence_name  || ''', ' || '(SELECT MAX(' || _columnname || ') FROM ' || _table_schema || '.' || _tablename || ')' || '+1)';
	RAISE NOTICE 'End: %','SELECT setval( ''' || _table_schema || '.' || _sequence_name  || ''', ' || '(SELECT MAX(' || _columnname || ') FROM ' || _table_schema || '.' || _tablename || ')' || '+1)';
 ELSE
  RAISE WARNING 'SEQUENCE NOT UPDATED ON %.%', _tablename, _columnname;
 END IF;
END; 
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for generate_random_user_info
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."generate_random_user_info"();
CREATE OR REPLACE FUNCTION "public"."generate_random_user_info"()
  RETURNS TABLE("first_name" varchar, "last_name" varchar, "picture" varchar, "email" varchar, "sign" varchar, "username" varchar) AS $BODY$
	BEGIN
	 --Adding audit item and return the just created id to _audit_id variable 
	RETURN QUERY 
	SELECT T.first_name, T.last_name, T.picture, lower(concat(T.username,'@rnd.ezfactory.nl'))::varchar AS email, T.sign, T.username  FROM (
		SELECT 
		S.first_name::varchar, 
		S.last_name::varchar, 
		S.picture::varchar, 
		'media/tasks/31272/20823ea7-3160-4a52-a191-6a10310e67dd.png'::varchar AS sign, 
		lower(concat(S.first_name,'.',S.last_name, ROUND(random() * 1000)::varchar))::varchar AS username 
		FROM (
			SELECT 
				(SELECT x[ 1 + ( (random() * 9026)::int) % 95 ]
						FROM (		
							select '{Achelous,Acheron,Acis,Aegle,Aether,Alpheus,Alpheus,Amalthea,Amphitrite,Aphrodite,Apollo,Ares,Arethusa,Artemis,Asia,Asopus,Callirhoë,Castalia,Catillus,Cebren,Cephissus,Ceto,Chaos,Circe,Clymene,Creüsa,Crinaeae,Crinisus,Demeter,Dione,Dionysos,Doris,Eleionomae,Elektra,Enipeus,Erebus,Eros,Eurydice,Eurynome,Gaia,Galatea,Glaucus,Hades,Hebe,Hemera,Hephaistos,Hera,Hermes,Hestia,Inachus,Iris,Leucothea,Lilaea,Limnaden,Lotis,Lycorias,Lysithea,Melia,Meliboea,Melite,Merope,Nilus,Nomia,Nyx,Ouranos,Palaemon,Pallas,Pan,Panacea,Panopea,Pegaeae,Peneus,Periboea,Perseïs,Persephone,Pherusa,Philyra,Phorcys,Pleione,Poseidon,Potamiden,Proteus,Psamathe,Rhode,Skamandros,Sphinx,Tartaros,Telesto,Thalassa,Thetis,Thetys,Thoosa,Triton,Tyche,Zeus}'::text[]
						) AS z2(x)) AS first_name, 

				(SELECT x[ 1 + ( (random() * 9026)::int) % 95 ]
						FROM (		
							select '{Achelous,Acheron,Acis,Aegle,Aether,Alpheus,Alpheus,Amalthea,Amphitrite,Aphrodite,Apollo,Ares,Arethusa,Artemis,Asia,Asopus,Callirhoë,Castalia,Catillus,Cebren,Cephissus,Ceto,Chaos,Circe,Clymene,Creüsa,Crinaeae,Crinisus,Demeter,Dione,Dionysos,Doris,Eleionomae,Elektra,Enipeus,Erebus,Eros,Eurydice,Eurynome,Gaia,Galatea,Glaucus,Hades,Hebe,Hemera,Hephaistos,Hera,Hermes,Hestia,Inachus,Iris,Leucothea,Lilaea,Limnaden,Lotis,Lycorias,Lysithea,Melia,Meliboea,Melite,Merope,Nilus,Nomia,Nyx,Ouranos,Palaemon,Pallas,Pan,Panacea,Panopea,Pegaeae,Peneus,Periboea,Perseïs,Persephone,Pherusa,Philyra,Phorcys,Pleione,Poseidon,Potamiden,Proteus,Psamathe,Rhode,Skamandros,Sphinx,Tartaros,Telesto,Thalassa,Thetis,Thetys,Thoosa,Triton,Tyche,Zeus}'::text[]
						) AS z2(x)) AS last_name,
						
						(SELECT x[ 1 + ( (random() * 442)::int) % 21 ]
						FROM (		
							select '{media/steps/15169/54919422-f00c-4fd5-94a2-2ec940ec8cde.png,media/steps/15170/f2113068-ae1c-4240-8220-794986feff2c.png,media/steps/15171/15a223bc-b2ee-435e-8c5b-bb72c51fc951.png,media/steps/15172/b488af47-5942-4cd4-9fae-c2b5bde2b01f.png,media/steps/15173/3bc5fbc0-9ae7-4f9b-bb3e-4bdd9e36a5d6.png,media/steps/15174/4951a141-2133-468c-ad9d-dd51e9f48afe.png,media/steps/15175/0290f40f-d26b-42da-b827-a824095410ac.png,media/steps/15176/82c05f32-744f-499f-b868-ae034a286ac8.png,media/steps/15177/a535b17e-c62a-4a2a-90f6-927064b8d42c.png,media/steps/15178/519a1b2f-699c-4ea4-88b4-eef245f20615.png,media/steps/15179/30416968-108b-4a44-9ae4-7981b4a9b76d.png,media/steps/15180/9c5b3a35-73d4-4c23-a9fa-b0dce1efe56e.png,media/steps/15181/478452ee-4ecf-4e00-906d-85944a5d01dc.png,media/steps/15182/2451cd5e-42a4-44d1-9751-1e2d5451f7c8.png,media/steps/15183/314f91f3-59e2-4451-9216-ee4f964c3283.png,media/steps/15184/2499f30b-f6a1-4c7a-b4e7-998168b4af49.png,media/steps/15185/51fa8c0b-63b9-41a7-90e4-3d0cd88a4ff7.png,media/steps/15186/38ea0be2-5232-4a1a-9fe9-987fab8298ab.png,media/steps/15187/23304724-1c7d-49dd-ac8e-a7f22a900d5d.png,media/steps/15188/94a388a8-57db-47d9-9053-c55f990c809f.png,media/steps/15189/695c7aa9-4577-4cf3-843c-58e4c053d048.png}'::text[]
						) AS z2(x)) AS picture
			) AS S
		) AS T;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for generate_tasks_insertupdate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."generate_tasks_insertupdate"("_status" varchar, "_templateid" int4, "_companyid" int4, "_startdate" date, "_enddate" date, "_startat" timestamp, "_dueat" timestamp, "_recurrencyid" int4, "_shiftid" int4);
CREATE OR REPLACE FUNCTION "public"."generate_tasks_insertupdate"("_status" varchar, "_templateid" int4, "_companyid" int4, "_startdate" date, "_enddate" date, "_startat" timestamp, "_dueat" timestamp, "_recurrencyid" int4=NULL::integer, "_shiftid" int4=NULL::integer)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  _mutationcount integer;
BEGIN
	---
	--- NOTE! this stored procedure / function is part of the task generation tooling. Only use it for this purpose.
	--  The function will try to update a task (that is set to false, can be recycled as a new task). If there are no tasks to update, it will insert one. 
	---
   _mutationcount = 0;
	
		UPDATE tasks_task SET  
					 status = _status, 
					 template_id = _templateid, 
					 company_id = _companyid, 
					 recurrency_id = _recurrencyid, 
					 shift_id = _shiftid, 
					 modified_at = now()::timestamp, 
					 is_active = true, 
					 start_date = _startdate, 
					 end_date = _enddate, 
					 start_at = _startat,
					 due_at = _dueat
					 WHERE is_active = false AND template_id = _templateid AND company_id = _companyid AND id = 
								(SELECT id FROM tasks_task WHERE is_active = false AND template_id = _templateid AND company_id = _companyid AND signed_by_id IS NULL AND start_date > NOW()::date LIMIT 1); 
		GET DIAGNOSTICS _mutationcount = ROW_COUNT;

		IF _mutationcount = 0 THEN
			INSERT INTO tasks_task (id, status, template_id, company_id, recurrency_id, shift_id, created_at, modified_at, is_active, start_date, end_date, start_at, due_at) VALUES (
					DEFAULT, 
					_status,
					_templateid,
					_companyid,
					_recurrencyid,
					_shiftid,
					now()::timestamp,
					now()::timestamp,
					true,
					_startdate,
					_enddate,
					_startat,
					_dueat
				);
				GET DIAGNOSTICS _mutationcount = ROW_COUNT;
		END IF;
		
	 --RAISE NOTICE 'Mutation count %', _mutationcount;
	 RETURN _mutationcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for generate_tasks_monthly_by_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."generate_tasks_monthly_by_company"("_companyid" int4, "_templateid" int4);
CREATE OR REPLACE FUNCTION "public"."generate_tasks_monthly_by_company"("_companyid" int4, "_templateid" int4=0)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  _rowcount integer;
	_temprow record;
	_mutationcount integer;
	_rowtotalcount integer;
	_debug bool;
BEGIN
	 _debug = false;
	 -- NOTE! this stored procedure / function is part of the task generation tooling. Only use it for this purpose.
	 -- Generate monthly tasks, tasks are based on 2 logical parts, tasks based on the day of the week every x number of monts or tasks based on the day of the month. 
	 -- All calculations are based on the periodes of these logic parts. E.g. the month. So every calculation is done based on the start of the month where the periode should overlap. 
	 -- By this method nog advanced individual calculations should be done on insertion. 
	 -- The data for the inserts / updates are preparted with an query that already calculates the start dates of the tasks. 
	 -- Tasks are generated based on 2 periods after the current periode, due to the large number of dates (spanning 1 or more months), if the generated date for the current periode has not passed yet.
	 -- then also the task for the current periode will be generated. 
	 
	 -- Week Calculations Used
	 -- Sunday = 1
	 -- Monday = 2
	 -- Tuesday = 3
	 -- Wednesday = 4
	 -- Thursday = 5
	 -- Friday = 6
	 -- Saturday = 7
	 -- Day structure lookslike DOW calculations but with +1 added
  _rowtotalcount = 0;
	-- TODO Add check based on periode / template changes so if the next template periode are already generated they don't have to be re-generated, base on modified data and or custom check.
	-- NOTE! Can only be done if the speed can be attained. 
	FOR _temprow IN

		SELECT 
			M.task_template_id AS _template_id, 
			M.tasks_taskrecurrency_id AS _recurrency_id,
			M.company_id AS _company_id,
			NULL::int AS _shift_id,
			'todo'::varchar AS _status,
			M.area_id AS _area_id,
			M.end_date AS _end_date,
			M.type AS _type, 
			M.week AS _week, 
			M.day AS _day,
			M.month AS _month,
			M.month_recurrency AS _monthrecurrency,
			M.weekday AS _weekday,
			M.weekday_number AS _weekdaynumber,
			M.current_periode_interval_month_moment,
			M.next_periode_interval_month_moment AS _next_periode,
			M.next_second_periode_interval_month_moment AS _next_second_periode,
			CASE WHEN M.month_recurrency = 'day_of_month' THEN
				-- Generate based on just adding the days of the month to the start date of that month. 
				M.current_periode_interval_month_moment + CONCAT((M.day-1)::varchar, ' day')::interval
			ELSE
				-- Generate date based on DOW, calculate the difference to the currect date from the periode data, add or subtract that to/from the periode date and add the number of weekdays to that date, it should then be the correct date.
				CASE WHEN ((EXTRACT(DOW FROM M.current_periode_interval_month_moment)::integer) + 1) < M.weekday THEN
					-- Check if the asked day is smaller than the real day of periode date. If so, calculate the difference and add it to the periode date and add the number of weeks - 1 for the current week. 
					(M.current_periode_interval_month_moment::DATE) + (M.weekday - ((EXTRACT(DOW FROM M.current_periode_interval_month_moment)::integer) + 1)) + (CONCAT((7 * (M.weekday_number - 1))::varchar, ' day'))::interval	
					
				WHEN ((EXTRACT(DOW FROM M.current_periode_interval_month_moment)::integer) + 1) > M.weekday THEN
					-- Check if the asked day is larger than the real day of periode date. If so, calculate the difference and subtract it to the periode date and add the number of weeks. 
					(M.current_periode_interval_month_moment::DATE) - (((EXTRACT(DOW FROM M.current_periode_interval_month_moment)::integer) + 1) - M.weekday) + (CONCAT((7 * (M.weekday_number))::varchar, ' day'))::interval	
				ELSE
					-- current date has same day as the asked day so just add the  the number of the week minus the first week. 
					(M.current_periode_interval_month_moment::DATE) + (CONCAT((7 * (M.weekday_number - 1))::varchar, ' day'))::interval		
					
				END 
			END AS _current_start_date,
			CASE WHEN M.month_recurrency = 'day_of_month' THEN
				-- Generate based on just adding the days of the month to the start date of that month. 
				M.next_periode_interval_month_moment + CONCAT((M.day-1)::varchar, ' day')::interval
			ELSE
				-- Generate date based on DOW, calculate the difference to the currect date from the periode data, add or subtract that to/from the periode date and add the number of weekdays to that date, it should then be the correct date.
				CASE WHEN ((EXTRACT(DOW FROM M.next_periode_interval_month_moment)::integer) + 1) < M.weekday THEN
						-- Check if the asked day is smaller than the real day of periode date. If so, calculate the difference and add it to the periode date and add the number of weeks. 
						(M.next_periode_interval_month_moment::DATE) + (M.weekday - ((EXTRACT(DOW FROM M.next_periode_interval_month_moment)::integer) + 1)) + (CONCAT((7 * (M.weekday_number - 1))::varchar, ' day'))::interval		
						
				WHEN ((EXTRACT(DOW FROM M.next_periode_interval_month_moment)::integer) + 1) > M.weekday THEN
					-- Check if the asked day is larger than the real day of periode date. If so, calculate the difference and subtract it to the periode date and add the number of weeks. 
					(M.next_periode_interval_month_moment::DATE) - (((EXTRACT(DOW FROM M.next_periode_interval_month_moment)::integer) + 1) - M.weekday) + (CONCAT((7 * (M.weekday_number))::varchar, ' day'))::interval	
					
				ELSE
					-- current date has same day as the asked day so just add the  the number of the week minus the first week. 
					(M.next_periode_interval_month_moment::DATE) + (CONCAT((7 * (M.weekday_number - 1))::varchar, ' day'))::interval
					
				END 
			END AS _next_start_date,
			CASE WHEN M.month_recurrency = 'day_of_month' THEN
				-- Generate based on just adding the days of the month to the start date of that month. 
				M.next_second_periode_interval_month_moment + CONCAT((M.day-1)::varchar, ' day')::interval
			ELSE
				-- Generate date based on DOW, calculate the difference to the currect date from the periode data, add or subtract that to/from the periode date and add the number of weekdays to that date, it should then be the correct date.
				CASE WHEN ((EXTRACT(DOW FROM M.next_second_periode_interval_month_moment)::integer) + 1) < M.weekday THEN
					-- Check if the asked day is smaller than the real day of periode date. If so, calculate the difference and add it to the periode date and add the number of weeks. 
					(M.next_second_periode_interval_month_moment::DATE) + (M.weekday - ((EXTRACT(DOW FROM M.next_second_periode_interval_month_moment)::integer) + 1)) + (CONCAT((7 * (M.weekday_number - 1))::varchar, ' day'))::interval	
						
				WHEN ((EXTRACT(DOW FROM M.next_second_periode_interval_month_moment)::integer) + 1) > M.weekday THEN
					-- Check if the asked day is larger than the real day of periode date. If so, calculate the difference and subtract it to the periode date and add the number of weeks. 
					(M.next_second_periode_interval_month_moment::DATE) - (((EXTRACT(DOW FROM M.next_second_periode_interval_month_moment)::integer) + 1) - M.weekday) + (CONCAT((7 * (M.weekday_number))::varchar, ' day'))::interval	
					
				ELSE
					-- current date has same day as the asked day so just add the  the number of the week minus the first week. 
					(M.next_second_periode_interval_month_moment::DATE) + (CONCAT((7 * (M.weekday_number - 1))::varchar, ' day'))::interval			
				END 
			END AS _next_second_start_date
		FROM (

				SELECT 
						(SELECT generate_series(date_trunc('month', T.schedule_month_start::timestamp),
									NOW()::date, 
									CONCAT((T.month)::varchar, ' month')::interval) as GS
									ORDER BY GS DESC LIMIT 1) AS current_periode_interval_month_moment, -- Current periode from now based on the periode time, this will be used for checks
						(SELECT generate_series(date_trunc('month', T.schedule_month_start::timestamp),
									NOW()::date + CONCAT((T.month * 1)::varchar, ' month')::interval, 
									CONCAT((T.month)::varchar, ' month')::interval) as GS
									ORDER BY GS DESC LIMIT 1) AS next_periode_interval_month_moment, -- Get first periode from now based on the periode time, this is potentially the next task that is inserted 
						(SELECT generate_series(date_trunc('month', T.schedule_month_start::timestamp),
									NOW()::date + CONCAT((T.month * 2)::varchar, ' month')::interval, 
									CONCAT((T.month)::varchar, ' month')::interval) as GS
									ORDER BY GS DESC LIMIT 1) AS next_second_periode_interval_month_moment, -- Get second periode from now based on the periode time. this is potentially the second task that is being inserted. 
						 *
				FROM (
						SELECT 
								(NOW()::date + CONCAT((coalesce(TTR.month, 1) * 2)::varchar, ' month')::interval)::timestamp AS max_date_window, -- max date for the next 2 periode windows that can occure
								date_trunc('month', (NOW()::date)) AS current_month_start, -- current week start (used for referencing purposes) 
								CASE WHEN start_date IS NOT NULL THEN date_trunc('month', (TTR.start_date::date))
										 ELSE date_trunc('month', (TTR.created_at::date))
								END AS schedule_month_start, -- If there is a start date this will be the scheduled start date else use the created on date. 
								TTR.id AS tasks_taskrecurrency_id, 
								TTR.type, 
								coalesce(TTR.week, 1) AS week, 
								coalesce(TTR.day, 1) AS day,
								coalesce(TTR.month, 1) AS month,
								TTR.month_recurrency,
								CASE WHEN TTR.month_recurrency = 'day_of_month' THEN
									TTR.weekday
								ELSE -- fix missing data if needed return 1 (e.g. field value = null, shouldn't ocurre.
									coalesce(TTR.weekday, 1)
								END AS weekday,
								CASE WHEN TTR.month_recurrency = 'day_of_month' THEN
									TTR.weekday_number
								ELSE -- fix missing data if needed return 1 (e.g. field value = null, shouldn't ocurre.
									coalesce(TTR.weekday_number, 1)
								END AS weekday_number,
								TTR.company_id, 
								TTR.template_id, 
								TTR.area_id, 
								TTR.end_date, 
								TTR.start_date, 
								TT.id AS task_template_id, 
								TT.name,
								TTR.created_at,	
								TTR.modified_at
						FROM tasks_taskrecurrency TTR
						INNER JOIN tasks_tasktemplate TT ON TT.id = TTR.template_id
						INNER JOIN companies_area CA ON CA.id = TTR.area_id AND CA.is_active = true
						WHERE TTR.type = 'month'  AND TT.is_active = true  AND TT.company_id = _companyid 
						AND (TTR.end_date > NOW()::date OR TTR.end_date IS NULL) -- only include items where the end date is bigger then the current date or no end date (null)
						AND (TT.id = _templateid OR _templateid = 0)  -- only use 1 templat or ignore template and use all.
						ORDER BY month_recurrency
				) AS T
		) AS M

			
	 LOOP
	 	  -- set future items to active false, if able they will be recycled.
			UPDATE tasks_task SET is_active = false WHERE template_id = _temprow._template_id AND recurrency_id = _temprow._recurrency_id AND company_id = _companyid AND signed_by_id IS NULL AND start_date > NOW()::date;
			GET DIAGNOSTICS _rowcount = ROW_COUNT;
			IF _debug THEN
			RAISE NOTICE 'FUTURE TASKS SET INACTIVE %', _rowcount;
			END IF;
			
			-- will be using the following generate date fields for inserting tasks
			-- _current_start_date -> date generate for current periode (based on schedule)
			-- _next_start_date -> next start date for first periode after current periode (based on schedule)
			-- _next_second_start_date -> start date for second periode after the current periode (based on schedule)
			
			-- check if for the current periode the taskchanges have not yet occurred, if so also generate new tasks for the current periode, only generate if end date has not passed.
			IF _temprow._current_start_date::date > NOW()::date AND  (_temprow._current_start_date::date < _temprow._end_date::date OR _temprow._end_date::date IS NULL) THEN
				IF _debug THEN
					RAISE NOTICE 'START CURRENT % %',  _temprow._template_id, _temprow._current_start_date;
				END IF;

				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											_temprow._current_start_date::date, 
																											(_temprow._current_start_date + interval '1 day')::date,  
																											_temprow._current_start_date::timestamp, 
																											(_temprow._current_start_date + interval '1 day')::timestamp,
																											_temprow._recurrency_id, 
																											_temprow._shift_id);

				IF _debug THEN
					RAISE NOTICE 'current periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
			END IF;
			

			IF  _temprow._next_start_date::date < _temprow._end_date::date OR _temprow._end_date::date IS NULL THEN -- only generate if end date has not passed.
				IF _debug THEN
					RAISE NOTICE 'START FIRST % %',  _temprow._template_id, _temprow._next_start_date;
				END IF;
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											_temprow._next_start_date::date, 
																											(_temprow._next_start_date + interval '1 day')::date,  
																											_temprow._next_start_date::timestamp, 
																											(_temprow._next_start_date + interval '1 day')::timestamp,
																											_temprow._recurrency_id, 
																											_temprow._shift_id);

				IF _debug THEN
					RAISE NOTICE 'first periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
			END IF;
			
			IF  _temprow._next_second_start_date::date < _temprow._end_date::date OR _temprow._end_date::date IS NULL THEN -- only generate if end date has not passed.
				IF _debug THEN
					RAISE NOTICE 'START SECOND % %',  _temprow._template_id, _temprow._next_second_start_date;
				END IF;
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											_temprow._next_second_start_date::date, 
																											(_temprow._next_second_start_date + interval '1 day')::date,  
																											_temprow._next_second_start_date::timestamp, 
																											(_temprow._next_second_start_date + interval '1 day')::timestamp,
																											_temprow._recurrency_id, 
																											_temprow._shift_id);
				IF _debug THEN
					RAISE NOTICE 'second periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
			END IF;
					
   END LOOP;

	 RAISE NOTICE 'total row count _rowtotalcount: %', _rowtotalcount;
	 RETURN _rowtotalcount;

END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for generate_tasks_onetimeonly_by_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."generate_tasks_onetimeonly_by_company"("_companyid" int4, "_templateid" int4);
CREATE OR REPLACE FUNCTION "public"."generate_tasks_onetimeonly_by_company"("_companyid" int4, "_templateid" int4=0)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  _rowcount integer;
	_temprow record;
	_mutationcount integer;
	_rowtotalcount integer;
	_debug bool;
BEGIN
	_debug = false;
		---
		-- NOTE! this stored procedure / function is part of the task generation tooling. Only use it for this purpose.
		-- Get the templates that have a recurrency type of 'no recurrency', with every template get the generated taskid (if allready generated for the future.)
	  -- Note based on the id of the tasks, it could be that tasks will be recycled if the table is not cleaned correctly. This is behavour by design. 
   _rowtotalcount = 0;
	 -- NOTE tasks for the current day are already scheduled. These will be ignored based on their start date. 
	 -- TODO Add check based on periode / template changes so if the next template periode are already generated they don't have to be re-generated, base on modified data and or custom check.
	 -- NOTE! Can only be done if the speed can be attained. 
	 			 
	 FOR _temprow IN
      	SELECT M._template_id,
				 M._recurrency_id,
				 M._company_id,
				 M._generated_task_id,
				 M._shift_id,
				 M._date,
				 M._status,
				 M._start_at,
				 M._due_at,
				 M._start_at::date AS _start_date,
				 M._due_at::date AS _end_date
				FROM (		
							SELECT 
							T._template_id,
							T._recurrency_id,
							T._company_id,
							T._generated_task_id,
							T._shift_id,
							T._date,
							T._status,
							CASE WHEN T.shift_start_time IS NOT NULL THEN
								(T._date + T.shift_start_time)::timestamp
							ELSE
								T._date::timestamp
							END AS _start_at,
							CASE WHEN T.shift_end_time IS NOT NULL AND T.shift_end_time > T.shift_start_time THEN
								(T._date + T.shift_end_time)::timestamp
							WHEN T.shift_end_time IS NOT NULL AND T.shift_end_time < T.shift_start_time THEN
								(T._date + interval '24 hour' + T.shift_end_time)::timestamp
							ELSE
								(T._date + interval '24 hour')::timestamp
							END AS _due_at
							FROM (
							
										WITH shifts AS (		
													SELECT CS.id, CS."start" AS start_time, CS."end" AS end_time, CS.weekday, TS.taskrecurrency_id FROM companies_shift CS
													INNER JOIN tasks_taskrecurrency_one_time_shifts TS ON TS.shift_id = CS.id
													WHERE  CS.is_active = true AND CS.company_id = _companyid
													ORDER BY CS.id
										)
										 SELECT 
										 TT.id AS _template_id, 
										 TTR.id AS _recurrency_id,
										 TT.company_id AS _company_id,
										 (SELECT T.id FROM tasks_task T WHERE T.template_id = TTR.template_id AND T.recurrency_id = TTR.id AND T.company_id = TT.company_id AND T.start_date > NOW()::date ORDER BY T.id DESC LIMIT 1) AS _generated_task_id,
										 NULL::int AS _shift_id,
										 TTR.date AS _date, --_start_date TODO implement shift times
										 --TTR.date + interval '24 hour' AS _end_date, -- TODO implement shift times
										 --TTR.date::timestamp + interval '24 hour' AS _due_at, -- TODO implement shift times
										 --TTR.date::timestamp AS _start_at, -- TODO implement shift times
										 'todo'::varchar AS _status,
										 (SELECT start_time FROM shifts WHERE shifts.taskrecurrency_id = TTR.id ORDER BY weekday, start_time limit 1 ) AS shift_start_time, 
										 (SELECT end_time FROM shifts WHERE shifts.taskrecurrency_id = TTR.id ORDER BY weekday, start_time desc limit 1) AS shift_end_time 
										 FROM tasks_taskrecurrency TTR
										 INNER JOIN tasks_tasktemplate TT ON TT.id = TTR.template_id
										 WHERE TTR.type = 'no recurrency'  AND TT.is_active = true 
										 AND TTR.date::date > NOW()::date AND TT.company_id = _companyid
										 AND (TT.id = _templateid OR _templateid = 0)  -- only use 1 template or ignore template and use all.
							) AS T
				) AS M
   LOOP
			 -- Set all future generated tasks is_active to false.
			 UPDATE tasks_task SET is_active = false WHERE template_id = _temprow._template_id AND recurrency_id = _temprow._recurrency_id AND company_id = _companyid AND start_date > NOW()::date;
			 GET DIAGNOSTICS _rowcount = ROW_COUNT;
			 IF _debug THEN
				RAISE NOTICE 'FUTURE TASKS SET INACTIVE %', _rowcount;
			 END IF;
			 -- Check for existing item and update that item.
			 IF _temprow._generated_task_id IS NOT NULL AND _temprow._generated_task_id > 0 THEN
					IF _debug THEN
						RAISE NOTICE 'GENERATED TASK FOUND %', _temprow._generated_task_id;
					END IF;
																			
					 UPDATE tasks_task SET  
					 status = _temprow._status, 
					 template_id = _temprow._template_id, 
					 company_id = _temprow._company_id, 
					 recurrency_id = _temprow._recurrency_id, 
					 shift_id = _temprow._shift_id,
					 modified_at = now()::timestamp, 
					 is_active = true, 
					 start_date = _temprow._start_date, 
					 end_date = _temprow._end_date, 
					 due_at = _temprow._due_at, 
					 start_at = _temprow._start_at
					 WHERE id = _temprow._generated_task_id and company_id = _companyid;
					 GET DIAGNOSTICS _mutationcount = ROW_COUNT;
						
			 ELSE
					IF _debug THEN
						RAISE NOTICE 'INSERT NEW TASK';
					END IF;
					
					INSERT INTO tasks_task (id, status, template_id, company_id, recurrency_id, shift_id, created_at, modified_at, is_active, start_date, end_date, due_at, start_at) VALUES (
							DEFAULT, 
							_temprow._status,
							_temprow._template_id,
							_temprow._company_id,
							_temprow._recurrency_id,
							_temprow._shift_id,
							now()::timestamp,
							now()::timestamp,
							true,
							_temprow._start_date,
							_temprow._end_date,
							_temprow._due_at,
							_temprow._start_at
						);
						GET DIAGNOSTICS _mutationcount = ROW_COUNT;
			 END IF;
			 -- No existing item, insert a new one.
			 IF _debug THEN
				RAISE NOTICE 'TemplateId: % | GeneratedTaskId: %', _temprow._template_id, _temprow._generated_task_id;
			 END IF;
			 	_rowtotalcount = _rowtotalcount + _mutationcount;
   END LOOP;
	
	 	RAISE NOTICE 'total row count _rowtotalcount: %', _rowtotalcount;
	 RETURN _rowtotalcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for generate_tasks_shifts_by_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."generate_tasks_shifts_by_company"("_companyid" int4, "_templateid" int4);
CREATE OR REPLACE FUNCTION "public"."generate_tasks_shifts_by_company"("_companyid" int4, "_templateid" int4=0)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  _rowcount integer;
	_temprow record;
	_mutationcount integer;
	_rowtotalcount integer;
	_previous_recurrency_id integer;
	_debug bool;
BEGIN
		_debug = false;
	 -- NOTE! this stored procedure / function is part of the task generation tooling. Only use it for this purpose.
	 -- Generate shift tasks based on the number of shifts associated with a template.
	 -- The data for the inserts / updates are preparted with an query that already calculates the start dates of the tasks. 
	 -- The dates are not based on a specific datetime periode but based on the shift start and end time. 
	 -- Tasks are generated based on 2 periods after the current periode (2 weeks), due to the large number of dates (spanning 1 or more weeks, 1 or more shifts), if the generated date for the current periode has not passed yet.
	 -- then also the task for the current periode will be generated. 
		_rowtotalcount = 0;
		
   	FOR _temprow IN

	  SELECT 
				K.task_template_id AS _template_id, 
				K.tasks_taskrecurrency_id AS _recurrency_id,
				K.company_id AS _company_id,
				K.shift_id AS _shift_id,
				'todo'::varchar AS _status,
				K.area_id AS _area_id,
				K.end_date AS _end_date,
				K.type AS _type, 
				
				-- current periode
				K.current_periode_shift_start_date AS _current_periode_shift_start_date,
				K.current_periode_shift_end_date AS _current_periode_shift_end_date,
				K.current_periode_shift_start_date + K.shift_start AS _current_periode_shift_start_date_time,
				K.current_periode_shift_end_date + K.shift_end AS _current_periode_shift_end_date_time,

				-- first periode
				K.next_periode_shift_start_date  AS _next_periode_shift_start_date,
				K.next_periode_shift_end_date  AS _next_periode_shift_end_date,
				K.next_periode_shift_start_date + K.shift_start AS _next_periode_shift_start_date_time,
				K.next_periode_shift_end_date + K.shift_end AS _next_periode_shift_end_date_time,

				-- second periode
				K.next_second_periode_shift_start_date AS _next_second_periode_shift_start_date,
				K.next_second_periode_shift_end_date AS _next_second_periode_shift_end_date,
				K.next_second_periode_shift_start_date + K.shift_start AS _next_second_periode_shift_start_date_time,
				K.next_second_periode_shift_end_date + K.shift_end AS _next_second_periode_shift_end_date_time
		FROM (
			SELECT 
					*,
					-- current periode
					M.current_periode_interval_week_moment + CONCAT(M.shift_day, ' days')::interval AS current_periode_shift_start_date,
					CASE WHEN M.shift_end < M.shift_start THEN -- end date falls on the next day so add an extra day
						M.current_periode_interval_week_moment + CONCAT(M.shift_day + 1, ' days')::interval 
					ELSE
						M.current_periode_interval_week_moment + CONCAT(M.shift_day, ' days')::interval 
					END  AS current_periode_shift_end_date,
					-- first periode
					M.next_periode_interval_week_moment + CONCAT(M.shift_day, ' days')::interval AS next_periode_shift_start_date,
					CASE WHEN M.shift_end < M.shift_start THEN -- end date falls on the next day so add an extra day
						M.next_periode_interval_week_moment + CONCAT(M.shift_day + 1, ' days')::interval 
					ELSE
						M.next_periode_interval_week_moment + CONCAT(M.shift_day, ' days')::interval 
					END  AS next_periode_shift_end_date,
					-- second periode
					M.next_second_periode_interval_week_moment + CONCAT(M.shift_day, ' days')::interval AS next_second_periode_shift_start_date,
					CASE WHEN M.shift_end < M.shift_start THEN -- end date falls on the next day so add an extra day
						M.next_second_periode_interval_week_moment + CONCAT(M.shift_day + 1, ' days')::interval 
					ELSE
						M.next_second_periode_interval_week_moment + CONCAT(M.shift_day, ' days')::interval 
					END AS next_second_periode_shift_end_date 					
			FROM (
						SELECT  
							schedule_week_start AS current_periode_interval_week_moment, -- Current periode from now based on the periode time, this will be used for checks
							schedule_week_start + '7 days'::interval AS next_periode_interval_week_moment, -- Get first periode from now based on the periode time, this is potentially the next task that is inserted 
							schedule_week_start + '14 days'::interval AS next_second_periode_interval_week_moment, -- Get second periode from now based on the periode time. this is potentially the second task that is being inserted. 
							*
						FROM (
							SELECT 
									date_trunc('week', (NOW()::date)) AS schedule_week_start, 
									TTR.id AS tasks_taskrecurrency_id, 
									TTR.type, 
									TTR.company_id, 
									TTR.template_id, 
									TTR.area_id, 
									TTR.end_date, 
									TTR.start_date, 
									TT.id AS task_template_id, 
									TT.name,
									TTR.created_at,	
									TTR.modified_at,
									CS.id AS shift_id,
									CS.start AS shift_start,
									CS.end AS shift_end,
									CS.weekday AS shift_day
							FROM tasks_taskrecurrency TTR
							INNER JOIN tasks_tasktemplate TT ON TT.id = TTR.template_id
							INNER JOIN companies_area CA ON CA.id = TTR.area_id AND CA.is_active = true
							INNER JOIN tasks_taskrecurrency_shifts TTRS ON TTRS.taskrecurrency_id = TTR.id
							INNER JOIN companies_shift CS ON CS.id = TTRS.shift_id AND CS.is_active = true
							WHERE TTR.type = 'shifts'  AND TT.is_active = true AND TT.company_id = _companyid 
							AND (TTR.end_date > NOW()::date OR TTR.end_date IS NULL) 
							AND (TT.id = _templateid OR _templateid = 0)  -- only use 1 template or ignore template and use all.
							ORDER BY TT.id, CS.weekday, TT.area_id -- only include items where the end date is bigger then the current date or no end date (null)
						) AS T
			) AS M
			WHERE (M.end_date < M.current_periode_interval_week_moment OR M.end_date IS NULL) -- Exclude all items where the next periode falls after the end date of the template
	) AS K
					

			
	 LOOP
	 	  -- set future items to active false, if able they will be recycled, only once per cycle due to multiple records for one recurrency.
			IF (_previous_recurrency_id <> _temprow._recurrency_id OR _previous_recurrency_id IS NULL) THEN
					UPDATE tasks_task SET is_active = false WHERE template_id = _temprow._template_id AND recurrency_id = _temprow._recurrency_id AND company_id = _companyid AND signed_by_id IS NULL AND start_date > NOW()::date;
					_previous_recurrency_id = _temprow._recurrency_id;
					GET DIAGNOSTICS _rowcount = ROW_COUNT;
					IF _debug THEN
						RAISE NOTICE 'FUTURE TASKS SET INACTIVE %', _rowcount;
					END IF;
			END IF;
	
			-- will be using the following generate date fields for inserting tasks
			--  _current_periode_shift_start_date -> date generated for the current periode shift start date (based on schedule, and coupled shift)
			--  _current_periode_shift_end_date -> date generated for the current periode shift end date (based on schedule, and coupled shift)
			--  _next_periode_shift_start_date -> date generated for the next periode shift start date (based on schedule, and coupled shift)
			--  _next_periode_shift_end_date -> date generated for the next periode shift start date (based on schedule, and coupled shift)
			--  _next_second_periode_shift_start_date -> date generated for the second next periode shift start date (based on schedule, and coupled shift)
			--  _next_second_periode_shift_end_date -> date generated for the second next periode shift start date (based on schedule, and coupled shift)
			--  _current_periode_shift_start_date_time -> date/time generated for the current periode shift start date (based on schedule, and coupled shift start time)
			--  _current_periode_shift_end_date_time -> date/time generated for the current periode shift end date (based on schedule, and coupled shift end time)
			--  _next_periode_shift_start_date_time -> date/time generated for the next periode shift start date (based on schedule, and coupled shift start time)
			--  _next_periode_shift_end_date_time -> date/time generated for the next periode shift end date (based on schedule, and coupled shift end time)
			--  _next_second_periode_shift_start_date_time -> date/time generated for the second next periode shift start date (based on schedule, and coupled shift start time)
			--  _next_second_periode_shift_end_date_time -> date/time generated for the second next periode shift end date (based on schedule, and coupled shift end time)
	
			
			-- check if for the current periode the taskchanges have not yet occurred, if so also generate new tasks for the current periode, only generate if end date has not passed.
			IF _temprow._current_periode_shift_start_date::date > NOW()::date AND  (_temprow._current_periode_shift_start_date::date < _temprow._end_date::date OR _temprow._end_date::date IS NULL) THEN
				IF _debug THEN
					RAISE NOTICE 'START CURRENT % %',  _temprow._template_id, _temprow._current_periode_shift_start_date;
				END IF;

				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											_temprow._current_periode_shift_start_date::date, 
																											_temprow._current_periode_shift_end_date::date,  
																											_temprow._current_periode_shift_start_date_time::timestamp, 
																											_temprow._current_periode_shift_end_date_time::timestamp,
																											_temprow._recurrency_id, 
																											_temprow._shift_id);
				IF _debug THEN
					RAISE NOTICE 'current periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
			END IF;
			
			IF  _temprow._next_periode_shift_start_date::date < _temprow._end_date::date OR _temprow._end_date::date IS NULL THEN -- only generate if end date has not passed.
				IF _debug THEN
					RAISE NOTICE 'START FIRST % %',  _temprow._template_id, _temprow._next_periode_shift_start_date;
				END IF;
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											_temprow._next_periode_shift_start_date::date, 
																											_temprow._next_periode_shift_end_date::date,  
																											_temprow._next_periode_shift_start_date_time::timestamp, 
																											_temprow._next_periode_shift_end_date_time::timestamp,
																											_temprow._recurrency_id, 
																											_temprow._shift_id);
			
				IF _debug THEN
					RAISE NOTICE 'first periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
			END IF;
			

			IF  _temprow._next_second_periode_shift_start_date::date < _temprow._end_date::date OR _temprow._end_date::date IS NULL THEN -- only generate if end date has not passed.
				IF _debug THEN
					RAISE NOTICE 'START SECOND % %',  _temprow._template_id, _temprow._next_second_periode_shift_start_date;
				END IF;
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											_temprow._next_second_periode_shift_start_date::date, 
																											_temprow._next_second_periode_shift_end_date::date,  
																											_temprow._next_second_periode_shift_start_date_time::timestamp, 
																											_temprow._next_second_periode_shift_end_date_time::timestamp,
																											_temprow._recurrency_id, 
																											_temprow._shift_id);
																											
				IF _debug THEN
					RAISE NOTICE 'second periode _mutationcount: %', _mutationcount;
				END IF;
			_rowtotalcount = _rowtotalcount + _mutationcount;
			END IF;
					
   END LOOP;
	 
	 RAISE NOTICE 'total row count _rowtotalcount: %', _rowtotalcount;
	 RETURN _rowtotalcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for generate_tasks_weekly_by_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."generate_tasks_weekly_by_company"("_companyid" int4, "_templateid" int4);
CREATE OR REPLACE FUNCTION "public"."generate_tasks_weekly_by_company"("_companyid" int4, "_templateid" int4=0)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  _rowcount integer;
	_temprow record;
	_mutationcount integer;
	_rowtotalcount integer;
	_debug bool;
BEGIN
	_debug = false;
	 ---
	 -- NOTE! this stored procedure / function is part of the task generation tooling. Only use it for this purpose.
	 -- The stored procdure will generate a dataset for a company (and a specific template if supplied) for all weekly scheduled tasks. 
	 -- Based on this dataset the stored procedure will generate one or more tasks per template (depending on the weekdays selected.)
	 -- To make sure to maximize the use of the database alle future scheduled tasks will be recycled if needed so no unnessecery data will stay behind in the database. 
	 -- This will be achieved per template, so no accedental updates can occure. 
	 
	 -- TODO Add check based on periode / template changes so if the next template periode are already generated they don't have to be re-generated, base on modified data and or custom check.
	 -- NOTE! Can only be done if the performance won't suffer. 
	_rowtotalcount = 0;

	FOR _temprow IN

		SELECT 
			 K.task_template_id AS _template_id, 
			 K.tasks_taskrecurrency_id AS _recurrency_id,
			 K.company_id AS _company_id,
			 NULL::int AS _shift_id,
			 'todo'::varchar AS _status,
			 K.area_id AS _area_id,
			 K.end_date AS _end_date,
			 K.weekday0 AS _weekday0,
			 K.weekday1 AS _weekday1,
			 K.weekday2 AS _weekday2, 
			 K.weekday3 AS _weekday3, 
			 K.weekday4 AS _weekday4, 
			 K.weekday5 AS _weekday5,
			 K.weekday6 AS _weekday6,
			 K.current_periode_interval_week_moment AS _current_periode,
			 K.next_periode_interval_week_moment AS _next_periode,
			 K.next_second_periode_interval_week_moment AS _next_second_periode,
			(periode_changed_on_weekday0 OR periode_changed_on_weekday1 OR periode_changed_on_weekday2 OR periode_changed_on_weekday3 OR periode_changed_on_weekday4 OR periode_changed_on_weekday5 OR periode_changed_on_weekday6) AS periode_changed --*/
			FROM (
					-- Getting basic data, the generated recurrency possible start dates and calculate any previous tasks that are available in the current periode for determing if there are certain inserts that do not need to be done. 
					SELECT *,
					-- Generete values for each day in the current periode tasks could or have been generated for use with checking if it is needed to generate tasks and checking if there were changes.
					(SELECT EXISTS(SELECT * FROM tasks_task T0 WHERE T0.is_active = true AND T0.company_id = _companyid AND T0.template_id = M.template_id AND T0.start_date::date >= (M.current_periode_interval_week_moment)::date AND EXTRACT(DOW FROM T0.start_date::timestamp) = 0)) <> M.weekday0 AS periode_changed_on_weekday0,
					(SELECT EXISTS(SELECT * FROM tasks_task T0 WHERE T0.is_active = true AND T0.company_id = _companyid AND T0.template_id = M.template_id AND T0.start_date::date >= (M.current_periode_interval_week_moment)::date AND EXTRACT(DOW FROM T0.start_date::timestamp) = 1)) <> M.weekday1 AS periode_changed_on_weekday1,
					(SELECT EXISTS(SELECT * FROM tasks_task T0 WHERE T0.is_active = true AND T0.company_id = _companyid AND T0.template_id = M.template_id AND T0.start_date::date >= (M.current_periode_interval_week_moment)::date AND EXTRACT(DOW FROM T0.start_date::timestamp) = 2)) <> M.weekday2 AS periode_changed_on_weekday2,
					(SELECT EXISTS(SELECT * FROM tasks_task T0 WHERE T0.is_active = true AND T0.company_id = _companyid AND T0.template_id = M.template_id AND T0.start_date::date >= (M.current_periode_interval_week_moment)::date AND EXTRACT(DOW FROM T0.start_date::timestamp) = 3)) <> M.weekday3 AS periode_changed_on_weekday3,
					(SELECT EXISTS(SELECT * FROM tasks_task T0 WHERE T0.is_active = true AND T0.company_id = _companyid AND T0.template_id = M.template_id AND T0.start_date::date >= (M.current_periode_interval_week_moment)::date AND EXTRACT(DOW FROM T0.start_date::timestamp) = 4)) <> M.weekday4 AS periode_changed_on_weekday4,
					(SELECT EXISTS(SELECT * FROM tasks_task T0 WHERE T0.is_active = true AND T0.company_id = _companyid AND T0.template_id = M.template_id AND T0.start_date::date >= (M.current_periode_interval_week_moment)::date AND EXTRACT(DOW FROM T0.start_date::timestamp) = 5)) <> M.weekday5 AS periode_changed_on_weekday5,
					(SELECT EXISTS(SELECT * FROM tasks_task T0 WHERE T0.is_active = true AND T0.company_id = _companyid AND T0.template_id = M.template_id AND T0.start_date::date >= (M.current_periode_interval_week_moment)::date AND EXTRACT(DOW FROM T0.start_date::timestamp) = 6)) <> M.weekday6 AS periode_changed_on_weekday6,
					-- Check if for current periode tasks are already done
					(SELECT EXISTS(SELECT * FROM tasks_task T0 WHERE T0.is_active = true AND T0.company_id = _companyid AND T0.template_id = M.template_id AND T0.start_date::date >= (M.current_periode_interval_week_moment)::date AND T0.signed_by_id IS NOT NULL)) AS task_done_for_current_periode
				FROM (
						-- Getting the basic data set and adding generated series start week dates based on the recurring periode
						SELECT 
								(SELECT generate_series(date_trunc('week', T.schedule_week_start::timestamp),
											NOW()::date, 
											CONCAT((T.week)::varchar, ' week')::interval) as GS
											ORDER BY GS DESC LIMIT 1) AS current_periode_interval_week_moment, -- Current periode from now based on the periode time, this will be used for checks
								(SELECT generate_series(date_trunc('week', T.schedule_week_start::timestamp),
											NOW()::date + CONCAT((T.week * 1)::varchar, ' week')::interval, 
											CONCAT((T.week)::varchar, ' week')::interval) as GS
											ORDER BY GS DESC LIMIT 1) AS next_periode_interval_week_moment, -- Get first periode from now based on the periode time, this is potentially the next task that is inserted 
								(SELECT generate_series(date_trunc('week', T.schedule_week_start::timestamp),
											NOW()::date + CONCAT((T.week * 2)::varchar, ' week')::interval, 
											CONCAT((T.week)::varchar, ' week')::interval) as GS
											ORDER BY GS DESC LIMIT 1) AS next_second_periode_interval_week_moment, -- Get second periode from now based on the periode time. this is potentially the second task that is being inserted. 
							*
						FROM (	
							-- Basic data set, getting all weekly recurrencies that are active and generating a set of start dates for further calculations
							SELECT 
								(NOW()::date + CONCAT((week * 2)::varchar, ' week')::interval)::timestamp AS max_date_window, -- max date for the next 2 periode windows that can occure
								date_trunc('week', (NOW()::date)) AS current_week_start, -- current week start (used for referencing purposes)
								CASE WHEN start_date IS NOT NULL THEN date_trunc('week', (TTR.start_date::date))
										 ELSE date_trunc('week', (TTR.created_at::date))
								END AS schedule_week_start, -- If there is a start date this will be the scheduled start date else use the created on date. 
								TTR.id AS tasks_taskrecurrency_id, 
								TTR.type, 
								CASE WHEN TTR.week IS NULL OR TTR.week = 0 THEN
									1::int
								ELSE
									TTR.week
								END AS week, 
								TTR.company_id, 
								TTR.template_id, 
								TTR.area_id, 
								TTR.end_date, 
								TTR.start_date, 
								TTR.weekday0, 
								TTR.weekday1, 
								TTR.weekday2,
								TTR.weekday3, 
								TTR.weekday4, 
								TTR.weekday5, 
								TTR.weekday6, 
								TT.id AS task_template_id, 
								TT.name,
								TTR.created_at,	
								TTR.modified_at
							FROM tasks_taskrecurrency TTR
							INNER JOIN tasks_tasktemplate TT ON TT.id = TTR.template_id
							INNER JOIN companies_area CA ON CA.id = TTR.area_id AND CA.is_active = true
							WHERE TTR.type = 'week'  AND TT.is_active = true  AND TT.company_id = _companyid 
							AND (TTR.end_date > NOW()::date OR TTR.end_date IS NULL) -- Exclude all items where end date falls after the current date.
							AND (TT.id = _templateid OR _templateid = 0)  -- Exclude all items where end date falls after the current date.
						) AS T
				) AS M
				WHERE (M.end_date > M."next_periode_interval_week_moment" OR M.end_date IS NULL) -- Exclude all items where the next periode falls after the end date of the template
		) AS K
     
     
     
     
   LOOP
	    -- set future items to active false, if able they will be recycled.
			UPDATE tasks_task SET is_active = false WHERE template_id = _temprow._template_id AND recurrency_id = _temprow._recurrency_id AND company_id = _companyid AND signed_by_id IS NULL AND start_date > NOW()::date;
			GET DIAGNOSTICS _rowcount = ROW_COUNT;
			IF _debug THEN
				RAISE NOTICE 'FUTURE TASKS SET INACTIVE %', _rowcount;
			END IF;
			 
			IF _temprow._weekday0 THEN
					IF _debug THEN
						RAISE NOTICE '_weekday0 % % % %', _temprow._weekday0, _temprow._template_id, _temprow._next_periode + interval '0 day', _temprow._next_second_periode + interval '0 day';
					END IF;
					IF (_temprow._current_periode + interval '0 day')::date > NOW()::date THEN
								-- insert update first periode for weekday 0
								_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																															_temprow._template_id, 
																															_temprow._company_id, 
																															(_temprow._current_periode + interval '0 day')::date, 
																															(_temprow._current_periode + interval '1 day')::date,  
																															(_temprow._current_periode + interval '0 day')::timestamp, 
																															(_temprow._current_periode + interval '1 day')::timestamp,
																															_temprow._recurrency_id, _temprow._shift_id);
								IF _debug THEN
									RAISE NOTICE 'Weekday 0 - current periode _mutationcount: %', _mutationcount;
								END IF;
					END IF;
					-- insert update first periode for weekday 0
					_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																												_temprow._template_id, 
																												_temprow._company_id, 
																												(_temprow._next_periode + interval '0 day')::date, 
																												(_temprow._next_periode + interval '1 day')::date,  
																												(_temprow._next_periode + interval '0 day')::timestamp, 
																												(_temprow._next_periode + interval '1 day')::timestamp,
																												_temprow._recurrency_id, _temprow._shift_id);
					IF _debug THEN
						RAISE NOTICE 'Weekday 0 - first periode _mutationcount: %', _mutationcount;
					END IF;
				  _rowtotalcount = _rowtotalcount + _mutationcount;
					-- insert update second periode for weekday 0
					_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																												_temprow._template_id, 
																												_temprow._company_id, 
																												(_temprow._next_second_periode + interval '0 day')::date, 
																												(_temprow._next_second_periode + interval '1 day')::date,  
																												(_temprow._next_second_periode + interval '0 day')::timestamp, 
																												(_temprow._next_second_periode + interval '1 day')::timestamp,
																												_temprow._recurrency_id, _temprow._shift_id);
					IF _debug THEN
						RAISE NOTICE 'Weekday 0 - second periode _mutationcount: %', _mutationcount;
					END IF;
					_rowtotalcount = _rowtotalcount + _mutationcount;
			END IF;
			
			IF _temprow._weekday1 THEN
				IF _debug THEN
					RAISE NOTICE '_weekday1 % % % %', _temprow._weekday1, _temprow._template_id, _temprow._next_periode + interval '1 day', _temprow._next_second_periode + interval '1 day';
				END IF;
				IF (_temprow._current_periode + interval '1 day')::date > NOW()::date THEN
						-- insert update current periode for weekday 1
						_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																													_temprow._template_id, 
																													_temprow._company_id, 
																													(_temprow._current_periode + interval '1 day')::date, 
																													(_temprow._current_periode + interval '2 day')::date,  
																													(_temprow._current_periode + interval '1 day')::timestamp, 
																													(_temprow._current_periode + interval '2 day')::timestamp,
																													_temprow._recurrency_id, _temprow._shift_id);

						IF _debug THEN
							RAISE NOTICE 'Weekday 1 - current periode _mutationcount: %', _mutationcount;
						END IF;
				END IF;
				
				-- insert update first periode for weekday 1
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											(_temprow._next_periode + interval '1 day')::date, 
																											(_temprow._next_periode + interval '2 day')::date,  
																											(_temprow._next_periode + interval '1 day')::timestamp, 
																											(_temprow._next_periode + interval '2 day')::timestamp,
																											_temprow._recurrency_id, _temprow._shift_id);

				IF _debug THEN
					RAISE NOTICE 'Weekday 1 - first periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
				-- insert update second periode for weekday 1
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											(_temprow._next_second_periode + interval '1 day')::date, 
																											(_temprow._next_second_periode + interval '2 day')::date,  
																											(_temprow._next_second_periode + interval '1 day')::timestamp, 
																											(_temprow._next_second_periode + interval '2 day')::timestamp,
																											_temprow._recurrency_id, _temprow._shift_id);
				IF _debug THEN
					RAISE NOTICE 'Weekday 1 - second periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
			END IF;
			
			IF _temprow._weekday2 THEN
				IF _debug THEN
					RAISE NOTICE '_weekday2 % % % %', _temprow._weekday2, _temprow._template_id, _temprow._next_periode + interval '2 day', _temprow._next_second_periode + interval '2 day';
				END IF;
				IF (_temprow._current_periode + interval '2 day')::date > NOW()::date THEN
						-- insert update current periode for weekday 2
						_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																													_temprow._template_id, 
																													_temprow._company_id, 
																													(_temprow._current_periode + interval '2 day')::date, 
																													(_temprow._current_periode + interval '3 day')::date,  
																													(_temprow._current_periode + interval '2 day')::timestamp, 
																													(_temprow._current_periode + interval '3 day')::timestamp,
																													_temprow._recurrency_id, _temprow._shift_id);
						IF _debug THEN
							RAISE NOTICE 'Weekday 2 - current periode _mutationcount: %', _mutationcount;
						END IF;
				END IF;
					
				-- insert update first periode for weekday 2
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											(_temprow._next_periode + interval '2 day')::date, 
																											(_temprow._next_periode + interval '3 day')::date,  
																											(_temprow._next_periode + interval '2 day')::timestamp, 
																											(_temprow._next_periode + interval '3 day')::timestamp,
																											_temprow._recurrency_id, _temprow._shift_id);
				IF _debug THEN
					RAISE NOTICE 'Weekday 2 - first periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
				-- insert update second periode for weekday 2
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											(_temprow._next_second_periode + interval '2 day')::date, 
																											(_temprow._next_second_periode + interval '3 day')::date,  
																											(_temprow._next_second_periode + interval '2 day')::timestamp, 
																											(_temprow._next_second_periode + interval '3 day')::timestamp,
																											_temprow._recurrency_id, _temprow._shift_id);
				IF _debug THEN
					RAISE NOTICE 'Weekday 2 - second periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
				
			END IF;
			
			IF _temprow._weekday3 THEN
				IF _debug THEN
					RAISE NOTICE '_weekday3 % % % %', _temprow._weekday3, _temprow._template_id, _temprow._next_periode + interval '3 day', _temprow._next_second_periode + interval '3 day';
				END IF;
				IF (_temprow._current_periode + interval '3 day')::date > NOW()::date THEN
						-- insert update cirrent periode for weekday 3
						_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																													_temprow._template_id, 
																													_temprow._company_id, 
																													(_temprow._current_periode + interval '3 day')::date, 
																													(_temprow._current_periode + interval '4 day')::date,  
																													(_temprow._current_periode + interval '3 day')::timestamp, 
																													(_temprow._current_periode + interval '4 day')::timestamp,
																													_temprow._recurrency_id, _temprow._shift_id);
						IF _debug THEN
							RAISE NOTICE 'Weekday 3 - current periode _mutationcount: %', _mutationcount;
						END IF;
				END IF;
				
				-- insert update first periode for weekday 3
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											(_temprow._next_periode + interval '3 day')::date, 
																											(_temprow._next_periode + interval '4 day')::date,  
																											(_temprow._next_periode + interval '3 day')::timestamp, 
																											(_temprow._next_periode + interval '4 day')::timestamp,
																											_temprow._recurrency_id, _temprow._shift_id);
				IF _debug THEN
					RAISE NOTICE 'Weekday 3 - first periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
				-- insert update second periode for weekday 3
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											(_temprow._next_second_periode + interval '3 day')::date, 
																											(_temprow._next_second_periode + interval '4 day')::date,  
																											(_temprow._next_second_periode + interval '3 day')::timestamp, 
																											(_temprow._next_second_periode + interval '4 day')::timestamp,
																											_temprow._recurrency_id, _temprow._shift_id);
				IF _debug THEN
					RAISE NOTICE 'Weekday 3 - second periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
				
			END IF;
			
			IF _temprow._weekday4 THEN
				IF _debug THEN
					RAISE NOTICE '_weekday4 % % % %', _temprow._weekday4, _temprow._template_id, _temprow._next_periode + interval '4 day', _temprow._next_second_periode + interval '4 day';
				END IF;
				IF (_temprow._current_periode + interval '4 day')::date > NOW()::date THEN
						-- insert update current periode for weekday 4
						_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																													_temprow._template_id, 
																													_temprow._company_id, 
																													(_temprow._current_periode + interval '4 day')::date, 
																													(_temprow._current_periode + interval '5 day')::date,  
																													(_temprow._current_periode + interval '4 day')::timestamp, 
																													(_temprow._current_periode + interval '5 day')::timestamp,
																													_temprow._recurrency_id, _temprow._shift_id);
						IF _debug THEN
							RAISE NOTICE 'Weekday 4 - current periode _mutationcount: %', _mutationcount;
						END IF;
				END IF;	
				
				-- insert update first periode for weekday 4
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											(_temprow._next_periode + interval '4 day')::date, 
																											(_temprow._next_periode + interval '5 day')::date,  
																											(_temprow._next_periode + interval '4 day')::timestamp, 
																											(_temprow._next_periode + interval '5 day')::timestamp,
																											_temprow._recurrency_id, _temprow._shift_id);
				IF _debug THEN
					RAISE NOTICE 'Weekday 4 - first periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
				-- insert update second periode for weekday 4
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											(_temprow._next_second_periode + interval '4 day')::date, 
																											(_temprow._next_second_periode + interval '5 day')::date,  
																											(_temprow._next_second_periode + interval '4 day')::timestamp, 
																											(_temprow._next_second_periode + interval '5 day')::timestamp,
																											_temprow._recurrency_id, _temprow._shift_id);
				IF _debug THEN
					RAISE NOTICE 'Weekday 4 - second periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
				
			END IF;
			
			IF _temprow._weekday5 THEN
				IF _debug THEN
					RAISE NOTICE '_weekday5 % % % %', _temprow._weekday5, _temprow._template_id, _temprow._next_periode + interval '5 day', _temprow._next_second_periode + interval '5 day';
				END IF;
				IF (_temprow._current_periode + interval '5 day')::date > NOW()::date THEN
						-- insert update current periode for weekday 5
						_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																													_temprow._template_id, 
																													_temprow._company_id, 
																													(_temprow._current_periode + interval '5 day')::date, 
																													(_temprow._current_periode + interval '6 day')::date,  
																													(_temprow._current_periode + interval '5 day')::timestamp, 
																													(_temprow._current_periode + interval '6 day')::timestamp,
																													_temprow._recurrency_id, _temprow._shift_id);
						IF _debug THEN
							RAISE NOTICE 'Weekday 5 - current periode _mutationcount: %', _mutationcount;
						END IF;
				END IF;	
					
				-- insert update first periode for weekday 5
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											(_temprow._next_periode + interval '5 day')::date, 
																											(_temprow._next_periode + interval '6 day')::date,  
																											(_temprow._next_periode + interval '5 day')::timestamp, 
																											(_temprow._next_periode + interval '6 day')::timestamp,
																											_temprow._recurrency_id, _temprow._shift_id);
				IF _debug THEN
					RAISE NOTICE 'Weekday 5 - first periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
				-- insert update second periode for weekday 5
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											(_temprow._next_second_periode + interval '5 day')::date, 
																											(_temprow._next_second_periode + interval '6 day')::date,  
																											(_temprow._next_second_periode + interval '5 day')::timestamp, 
																											(_temprow._next_second_periode + interval '6 day')::timestamp,
																											_temprow._recurrency_id, _temprow._shift_id);
				IF _debug THEN
					RAISE NOTICE 'Weekday 5 - second periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
				
			END IF;
			IF _temprow._weekday6 THEN
				IF _debug THEN
					RAISE NOTICE '_weekday6 % % % %', _temprow._weekday6, _temprow._template_id, _temprow._next_periode + interval '6 day', _temprow._next_second_periode + interval '6 day';
				END IF;
				IF (_temprow._current_periode + interval '6 day')::date > NOW()::date THEN
						-- insert update current periode for weekday 6
						_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																													_temprow._template_id, 
																													_temprow._company_id, 
																													(_temprow._current_periode + interval '6 day')::date, 
																													(_temprow._current_periode + interval '7 day')::date,  
																													(_temprow._current_periode + interval '6 day')::timestamp, 
																													(_temprow._current_periode + interval '7 day')::timestamp,
																													_temprow._recurrency_id, _temprow._shift_id);
						IF _debug THEN
							RAISE NOTICE 'Weekday 6 - current periode _mutationcount: %', _mutationcount;
						END IF;
				END IF;	
					
				-- insert update first periode for weekday 6
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											(_temprow._next_periode + interval '6 day')::date, 
																											(_temprow._next_periode + interval '7 day')::date,  
																											(_temprow._next_periode + interval '6 day')::timestamp, 
																											(_temprow._next_periode + interval '7 day')::timestamp,
																											_temprow._recurrency_id, _temprow._shift_id);
				IF _debug THEN
					RAISE NOTICE 'Weekday 6 - first periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
				-- insert update second periode for weekday 6
				_mutationcount = generate_tasks_insertupdate(	_temprow._status, 
																											_temprow._template_id, 
																											_temprow._company_id, 
																											(_temprow._next_second_periode + interval '6 day')::date, 
																											(_temprow._next_second_periode + interval '7 day')::date,  
																											(_temprow._next_second_periode + interval '6 day')::timestamp, 
																											(_temprow._next_second_periode + interval '7 day')::timestamp,
																											_temprow._recurrency_id, _temprow._shift_id);
				IF _debug THEN
					RAISE NOTICE 'Weekday 6 - second periode _mutationcount: %', _mutationcount;
				END IF;
				_rowtotalcount = _rowtotalcount + _mutationcount;
			
			END IF;
	
   END LOOP;

	 RETURN _rowtotalcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for generate_uid
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."generate_uid"("id" int8, "min_length" int4, "salt" text);
CREATE OR REPLACE FUNCTION "public"."generate_uid"("id" int8, "min_length" int4, "salt" text)
  RETURNS "pg_catalog"."text" AS $BODY$
DECLARE
    clean_alphabet TEXT := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';
    curse_chars TEXT := 'csfhuit';
    curse TEXT := curse_chars || UPPER(curse_chars);
    alphabet TEXT := regexp_replace(clean_alphabet, '[' || curse  || ']', '', 'gi');
    shuffle_alphabet TEXT := consistent_shuffle(alphabet, salt);
    char_length INT := length(alphabet);
    output TEXT := '';
BEGIN
		------------------------------
		-- BASED ON hashids.org functionality https://hashids.org/ & https://stackoverflow.com/questions/41970461/how-to-generate-a-random-unique-alphanumeric-id-of-length-n-in-postgres-9-6
		-- Functionality generates a uid based on a integer, lenght and salt text. 
		------------------------------
    WHILE id != 0 LOOP
        output := output || substr(shuffle_alphabet, ((id % char_length) + 1)::int4, 1);
        id := trunc(id / char_length);
    END LOOP;
    curse := consistent_shuffle(curse, output || salt);
    output := RPAD(output, min_length, curse);
    RETURN output;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for generate_uid
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."generate_uid"("id" int4, "min_length" int4, "salt" text);
CREATE OR REPLACE FUNCTION "public"."generate_uid"("id" int4, "min_length" int4, "salt" text)
  RETURNS "pg_catalog"."text" AS $BODY$
DECLARE
    clean_alphabet TEXT := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';
    curse_chars TEXT := 'csfhuit';
    curse TEXT := curse_chars || UPPER(curse_chars);
    alphabet TEXT := regexp_replace(clean_alphabet, '[' || curse  || ']', '', 'gi');
    shuffle_alphabet TEXT := consistent_shuffle(alphabet, salt);
    char_length INT := length(alphabet);
    output TEXT := '';
BEGIN
		------------------------------
		-- BASED ON hashids.org functionality https://hashids.org/ & https://stackoverflow.com/questions/41970461/how-to-generate-a-random-unique-alphanumeric-id-of-length-n-in-postgres-9-6
		-- Functionality generates a uid based on a integer, lenght and salt text. 
		------------------------------
    WHILE id != 0 LOOP
        output := output || substr(shuffle_alphabet, (id % char_length) + 1, 1);
        id := trunc(id / char_length);
    END LOOP;
    curse := consistent_shuffle(curse, output || salt);
    output := RPAD(output, min_length, curse);
    RETURN output;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for get_action
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_action"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_action"("_companyid" int4, "_id" int4)
  RETURNS TABLE("comment" text, "company_id" int4, "created_at" timestamptz, "created_by_id" int4, "description" text, "due_date" date, "id" int4, "image_0" varchar, "image_1" varchar, "image_2" varchar, "image_3" varchar, "image_4" varchar, "image_5" varchar, "is_resolved" bool, "modified_at" timestamptz, "resolved_at" timestamptz, "task_id" int4, "task_template_id" int4, "video_0" varchar, "video_1" varchar, "video_2" varchar, "video_3" varchar, "video_4" varchar, "video_5" varchar, "video_thumbnail_0" varchar, "video_thumbnail_1" varchar, "video_thumbnail_2" varchar, "video_thumbnail_3" varchar, "video_thumbnail_4" varchar, "video_thumbnail_5" varchar, "commentnr" int4, "createdby" text) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	AA.comment, 
	AA.company_id, 
	AA.created_at, 
	AA.created_by_id,
	AA.description, 
	AA.due_date, 
	AA.id, 
	AA.image_0, 
	AA.image_1, 
	AA.image_2, 
	AA.image_3, 
	AA.image_4, 
	AA.image_5, 
	AA.is_resolved, 
	AA.modified_at, 
	AA.resolved_at, 
	AA.task_id, 
	AA.task_template_id, 
	AA.video_0, 
	AA.video_1, 
	AA.video_2, 
	AA.video_3, 
	AA.video_4, 
	AA.video_5, 
	AA.video_thumbnail_0, 
	AA.video_thumbnail_1, 
	AA.video_thumbnail_2,
	AA.video_thumbnail_3,
	AA.video_thumbnail_4,
	AA.video_thumbnail_5, 
	(SELECT Count(AAC.id)::int4 FROM actions_actioncomment AAC WHERE AAC.action_id = AA.id) AS commentnr, 
	CONCAT(PU.first_name, ' ', PU.last_name) AS createdby 
	FROM actions_action AA INNER JOIN profiles_user PU ON PU.id = AA.created_by_id 
	WHERE AA.company_id = _companyid AND AA.id = _id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_action_parent
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_action_parent"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_action_parent"("_companyid" int4, "_id" int4)
  RETURNS TABLE("id" int4, "task_name" varchar, "type" varchar, "task_id" int4, "task_template_id" int4, "audittemplate_id" int4, "audittemplate_name" varchar, "checklisttemplate_id" int4, "checklisttemplate_name" varchar, "audit_id" int4, "checklist_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
AA.id, 
TTT.name AS task_name, 
TTT.type, 
AA.task_id, 
TTT.id AS task_template_id, 
AAT.id AS audittemplate_id, 
AAT.name AS audittemplate_name, 
CCT.id AS checklisttemplate_id,
CCT.name AS checklisttemplate_name,
AU.id AS audit_id, 
CC.id AS checklist_id
FROM actions_action AA 
LEFT JOIN tasks_task TT  ON TT.id = AA.task_id
LEFT JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id OR TTT.id = AA.task_template_id
LEFT JOIN audits_audittemplate_tasks AATT ON AATT.tasktemplate_id = TTT.id
LEFT JOIN audits_audittemplate AAT ON AAT.id = AATT.audittemplate_id
LEFT JOIN audits_audit_tasks AUT ON AUT.task_id = AA.task_id
LEFT JOIN audits_audit AU ON AU.id = AUT.audit_id
LEFT JOIN checklists_checklisttemplate_tasks CCTT ON CCTT.tasktemplate_id = TTT.id
LEFT JOIN checklists_checklisttemplate CCT ON CCT.id = CCTT.checklisttemplate_id
LEFT JOIN checklists_checklist_tasks CUT ON CUT.task_id = AA.task_id
LEFT JOIN checklists_checklist CC ON CC.id = CUT.checklist_id
WHERE AA.id = _id AND AA.company_id = _companyid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_action_parents
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_action_parents"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_action_parents"("_companyid" int4)
  RETURNS TABLE("id" int4, "task_name" varchar, "type" varchar, "task_id" int4, "task_template_id" int4, "audittemplate_id" int4, "audittemplate_name" varchar, "checklisttemplate_id" int4, "checklisttemplate_name" varchar, "audit_id" int4, "checklist_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
AA.id, 
TTT.name AS task_name, 
TTT.type, 
AA.task_id, 
TTT.id AS task_template_id, 
AAT.id AS audittemplate_id, 
AAT.name AS audittemplate_name, 
CCT.id AS checklisttemplate_id,
CCT.name AS checklisttemplate_name,
AU.id AS audit_id, 
CC.id AS checklist_id
FROM actions_action AA 
LEFT JOIN tasks_task TT  ON TT.id = AA.task_id
LEFT JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id OR TTT.id = AA.task_template_id
LEFT JOIN audits_audittemplate_tasks AATT ON AATT.tasktemplate_id = TTT.id
LEFT JOIN audits_audittemplate AAT ON AAT.id = AATT.audittemplate_id
LEFT JOIN audits_audit_tasks AUT ON AUT.task_id = AA.task_id
LEFT JOIN audits_audit AU ON AU.id = AUT.audit_id
LEFT JOIN checklists_checklisttemplate_tasks CCTT ON CCTT.tasktemplate_id = TTT.id
LEFT JOIN checklists_checklisttemplate CCT ON CCT.id = CCTT.checklisttemplate_id
LEFT JOIN checklists_checklist_tasks CUT ON CUT.task_id = AA.task_id
LEFT JOIN checklists_checklist CC ON CC.id = CUT.checklist_id
WHERE AA.company_id = _companyid AND AA.is_active = true;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_actioncomment
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_actioncomment"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_actioncomment"("_companyid" int4, "_id" int4)
  RETURNS TABLE("action_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "id" int4, "image_0" varchar, "image_1" varchar, "image_2" varchar, "image_3" varchar, "image_4" varchar, "modified_at" timestamptz, "user_id" int4, "video" varchar, "video_thumbnail" varchar, "createdby" text) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
AC.action_id, 
AC.comment, 
AC.company_id, 
AC.created_at, 
AC.id, 
AC.image_0, 
AC.image_1, 
AC.image_2, 
AC.image_3, 
AC.image_4,
AC.modified_at, 
AC.user_id, 
AC.video, 
AC.video_thumbnail, 
CONCAT(PU.first_name, ' ', PU.last_name) AS createdby 
FROM actions_actioncomment AC 
INNER JOIN actions_action A ON A.id = AC.action_id AND A.is_active = true AND A.company_id = _companyid 
INNER JOIN profiles_user PU ON PU.id = AC.user_id 
WHERE AC.id = _id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_actioncomments
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_actioncomments"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_actioncomments"("_companyid" int4)
  RETURNS TABLE("action_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "id" int4, "image_0" varchar, "image_1" varchar, "image_2" varchar, "image_3" varchar, "image_4" varchar, "modified_at" timestamptz, "user_id" int4, "video" varchar, "video_thumbnail" varchar, "createdby" text) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
AC.action_id, 
AC.comment, 
AC.company_id, 
AC.created_at, 
AC.id, 
AC.image_0, 
AC.image_1, 
AC.image_2, 
AC.image_3, 
AC.image_4,
AC.modified_at, 
AC.user_id, 
AC.video, 
AC.video_thumbnail, 
CONCAT(PU.first_name, ' ', PU.last_name) AS createdby 
FROM actions_actioncomment AC 
INNER JOIN actions_action A ON A.id = AC.action_id AND A.is_active = true AND A.company_id = _companyid 
INNER JOIN profiles_user PU ON PU.id = AC.user_id 
WHERE AC.is_active = true 
ORDER BY AC.modified_at DESC, AC.created_at DESC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_actioncomments_by_action
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_actioncomments_by_action"("_companyid" int4, "_actionid" int4);
CREATE OR REPLACE FUNCTION "public"."get_actioncomments_by_action"("_companyid" int4, "_actionid" int4)
  RETURNS TABLE("action_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "id" int4, "image_0" varchar, "image_1" varchar, "image_2" varchar, "image_3" varchar, "image_4" varchar, "modified_at" timestamptz, "user_id" int4, "video" varchar, "video_thumbnail" varchar, "createdby" text) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
AC.action_id, 
AC.comment, 
AC.company_id, 
AC.created_at, 
AC.id, 
AC.image_0, 
AC.image_1, 
AC.image_2, 
AC.image_3, 
AC.image_4,
AC.modified_at, 
AC.user_id, 
AC.video, 
AC.video_thumbnail, 
CONCAT(PU.first_name, ' ', PU.last_name) AS createdby 
FROM actions_actioncomment AC 
INNER JOIN actions_action A ON A.id = AC.action_id AND A.is_active = true AND A.company_id = _companyid AND A.id = _actionid
INNER JOIN profiles_user PU ON PU.id = AC.user_id 
WHERE AC.is_active = true
ORDER BY AC.modified_at DESC, AC.created_at DESC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_actioncomments_viewed_statistics_with_user
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_actioncomments_viewed_statistics_with_user"("_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."get_actioncomments_viewed_statistics_with_user"("_companyid" int4, "_userid" int4)
  RETURNS TABLE("action_id" int4, "comment_count" int4, "comment_viewed_count" int4, "comment_unviewed_count" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT T.id AS action_id, T.comment_count::int, T.comment_viewed_count::int, (T.comment_count - T.comment_viewed_count)::int as comment_unviewed_count
FROM (
	SELECT AA.id, COUNT(AAC.id) AS comment_count,COUNT(AACV.comment_id) AS comment_viewed_count FROM actions_action AA 
	INNER JOIN actions_actioncomment AAC ON AAC.action_id = AA.id
	LEFT JOIN actions_actioncommentviewed AACV ON AACV.comment_id = AAC.id AND AACV.user_id = _userid
	WHERE AA.company_id = _companyid AND AAC.user_id <> _userid AND AA.is_active = true AND AAC.is_active = true
	GROUP BY AA.id
) AS T
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_actionids_by_area
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_actionids_by_area"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."get_actionids_by_area"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("action_id" int4, "area_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)	
	SELECT DISTINCT * FROM (
		-- direct area from tasktemplate
		SELECT DISTINCT AA.id AS action_id, TTT.area_id AS area_id FROM actions_action AA 
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = AA.task_template_id
		WHERE AA.company_id = _companyid AND TTT.area_id IS NOT NULL
		UNION
		-- direct area through recurrency of task template
		SELECT DISTINCT AA.id AS action_id, TTR.area_id AS area_id FROM actions_action AA 
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = AA.task_template_id
		INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
		WHERE AA.company_id = _companyid AND TTR.area_id IS NOT NULL 
		UNION
		-- area through task from task_templaterecurrency
		SELECT DISTINCT AA.id AS action_id, TTR.area_id AS area_id FROM actions_action AA 
		INNER JOIN tasks_task TT ON TT.id = AA.task_ID
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
		WHERE AA.company_id = _companyid AND TTR.area_id IS NOT NULL
		UNION
		-- area through task from task_template
		SELECT DISTINCT AA.id AS action_id, TTT.area_id AS area_id FROM actions_action AA 
		INNER JOIN tasks_task TT ON TT.id = AA.task_ID
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		WHERE AA.company_id = _companyid AND TTT.area_id IS NOT NULL
		UNION
		-- area through task , through checklist tasks, through checklist, from checklist template
		SELECT DISTINCT AA.id AS action_id, CCTT.area_id AS area_id FROM actions_action AA 
		INNER JOIN tasks_task TT ON TT.id = AA.task_ID
		INNER JOIN checklists_checklist_tasks CCT ON CCT.task_id = TT.id
		INNER JOIN checklists_checklist CC ON CC.id = CCT.checklist_id
		INNER JOIN checklists_checklisttemplate CCTT ON CCTT.id = CC.template_id
		WHERE AA.company_id = _companyid AND CCTT.area_id IS NOT NULL
		UNION
		-- area through tasktemplate, through checklist taskstemplates, through checklist, from checklist template
		SELECT DISTINCT AA.id AS action_id, CCTT.area_id AS area_id FROM actions_action AA 
		INNER JOIN tasks_task TT ON TT.id = AA.task_ID
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN checklists_checklisttemplate_tasks CCT ON CCT.tasktemplate_id = TTT.id
		INNER JOIN checklists_checklisttemplate CCTT ON CCTT.id = CCT.checklisttemplate_id 
		WHERE AA.company_id = _companyid AND CCTT.area_id IS NOT NULL
		UNION
		-- area through task , through audit tasks, through audit, from audit template
		SELECT DISTINCT AA.id AS action_id, CCTT.area_id AS area_id FROM actions_action AA 
		INNER JOIN tasks_task TT ON TT.id = AA.task_ID
		INNER JOIN audits_audit_tasks CCT ON CCT.task_id = TT.id
		INNER JOIN audits_audit CC ON CC.id = CCT.audit_id
		INNER JOIN audits_audittemplate CCTT ON CCTT.id = CC.template_id
		WHERE AA.company_id = _companyid AND CCTT.area_id IS NOT NULL
		UNION
		-- area through tasktemplate, through audit taskstemplates, through audit, from audut template
		SELECT DISTINCT AA.id AS action_id, CCTT.area_id AS area_id FROM actions_action AA 
		INNER JOIN tasks_task TT ON TT.id = AA.task_ID
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN audits_audittemplate_tasks CCT ON CCT.tasktemplate_id = TTT.id
		INNER JOIN audits_audittemplate CCTT ON CCTT.id = CCT.audittemplate_id 
		WHERE AA.company_id = _companyid AND CCTT.area_id IS NOT NULL
	) AS T
	WHERE (EXISTS (SELECT areas.id FROM areas WHERE areas.id = T.area_id) OR _areaid = 0)
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_actions
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_actions"("_companyid" int4, "_isresolved" bool, "_createdbyid" int4, "_timestamp" timestamp, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_actions"("_companyid" int4, "_isresolved" bool=NULL::boolean, "_createdbyid" int4=NULL::integer, "_timestamp" timestamp=NULL::timestamp without time zone, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("comment" text, "company_id" int4, "created_at" timestamptz, "created_by_id" int4, "description" text, "due_date" date, "id" int4, "image_0" varchar, "image_1" varchar, "image_2" varchar, "image_3" varchar, "image_4" varchar, "image_5" varchar, "is_resolved" bool, "modified_at" timestamptz, "resolved_at" timestamptz, "task_id" int4, "task_template_id" int4, "video_0" varchar, "video_1" varchar, "video_2" varchar, "video_3" varchar, "video_4" varchar, "video_5" varchar, "video_thumbnail_0" varchar, "video_thumbnail_1" varchar, "video_thumbnail_2" varchar, "video_thumbnail_3" varchar, "video_thumbnail_4" varchar, "video_thumbnail_5" varchar, "commentnr" int4, "createdby" text, "lastcommentdate" timestamptz) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	AA.comment, 
	AA.company_id, 
	AA.created_at, 
	AA.created_by_id,
	AA.description, 
	AA.due_date, 
	AA.id, 
	AA.image_0, 
	AA.image_1, 
	AA.image_2, 
	AA.image_3, 
	AA.image_4, 
	AA.image_5, 
	AA.is_resolved, 
	AA.modified_at, 
	AA.resolved_at, 
	AA.task_id, 
	AA.task_template_id, 
	AA.video_0, 
	AA.video_1, 
	AA.video_2, 
	AA.video_3, 
	AA.video_4, 
	AA.video_5, 
	AA.video_thumbnail_0, 
	AA.video_thumbnail_1, 
	AA.video_thumbnail_2,
	AA.video_thumbnail_3,
	AA.video_thumbnail_4,
	AA.video_thumbnail_5, 
	(SELECT Count(AAC.id)::int4 FROM actions_actioncomment AAC WHERE AAC.action_id = AA.id) AS commentnr, 
	CONCAT(PU.first_name, ' ', PU.last_name) AS createdby ,
	(SELECT AAC.modified_at::timestamptz FROM actions_actioncomment AAC WHERE AAC.action_id = AA.id ORDER BY modified_at DESC LIMIT 1) AS lastcommentdate
	FROM actions_action AA INNER JOIN profiles_user PU ON PU.id = AA.created_by_id 
	WHERE AA.company_id = _companyid AND AA.is_active = true
	AND (AA.created_by_id = _createdbyid OR _createdbyid IS NULL)
	AND (AA.is_resolved = _isresolved OR _isresolved IS NULL)
	AND (AA.created_at < _timestamp OR _timestamp IS NULL)
	ORDER BY AA.due_date DESC, AA.modified_at DESC, AA.created_at DESC, AA.id ASC
	LIMIT CASE WHEN (_limit > 0) THEN _limit END 
  OFFSET CASE WHEN (_offset > 0) THEN _offset END
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_actions_by_assignedarea
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_actions_by_assignedarea"("_companyid" int4, "_assignedareaid" int4, "_isresolved" bool, "_createdbyid" int4, "_timestamp" timestamp, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_actions_by_assignedarea"("_companyid" int4, "_assignedareaid" int4, "_isresolved" bool=NULL::boolean, "_createdbyid" int4=NULL::integer, "_timestamp" timestamp=NULL::timestamp without time zone, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("comment" text, "company_id" int4, "created_at" timestamptz, "created_by_id" int4, "description" text, "due_date" date, "id" int4, "image_0" varchar, "image_1" varchar, "image_2" varchar, "image_3" varchar, "image_4" varchar, "image_5" varchar, "is_resolved" bool, "modified_at" timestamptz, "resolved_at" timestamptz, "task_id" int4, "task_template_id" int4, "video_0" varchar, "video_1" varchar, "video_2" varchar, "video_3" varchar, "video_4" varchar, "video_5" varchar, "video_thumbnail_0" varchar, "video_thumbnail_1" varchar, "video_thumbnail_2" varchar, "video_thumbnail_3" varchar, "video_thumbnail_4" varchar, "video_thumbnail_5" varchar, "commentnr" int4, "createdby" text, "lastcommentdate" timestamptz) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	AA.comment, 
	AA.company_id, 
	AA.created_at, 
	AA.created_by_id,
	AA.description, 
	AA.due_date, 
	AA.id, 
	AA.image_0, 
	AA.image_1, 
	AA.image_2, 
	AA.image_3, 
	AA.image_4, 
	AA.image_5, 
	AA.is_resolved, 
	AA.modified_at, 
	AA.resolved_at, 
	AA.task_id, 
	AA.task_template_id, 
	AA.video_0, 
	AA.video_1, 
	AA.video_2, 
	AA.video_3, 
	AA.video_4, 
	AA.video_5, 
	AA.video_thumbnail_0, 
	AA.video_thumbnail_1, 
	AA.video_thumbnail_2,
	AA.video_thumbnail_3,
	AA.video_thumbnail_4,
	AA.video_thumbnail_5, 
	(SELECT Count(AAC.id)::int4 FROM actions_actioncomment AAC WHERE AAC.action_id = AA.id) AS commentnr, 
	CONCAT(PU.first_name, ' ', PU.last_name) AS createdby,
  (SELECT AAC.modified_at::timestamptz FROM actions_actioncomment AAC WHERE AAC.action_id = AA.id ORDER BY modified_at DESC LIMIT 1) AS lastcommentdate	
	FROM actions_action AA 
	INNER JOIN profiles_user PU ON PU.id = AA.created_by_id 
	INNER JOIN actions_action_assigned_areas AAU ON AAU.action_id = AA.id
	WHERE AA.company_id = _companyid AND AA.is_active = true AND AAU.area_id = _assignedareaid
	AND (AA.created_by_id = _createdbyid OR _createdbyid IS NULL)
	AND (AA.is_resolved = _isresolved OR _isresolved IS NULL)
	AND (AA.created_at < _timestamp OR _timestamp IS NULL)
	ORDER BY AA.modified_at DESC, AA.created_at DESC
	LIMIT CASE WHEN (_limit > 0) THEN _limit END 
  OFFSET CASE WHEN (_offset > 0) THEN _offset END;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_actions_by_assigneduser
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_actions_by_assigneduser"("_companyid" int4, "_assigneduserid" int4, "_isresolved" bool, "_createdbyid" int4, "_timestamp" timestamp, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_actions_by_assigneduser"("_companyid" int4, "_assigneduserid" int4, "_isresolved" bool=NULL::boolean, "_createdbyid" int4=NULL::integer, "_timestamp" timestamp=NULL::timestamp without time zone, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("comment" text, "company_id" int4, "created_at" timestamptz, "created_by_id" int4, "description" text, "due_date" date, "id" int4, "image_0" varchar, "image_1" varchar, "image_2" varchar, "image_3" varchar, "image_4" varchar, "image_5" varchar, "is_resolved" bool, "modified_at" timestamptz, "resolved_at" timestamptz, "task_id" int4, "task_template_id" int4, "video_0" varchar, "video_1" varchar, "video_2" varchar, "video_3" varchar, "video_4" varchar, "video_5" varchar, "video_thumbnail_0" varchar, "video_thumbnail_1" varchar, "video_thumbnail_2" varchar, "video_thumbnail_3" varchar, "video_thumbnail_4" varchar, "video_thumbnail_5" varchar, "commentnr" int4, "createdby" text, "lastcommentdate" timestamptz) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	AA.comment, 
	AA.company_id, 
	AA.created_at, 
	AA.created_by_id,
	AA.description, 
	AA.due_date, 
	AA.id, 
	AA.image_0, 
	AA.image_1, 
	AA.image_2, 
	AA.image_3, 
	AA.image_4, 
	AA.image_5, 
	AA.is_resolved, 
	AA.modified_at, 
	AA.resolved_at, 
	AA.task_id, 
	AA.task_template_id, 
	AA.video_0, 
	AA.video_1, 
	AA.video_2, 
	AA.video_3, 
	AA.video_4, 
	AA.video_5, 
	AA.video_thumbnail_0, 
	AA.video_thumbnail_1, 
	AA.video_thumbnail_2,
	AA.video_thumbnail_3,
	AA.video_thumbnail_4,
	AA.video_thumbnail_5, 
	(SELECT Count(AAC.id)::int4 FROM actions_actioncomment AAC WHERE AAC.action_id = AA.id) AS commentnr, 
	CONCAT(PU.first_name, ' ', PU.last_name) AS createdby,
  (SELECT AAC.modified_at::timestamptz FROM actions_actioncomment AAC WHERE AAC.action_id = AA.id ORDER BY modified_at DESC LIMIT 1) AS lastcommentdate	
	FROM actions_action AA 
	INNER JOIN profiles_user PU ON PU.id = AA.created_by_id 
	INNER JOIN actions_action_assigned_users AAU ON AAU.action_id = AA.id
	WHERE AA.company_id = _companyid AND AA.is_active = true AND AAU.user_id = _assigneduserid
	AND (AA.created_by_id = _createdbyid OR _createdbyid IS NULL)
	AND (AA.is_resolved = _isresolved OR _isresolved IS NULL)
	AND (AA.created_at < _timestamp OR _timestamp IS NULL)
	ORDER BY AA.modified_at DESC, AA.created_at DESC
	LIMIT CASE WHEN (_limit > 0) THEN _limit END 
  OFFSET CASE WHEN (_offset > 0) THEN _offset END;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_actions_by_assigneduser_and_assignedarea
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_actions_by_assigneduser_and_assignedarea"("_companyid" int4, "_assigneduserid" int4, "_assignedareaid" int4, "_isresolved" bool, "_createdbyid" int4, "_timestamp" timestamp, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_actions_by_assigneduser_and_assignedarea"("_companyid" int4, "_assigneduserid" int4, "_assignedareaid" int4, "_isresolved" bool=NULL::boolean, "_createdbyid" int4=NULL::integer, "_timestamp" timestamp=NULL::timestamp without time zone, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("comment" text, "company_id" int4, "created_at" timestamptz, "created_by_id" int4, "description" text, "due_date" date, "id" int4, "image_0" varchar, "image_1" varchar, "image_2" varchar, "image_3" varchar, "image_4" varchar, "image_5" varchar, "is_resolved" bool, "modified_at" timestamptz, "resolved_at" timestamptz, "task_id" int4, "task_template_id" int4, "video_0" varchar, "video_1" varchar, "video_2" varchar, "video_3" varchar, "video_4" varchar, "video_5" varchar, "video_thumbnail_0" varchar, "video_thumbnail_1" varchar, "video_thumbnail_2" varchar, "video_thumbnail_3" varchar, "video_thumbnail_4" varchar, "video_thumbnail_5" varchar, "commentnr" int4, "createdby" text, "lastcommentdate" timestamptz) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	AA.comment, 
	AA.company_id, 
	AA.created_at, 
	AA.created_by_id,
	AA.description, 
	AA.due_date, 
	AA.id, 
	AA.image_0, 
	AA.image_1, 
	AA.image_2, 
	AA.image_3, 
	AA.image_4, 
	AA.image_5, 
	AA.is_resolved, 
	AA.modified_at, 
	AA.resolved_at, 
	AA.task_id, 
	AA.task_template_id, 
	AA.video_0, 
	AA.video_1, 
	AA.video_2, 
	AA.video_3, 
	AA.video_4, 
	AA.video_5, 
	AA.video_thumbnail_0, 
	AA.video_thumbnail_1, 
	AA.video_thumbnail_2,
	AA.video_thumbnail_3,
	AA.video_thumbnail_4,
	AA.video_thumbnail_5, 
	(SELECT Count(AAC.id)::int4 FROM actions_actioncomment AAC WHERE AAC.action_id = AA.id) AS commentnr, 
	CONCAT(PU.first_name, ' ', PU.last_name) AS createdby,
  (SELECT AAC.modified_at::timestamptz FROM actions_actioncomment AAC WHERE AAC.action_id = AA.id ORDER BY modified_at DESC LIMIT 1) AS lastcommentdate	
	FROM actions_action AA 
	INNER JOIN profiles_user PU ON PU.id = AA.created_by_id 
	INNER JOIN actions_action_assigned_users AAU ON AAU.action_id = AA.id
	INNER JOIN actions_action_assigned_areas AAA ON AAA.action_id = AA.id
	WHERE AA.company_id = _companyid AND AA.is_active = true AND AAU.user_id = _assigneduserid AND AAA.area_id = _assignedareaid
	AND (AA.created_by_id = _createdbyid OR _createdbyid IS NULL)
	AND (AA.is_resolved = _isresolved OR _isresolved IS NULL)
	AND (AA.created_at < _timestamp OR _timestamp IS NULL)
	ORDER BY AA.modified_at DESC, AA.created_at DESC
	LIMIT CASE WHEN (_limit > 0) THEN _limit END 
  OFFSET CASE WHEN (_offset > 0) THEN _offset END;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_actions_by_task
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_actions_by_task"("_companyid" int4, "_taskid" int4);
CREATE OR REPLACE FUNCTION "public"."get_actions_by_task"("_companyid" int4, "_taskid" int4)
  RETURNS TABLE("comment" text, "company_id" int4, "created_at" timestamptz, "created_by_id" int4, "description" text, "due_date" date, "id" int4, "image_0" varchar, "image_1" varchar, "image_2" varchar, "image_3" varchar, "image_4" varchar, "image_5" varchar, "is_resolved" bool, "modified_at" timestamptz, "resolved_at" timestamptz, "task_id" int4, "task_template_id" int4, "video_0" varchar, "video_1" varchar, "video_2" varchar, "video_3" varchar, "video_4" varchar, "video_5" varchar, "video_thumbnail_0" varchar, "video_thumbnail_1" varchar, "video_thumbnail_2" varchar, "video_thumbnail_3" varchar, "video_thumbnail_4" varchar, "video_thumbnail_5" varchar, "commentnr" int4, "createdby" text, "lastcommentdate" timestamptz) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	AA.comment, 
	AA.company_id, 
	AA.created_at, 
	AA.created_by_id,
	AA.description, 
	AA.due_date, 
	AA.id, 
	AA.image_0, 
	AA.image_1, 
	AA.image_2, 
	AA.image_3, 
	AA.image_4, 
	AA.image_5, 
	AA.is_resolved, 
	AA.modified_at, 
	AA.resolved_at, 
	AA.task_id, 
	AA.task_template_id, 
	AA.video_0, 
	AA.video_1, 
	AA.video_2, 
	AA.video_3, 
	AA.video_4, 
	AA.video_5, 
	AA.video_thumbnail_0, 
	AA.video_thumbnail_1, 
	AA.video_thumbnail_2,
	AA.video_thumbnail_3,
	AA.video_thumbnail_4,
	AA.video_thumbnail_5, 
	(SELECT Count(AAC.id)::int4 FROM actions_actioncomment AAC WHERE AAC.action_id = AA.id) AS commentnr, 
	CONCAT(PU.first_name, ' ', PU.last_name) AS createdby,
  (SELECT AAC.modified_at::timestamptz FROM actions_actioncomment AAC WHERE AAC.action_id = AA.id ORDER BY modified_at DESC LIMIT 1) AS lastcommentdate	
	FROM actions_action AA INNER JOIN profiles_user PU ON PU.id = AA.created_by_id 
	WHERE AA.company_id = _companyid AND AA.is_active = true
	AND AA.task_id = _taskid
	ORDER BY AA.modified_at DESC, AA.created_at DESC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_actions_by_tasktemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_actions_by_tasktemplate"("_companyid" int4, "_tasktemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."get_actions_by_tasktemplate"("_companyid" int4, "_tasktemplateid" int4)
  RETURNS TABLE("comment" text, "company_id" int4, "created_at" timestamptz, "created_by_id" int4, "description" text, "due_date" date, "id" int4, "image_0" varchar, "image_1" varchar, "image_2" varchar, "image_3" varchar, "image_4" varchar, "image_5" varchar, "is_resolved" bool, "modified_at" timestamptz, "resolved_at" timestamptz, "task_id" int4, "task_template_id" int4, "video_0" varchar, "video_1" varchar, "video_2" varchar, "video_3" varchar, "video_4" varchar, "video_5" varchar, "video_thumbnail_0" varchar, "video_thumbnail_1" varchar, "video_thumbnail_2" varchar, "video_thumbnail_3" varchar, "video_thumbnail_4" varchar, "video_thumbnail_5" varchar, "commentnr" int4, "createdby" text, "lastcommentdate" timestamptz) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	AA.comment, 
	AA.company_id, 
	AA.created_at, 
	AA.created_by_id,
	AA.description, 
	AA.due_date, 
	AA.id, 
	AA.image_0, 
	AA.image_1, 
	AA.image_2, 
	AA.image_3, 
	AA.image_4, 
	AA.image_5, 
	AA.is_resolved, 
	AA.modified_at, 
	AA.resolved_at, 
	AA.task_id, 
	AA.task_template_id, 
	AA.video_0, 
	AA.video_1, 
	AA.video_2, 
	AA.video_3, 
	AA.video_4, 
	AA.video_5, 
	AA.video_thumbnail_0, 
	AA.video_thumbnail_1, 
	AA.video_thumbnail_2,
	AA.video_thumbnail_3,
	AA.video_thumbnail_4,
	AA.video_thumbnail_5, 
	(SELECT Count(AAC.id)::int4 FROM actions_actioncomment AAC WHERE AAC.action_id = AA.id) AS commentnr, 
	CONCAT(PU.first_name, ' ', PU.last_name) AS createdby,
  (SELECT AAC.modified_at::timestamptz FROM actions_actioncomment AAC WHERE AAC.action_id = AA.id ORDER BY modified_at DESC LIMIT 1) AS lastcommentdate	
	FROM actions_action AA INNER JOIN profiles_user PU ON PU.id = AA.created_by_id 
	WHERE AA.company_id = _companyid AND AA.is_active = true
	AND AA.task_template_id = _tasktemplateid
	ORDER BY AA.modified_at DESC, AA.created_at DESC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_allowedareaids_by_user
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_allowedareaids_by_user"("_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."get_allowedareaids_by_user"("_companyid" int4, "_userid" int4)
  RETURNS TABLE("area_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	AA.area_id
	FROM profiles_user_allowed_areas AA 
	INNER JOIN companies_area CA ON CA.id = AA.area_id AND CA.is_active = true
	WHERE CA.company_id = _companyid AND AA.user_id = _userid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_alloweddisplayareaids_by_user
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_alloweddisplayareaids_by_user"("_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."get_alloweddisplayareaids_by_user"("_companyid" int4, "_userid" int4)
  RETURNS TABLE("area_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT AA.area_id
	FROM profiles_user_areas AA 
	INNER JOIN companies_area CA ON CA.id = AA.area_id AND CA.is_active = true
	WHERE CA.company_id = _companyid AND AA.user_id = _userid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_announcements
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_announcements"("_companyid" int4, "_limit" int4, "_offset" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_announcements"("_companyid" int4, "_limit" int4=0, "_offset" int4=0, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("id" int4, "title" varchar, "description" text, "announcement_date" timestamptz, "created_on" timestamptz, "announcement_type" int4) AS $BODY$BEGIN
	RETURN QUERY
SELECT AA."id", AA."title", AA."description", AA."announcement_date", AA."created_on", AA."announcement_type" 
FROM announcement AA
WHERE (AA.announcement_date >= get_timestamp_without_companytimezone(_companyid ,_starttimestamp) OR _starttimestamp IS NULL)
AND (AA.announcement_date <= get_timestamp_without_companytimezone(_companyid ,_endtimestamp) OR _endtimestamp IS NULL)
ORDER BY AA.announcement_date DESC, AA.created_on DESC
LIMIT CASE WHEN (_limit > 0) THEN _limit END 
OFFSET CASE WHEN (_offset > 0) THEN _offset END
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_area
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_area"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_area"("_companyid" int4, "_id" int4)
  RETURNS TABLE("company_id" int4, "description" text, "id" int4, "level" int4, "name" varchar, "parent_id" int4, "picture" varchar, "tree_id" int4, "FullDisplayName" text) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
CA.company_id, 
CA.description, 
CA.id, 
CA.level, 
CA.name, 
CA.parent_id, 
CA.picture, 
CA.tree_id, 
get_task_area_full(CA.id) AS FullDisplayName 
FROM companies_area CA
WHERE CA.company_id = _companyid AND CA.id = _id
ORDER BY CA.level, CA.parent_id, CA.tree_id, CA.name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_area_full_path
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_area_full_path"("area_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_area_full_path"("area_id" int4)
  RETURNS "pg_catalog"."text" AS $BODY$
WITH RECURSIVE Areas AS (
   SELECT id,name,parent_id, level
   FROM companies_area
   WHERE id = area_id
   UNION
   SELECT e.id,e.name,e.parent_id, e.level
   FROM companies_area e
   INNER JOIN Areas s ON s.parent_id = e.id
) 
SELECT string_agg(name, ' -> ') AS area FROM (
	SELECT id,name,parent_id, level
	FROM Areas
	ORDER BY Level
) AS T;
$BODY$
  LANGUAGE sql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for get_area_full_path_ids
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_area_full_path_ids"("area_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_area_full_path_ids"("area_id" int4)
  RETURNS "pg_catalog"."text" AS $BODY$
WITH RECURSIVE Areas AS (
   SELECT id,name,parent_id, level
   FROM companies_area
   WHERE id = area_id
   UNION
   SELECT e.id,e.name,e.parent_id, e.level
   FROM companies_area e
   INNER JOIN Areas s ON s.parent_id = e.id
) 
SELECT string_agg(id::varchar, ' -> ') AS area FROM (
	SELECT id,name,parent_id, level
	FROM Areas
	ORDER BY Level
) AS T;
$BODY$
  LANGUAGE sql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for get_area_has_active_relations
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_area_has_active_relations"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_area_has_active_relations"("_companyid" int4, "_id" int4)
  RETURNS TABLE("id" int4, "name" varchar, "has_active_tasktemplates" bool, "has_active_actions" bool, "has_active_checklisttemplates" bool, "has_active_audittemplates" bool, "has_active_shifts" bool, "has_active_children" bool) AS $BODY$BEGIN
	RETURN QUERY
	SELECT CA.id, CA.name,
	(SELECT (COUNT(*) > 0)::bool FROM tasks_tasktemplate TTT 
	 INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	 WHERE (CA.id = TTT.area_id OR CA.id = TTR.area_id) AND TTT.is_active = true AND TTT.type = 'task' LIMIT 1) AS has_active_tasktemplates,
	(SELECT (COUNT(*) > 0)::bool FROM actions_action_assigned_areas AAAA
	 INNER JOIN actions_action AA ON AA.id = AAAA.action_id
	 WHERE CA.id = AAAA.area_id AND AA.is_active = true LIMIT 1) AS has_active_actions,
	(SELECT (COUNT(*) > 0)::bool FROM checklists_checklisttemplate CCT WHERE CA.id = CCT.area_id  AND CCT.is_active = true LIMIT 1) AS has_active_checklisttemplates,
	(SELECT (COUNT(*) > 0)::bool FROM audits_audittemplate AAT WHERE CA.id = AAT.area_id AND AAT.is_active = true LIMIT 1) AS has_active_audittemplates,
	(SELECT (COUNT(*) > 0)::bool FROM companies_shift CS WHERE CA.id = CS.area_id AND CS.is_active = true LIMIT 1) AS has_active_shifts,
	(SELECT (COUNT(*) > 0)::bool FROM companies_area CAA WHERE CA.id = CAA.parent_id AND CAA.is_active = true LIMIT 1) AS has_active_children
	FROM companies_area CA
	WHERE company_id = _companyid AND CA.is_active = true AND CA.id = _id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_area_has_inactive_parents
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_area_has_inactive_parents"("area_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_area_has_inactive_parents"("area_id" int4)
  RETURNS "pg_catalog"."bool" AS $BODY$
WITH RECURSIVE Areas AS (
   SELECT id,parent_id, is_active
   FROM companies_area
   WHERE id = area_id
   UNION
   SELECT e.id,e.parent_id, e.is_active
   FROM companies_area e
   INNER JOIN Areas s ON s.parent_id = e.id
) 
SELECT (COUNT(*) > 0)::bool FROM Areas A WHERE A.is_active = false;
$BODY$
  LANGUAGE sql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for get_area_nodes_from_leaf_to_root
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_area_nodes_from_leaf_to_root"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_area_nodes_from_leaf_to_root"("_companyid" int4, "_id" int4)
  RETURNS TABLE("id" int4, "name" varchar, "parent_id" int4) AS $BODY$
BEGIN
RETURN QUERY WITH RECURSIVE Areas AS (
   SELECT
      a.id,a.name,a.parent_id, a.company_id
   FROM
      companies_area a
   WHERE
      a.id = _id
   UNION
      SELECT
         e.id,e.name,e.parent_id, e.company_id
      FROM
         companies_area e
      INNER JOIN Areas s ON s.parent_id = e.id
) SELECT
   ae.id, ae.name, ae.parent_id
FROM
   Areas ae
 WHERE ae.company_id = _companyid;
   
END; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_area_nodes_from_root_to_leaf
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_area_nodes_from_root_to_leaf"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_area_nodes_from_root_to_leaf"("_companyid" int4, "_id" int4)
  RETURNS TABLE("id" int4, "name" varchar, "parent_id" int4) AS $BODY$
BEGIN
RETURN QUERY WITH RECURSIVE Areas AS (
   SELECT
      a.id,a.name,a.parent_id, a.company_id
   FROM
      companies_area a
   WHERE
      a.id = _id
   UNION
      SELECT
         e.id,e.name,e.parent_id, e.company_id
      FROM
         companies_area e
      INNER JOIN Areas s ON e.parent_id = s.id
) SELECT
   ae.id, ae.name, ae.parent_id
FROM
   Areas ae
	 WHERE ae.company_id = _companyid;
   
END; $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_area_nr_active_relations
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_area_nr_active_relations"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_area_nr_active_relations"("_companyid" int4, "_id" int4)
  RETURNS TABLE("id" int4, "name" varchar, "nr_active_tasktemplates" int4, "nr_active_actions" int4, "nr_active_checklisttemplates" int4, "nr_active_audittemplates" int4, "nr_active_shifts" int4, "nr_active_children" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT CA.id, CA.name,
	(SELECT COUNT(*)::int4  FROM tasks_tasktemplate TTT 
	 INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	 WHERE (CA.id = TTT.area_id OR CA.id = TTR.area_id) AND TTT.is_active = true AND TTT.type = 'task' LIMIT 1) AS nr_active_tasktemplates,
	(SELECT COUNT(*)::int4 FROM actions_action_assigned_areas AAAA
	 INNER JOIN actions_action AA ON AA.id = AAAA.action_id
	 WHERE CA.id = AAAA.area_id AND AA.is_active = true LIMIT 1) AS nr_active_actions,
	(SELECT COUNT(*)::int4 FROM checklists_checklisttemplate CCT WHERE CA.id = CCT.area_id  AND CCT.is_active = true LIMIT 1) AS nr_active_checklisttemplates,
	(SELECT COUNT(*)::int4 FROM audits_audittemplate AAT WHERE CA.id = AAT.area_id AND AAT.is_active = true LIMIT 1) AS nr_active_audittemplates,
	(SELECT COUNT(*)::int4 FROM companies_shift CS WHERE CA.id = CS.area_id AND CS.is_active = true LIMIT 1) AS nr_active_shifts,
	(SELECT COUNT(*)::int4 FROM companies_area CAA WHERE CA.id = CAA.parent_id AND CAA.is_active = true LIMIT 1) AS nr_active_children
	FROM companies_area CA
	WHERE company_id = _companyid AND CA.is_active = true AND CA.id = _id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_areas
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_areas"("_companyid" int4, "_maxlevel" int4);
CREATE OR REPLACE FUNCTION "public"."get_areas"("_companyid" int4, "_maxlevel" int4)
  RETURNS TABLE("company_id" int4, "description" text, "id" int4, "level" int4, "name" varchar, "parent_id" int4, "picture" varchar, "tree_id" int4, "FullDisplayName" text, "fulldisplayids" text) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 	
	T.company_id, 
	T.description, 
	T.id, 
	T.level, 
	T.name, 
	T.parent_id, 
	T.picture, 
	T.tree_id, 
	T.FullDisplayName,
	T.fulldisplayids FROM (
		SELECT 
			CA.company_id, 
			CA.description, 
			CA.id, 
			CA.level, 
			CA.name, 
			CA.parent_id, 
			CA.picture, 
			CA.tree_id, 
			get_task_area_full(CA.id) AS FullDisplayName,
			get_area_full_path_ids(CA.id) AS fulldisplayids,
			get_area_has_inactive_parents(CA.id) AS hasinactiveparents
		FROM companies_area CA
		WHERE CA.company_id = _companyid AND CA.is_system = false AND CA.is_active = true AND CA.level < _maxlevel
		ORDER BY CA.level, CA.parent_id, CA.tree_id, CA.name
	) AS T WHERE hasinactiveparents = false
ORDER BY T.level, T.parent_id, T.tree_id, T.name;	
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_assignedareaids_by_action
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_assignedareaids_by_action"("_companyid" int4, "_actionid" int4);
CREATE OR REPLACE FUNCTION "public"."get_assignedareaids_by_action"("_companyid" int4, "_actionid" int4)
  RETURNS TABLE("user_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	AA.area_id
	FROM actions_action_assigned_areas AA 
	INNER JOIN actions_action A ON A.id = AA.action_id
	INNER JOIN companies_area CA ON CA.id = AA.area_id AND CA.is_active = true
	WHERE CA.company_id = _companyid AND AA.action_id = _actionid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_assignedareaids_with_actions
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_assignedareaids_with_actions"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_assignedareaids_with_actions"("_companyid" int4)
  RETURNS TABLE("action_id" int4, "area_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	AA.action_id,
	AA.area_id
	FROM actions_action_assigned_areas AA 
	INNER JOIN companies_area CA ON CA.id = AA.area_id AND CA.is_active = true
	WHERE CA.company_id = _companyid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_assigneduserids_by_action
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_assigneduserids_by_action"("_companyid" int4, "_actionid" int4);
CREATE OR REPLACE FUNCTION "public"."get_assigneduserids_by_action"("_companyid" int4, "_actionid" int4)
  RETURNS TABLE("user_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	AA.user_id
	FROM actions_action_assigned_users AA 
	INNER JOIN profiles_user PU ON PU.id = AA.user_id AND PU.is_active = true
	WHERE PU.company_id = _companyid AND AA.action_id = _actionid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_assigneduserids_with_actions
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_assigneduserids_with_actions"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_assigneduserids_with_actions"("_companyid" int4)
  RETURNS TABLE("action_id" int4, "user_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	AA.action_id,
	AA.user_id
	FROM actions_action_assigned_users AA 
	INNER JOIN profiles_user PU ON PU.id = AA.user_id AND PU.is_active = true
	WHERE PU.company_id = _companyid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_audit
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_audit"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_audit"("_companyid" int4, "_id" int4)
  RETURNS TABLE("area_id" int4, "company_id" int4, "created_at" timestamptz, "description" text, "double_signature_required" bool, "id" int4, "is_complete" bool, "modified_at" timestamptz, "name" varchar, "picture" varchar, "score_type" varchar, "signature_1" varchar, "signature_2" varchar, "signature_required" bool, "signed_at_1" timestamptz, "signed_at_2" timestamptz, "signed_by_1_id" int4, "signed_by_2_id" int4, "signed_by_1" varchar, "signed_by_2" varchar, "template_id" int4, "total_score" int2, "min_task_score" int4, "max_task_score" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
AAT.area_id, 
AA.company_id, 
AA.created_at, 
AAT.description, 
AAT.double_signature_required, 
AA.id, 
AA.is_complete, 
AA.modified_at, 
AAT.name, 
AAT.picture, 
AAT.score_type, 
AA.signature_1, 
AA.signature_2, 
AAT.signature_required, 
AA.signed_at_1, 
AA.signed_at_2, 
AA.signed_by_1_id, 
0::int4 AS signed_by_2_id,
CONCAT(PU.first_name, ' ', PU.last_name)::varchar AS signed_by_1,
AA.signed_by_2, 
AA.template_id, 
AA.total_score,
AAT.min_task_score,
AAT.max_task_score
FROM audits_audit AA 
INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id AND AA.company_id = AAT.company_id AND AAT.is_active = true 
LEFT JOIN profiles_user PU ON PU.id = AA.signed_by_1_id
WHERE AA.company_id = _companyid AND AA.is_active = true AND AA.id = _id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_audits
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_audits"("_companyid" int4, "_iscomplete" bool, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4, "_timespanindays" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_audits"("_companyid" int4, "_iscomplete" bool=NULL::boolean, "_timestamp" timestamp=NULL::timestamp without time zone, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0, "_timespanindays" int4=0, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("area_id" int4, "company_id" int4, "created_at" timestamptz, "description" text, "double_signature_required" bool, "id" int4, "is_complete" bool, "modified_at" timestamptz, "name" varchar, "picture" varchar, "score_type" varchar, "signature_1" varchar, "signature_2" varchar, "signature_required" bool, "signed_at_1" timestamptz, "signed_at_2" timestamptz, "signed_by_1_id" int4, "signed_by_2_id" int4, "signed_by_1" varchar, "signed_by_2" varchar, "template_id" int4, "total_score" int2, "min_task_score" int4, "max_task_score" int4) AS $BODY$
	BEGIN
	RETURN QUERY
	SELECT 
AAT.area_id, 
AA.company_id, 
AA.created_at, 
AAT.description, 
AAT.double_signature_required, 
AA.id, 
AA.is_complete, 
AA.modified_at, 
AAT.name, 
AAT.picture, 
AAT.score_type, 
AA.signature_1, 
AA.signature_2, 
AAT.signature_required, 
AA.signed_at_1, 
AA.signed_at_2, 
AA.signed_by_1_id,
0::int4 AS signed_by_2_id,
CONCAT(PU.first_name, ' ', PU.last_name)::varchar AS signed_by_1,
AA.signed_by_2, 
AA.template_id, 
AA.total_score,
AAT.min_task_score,
AAT.max_task_score
FROM audits_audit AA 
INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id AND AA.company_id = AAT.company_id AND AAT.is_active = true 
LEFT JOIN profiles_user PU ON PU.id = AA.signed_by_1_id
WHERE AA.company_id = _companyid AND AA.is_active = true
AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = AAT.area_id) OR _areaid= 0) 
AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_audittemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = AAT.id) OR _userid = 0) 
AND (AA.signed_at_1::timestamp < get_timestamp_without_companytimezone(_companyid ,_timestamp) OR _timestamp IS NULL)
AND (AA.signed_at_1 >= get_timestamp_without_companytimezone(_companyid ,_starttimestamp) OR _starttimestamp IS NULL)
AND (AA.signed_at_1 <= get_timestamp_without_companytimezone(_companyid ,_endtimestamp) OR _endtimestamp IS NULL)
AND (AA.created_at > (NOW()::date - CONCAT(_timespanindays,' days')::interval) OR _timespanindays = 0) -- note when partial items can be submitted, this must change
AND (AA.is_complete = _iscomplete OR _iscomplete IS NULL)
ORDER BY AA.signed_at_1 DESC, AAT.name, AA.id
LIMIT CASE WHEN (_limit > 0) THEN _limit END 
OFFSET CASE WHEN (_offset > 0) THEN _offset END
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_audits_properties
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_audits_properties"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_audits_properties"("_companyid" int4)
  RETURNS TABLE("id" int4, "company_id" int4, "audit_id" int4, "property_id" int4, "template_property_id" int4, "user_id" int4, "value_int" int4, "value_string" text, "value_decimal" numeric, "value_time" time, "value_date" timestamp, "value_bool" bool, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
		SELECT 
		TP.id, 
		TP.company_id, 
		TP.audit_id, 
		TP.property_id, 
		TP.template_property_id, 
		TP.user_id, 
		TP.value_int, 
		TP.value_string, 
		TP.value_decimal, 
		TP.value_time, 
		TP.value_date, 
		TP.value_bool, 
		TP.created_at, 
		TP.modified_at
		FROM audits_properties TP
		WHERE TP.company_id = _companyid
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_audittemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_audittemplate"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_audittemplate"("_companyid" int4, "_id" int4)
  RETURNS TABLE("area_id" int4, "company_id" int4, "description" text, "double_signature_required" bool, "id" int4, "max_task_score" int4, "min_task_score" int4, "name" varchar, "picture" varchar, "role" varchar, "score_type" varchar, "signature_required" bool, "has_incomplete_audits" bool, "score" int2, "has_derived_items" bool) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
AA.area_id, 
AA.company_id, 
AA.description, 
AA.double_signature_required, 
AA.id, 
AA.max_task_score, 
AA.min_task_score, 
AA.name, 
AA.picture, 
AA.role, 
AA.score_type, 
AA.signature_required,
((SELECT COUNT(A.id) FROM audits_audit A WHERE A.is_complete = false AND AA.id = A.template_id) > 0) AS has_incomplete_audits,
(SELECT A.total_score FROM audits_audit A WHERE A.is_complete = true AND A.is_active = true AND A.template_id = AA.id ORDER BY A.signed_at_1 DESC LIMIT 1) AS score,
(SELECT (COUNT(A.id) > 0)::bool FROM audits_audit A WHERE AA.id = A.template_id)AS has_derived_items
FROM audits_audittemplate AA WHERE AA.company_id = _companyid AND AA.id = _id AND AA.is_active = true;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_audittemplate_properties
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_audittemplate_properties"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_audittemplate_properties"("_companyid" int4)
  RETURNS TABLE("id" int4, "company_id" int4, "audittemplate_id" int4, "property_id" int4, "propertyvalue_id" int4, "primary_int_value" int4, "secondary_int_value" int4, "primary_decimal_value" numeric, "secondary_decimal_value" numeric, "primary_string_value" text, "secondary_string_value" text, "bool_value" bool, "custom_value_type_display" varchar, "custom_title_display" varchar, "is_required" bool, "index" int4) AS $BODY$BEGIN
	RETURN QUERY
SELECT 
ATP.id, 
ATP.company_id, 
ATP.audittemplate_id, 
ATP.property_id, 
ATP.propertyvalue_id, 
ATP.primary_int_value, 
ATP.secondary_int_value, 
ATP.primary_decimal_value, 
ATP.secondary_decimal_value, 
ATP.primary_string_value, 
ATP.secondary_string_value, 
ATP.bool_value, 
ATP.custom_value_type_display, 
ATP.custom_title_display, 
ATP.is_required, 
ATP.index
FROM audits_audittemplate_properties ATP
WHERE ATP.company_id = _companyid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_audittemplates
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_audittemplates"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_audittemplates"("_companyid" int4, "_timestamp" timestamp=NULL::timestamp without time zone, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("area_id" int4, "company_id" int4, "description" text, "double_signature_required" bool, "id" int4, "max_task_score" int4, "min_task_score" int4, "name" varchar, "picture" varchar, "role" varchar, "score_type" varchar, "score" int2, "signature_required" bool, "has_derived_items" bool) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
AA.area_id, 
AA.company_id, 
AA.description, 
AA.double_signature_required, 
AA.id, 
AA.max_task_score, 
AA.min_task_score, 
AA.name, 
AA.picture, 
AA.role, 
AA.score_type, 
(SELECT A.total_score FROM audits_audit A WHERE A.is_complete = true AND A.is_active = true AND A.template_id = AA.id ORDER BY A.signed_at_1 DESC LIMIT 1) AS score,
AA.signature_required,
(SELECT (COUNT(A.id) > 0)::bool FROM audits_audit A WHERE AA.id = A.template_id) AS has_derived_items
FROM audits_audittemplate AA 
WHERE AA.company_id = _companyid AND is_active = true
AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = AA.area_id) OR _areaid= 0) 
AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_audittemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = AA.id) OR _userid = 0) 
AND (AA.modified_at < _timestamp OR _timestamp IS NULL)
ORDER BY AA.Name ASC, AA.id
LIMIT CASE WHEN (_limit > 0) THEN _limit END 
OFFSET CASE WHEN (_offset > 0) THEN _offset END;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_checklist
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_checklist"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_checklist"("_companyid" int4, "_id" int4)
  RETURNS TABLE("area_id" int4, "company_id" int4, "created_at" timestamptz, "description" text, "double_signature_required" bool, "signature_required" bool, "id" int4, "is_complete" bool, "modified_at" timestamptz, "name" varchar, "picture" varchar, "signature_1" varchar, "signature_2" varchar, "signed_at_1" timestamptz, "signed_at_2" timestamptz, "signed_by_1_id" int4, "signed_by_2_id" int4, "signed_by_1" varchar, "signed_by_2" varchar, "template_id" int4) AS $BODY$BEGIN
	RETURN QUERY
SELECT 
CCT.area_id, 
CC.company_id, 
CC.created_at, 
CCT.description, 
CCT.double_signature_required, 
CCT.signature_required,
CC.id, 
CC.is_complete, 
CC.modified_at, 
CCT.name, 
CCT.picture, 
CC.signature_1, 
CC.signature_2, 
CC.signed_at_1, 
CC.signed_at_2, 
CC.signed_by_1_id,
0::int4 AS signed_by_2_id,
CONCAT(PU.first_name, ' ', PU.last_name)::varchar AS signed_by_1,
CC.signed_by_2, 
CC.template_id
FROM checklists_checklist CC 
INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id AND CC.company_id = CCT.company_id AND CCT.is_active = true 
LEFT JOIN profiles_user PU ON PU.id = CC.signed_by_1_id
WHERE CC.is_active = true AND CC.company_id = _companyid AND CC.id = _id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_checklists
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_checklists"("_companyid" int4, "_iscomplete" bool, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4, "_timespanindays" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_checklists"("_companyid" int4, "_iscomplete" bool=NULL::boolean, "_timestamp" timestamp=NULL::timestamp without time zone, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0, "_timespanindays" int4=0, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("area_id" int4, "company_id" int4, "created_at" timestamptz, "description" text, "double_signature_required" bool, "signature_required" bool, "id" int4, "is_complete" bool, "modified_at" timestamptz, "name" varchar, "picture" varchar, "signature_1" varchar, "signature_2" varchar, "signed_at_1" timestamptz, "signed_at_2" timestamptz, "signed_by_1_id" int4, "signed_by_2_id" int4, "signed_by_1" varchar, "signed_by_2" varchar, "template_id" int4) AS $BODY$BEGIN
	RETURN QUERY
SELECT 
CCT.area_id, 
CC.company_id, 
CC.created_at, 
CCT.description, 
CCT.double_signature_required, 
CCT.signature_required,
CC.id, 
CC.is_complete, 
CC.modified_at, 
CCT.name, 
CCT.picture, 
CC.signature_1, 
CC.signature_2, 
CC.signed_at_1, 
CC.signed_at_2, 
CC.signed_by_1_id, 
0::int4 AS signed_by_2_id,
CONCAT(PU.first_name, ' ', PU.last_name)::varchar AS signed_by_1,
CC.signed_by_2, 
CC.template_id
FROM checklists_checklist CC 
INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id AND CC.company_id = CCT.company_id AND CCT.is_active = true 
LEFT JOIN profiles_user PU ON PU.id = CC.signed_by_1_id
WHERE CC.is_active = true AND CC.company_id = _companyid
AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = CCT.area_id) OR _areaid= 0) 
AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_checklisttemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = CCT.id) OR _userid = 0) 
AND (CC.signed_at_1::timestamp < get_timestamp_without_companytimezone(_companyid ,_timestamp) OR _timestamp IS NULL)
AND (CC.signed_at_1 >= get_timestamp_without_companytimezone(_companyid ,_starttimestamp) OR _starttimestamp IS NULL)
AND (CC.signed_at_1 <= get_timestamp_without_companytimezone(_companyid ,_endtimestamp) OR _endtimestamp IS NULL)
AND (CC.created_at > (NOW()::date - CONCAT(_timespanindays,' days')::interval) OR _timespanindays = 0) -- note when partial items can be submitted, this must change
AND (CC.is_complete = _iscomplete OR _iscomplete IS NULL)
ORDER BY CC.signed_at_1 DESC, CCT.name ASC, CCT.id
LIMIT CASE WHEN (_limit > 0) THEN _limit END 
OFFSET CASE WHEN (_offset > 0) THEN _offset END
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_checklists_properties
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_checklists_properties"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_checklists_properties"("_companyid" int4)
  RETURNS TABLE("id" int4, "company_id" int4, "checklist_id" int4, "property_id" int4, "template_property_id" int4, "user_id" int4, "value_int" int4, "value_string" text, "value_decimal" numeric, "value_time" time, "value_date" timestamp, "value_bool" bool, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
		SELECT 
		TP.id, 
		TP.company_id, 
		TP.checklist_id, 
		TP.property_id, 
		TP.template_property_id, 
		TP.user_id, 
		TP.value_int, 
		TP.value_string, 
		TP.value_decimal, 
		TP.value_time, 
		TP.value_date, 
		TP.value_bool, 
		TP.created_at, 
		TP.modified_at
		FROM checklists_properties TP
		WHERE TP.company_id = _companyid
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_checklisttemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_checklisttemplate"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_checklisttemplate"("_companyid" int4, "_id" int4)
  RETURNS TABLE("area_id" int4, "company_id" int4, "description" text, "double_signature_required" bool, "signature_required" bool, "id" int4, "name" varchar, "picture" varchar, "role" varchar, "has_incomplete_checklists" bool, "has_derived_items" bool) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
CC.area_id, 
CC.company_id, 
CC.description, 
CC.double_signature_required, 
CC.signature_required,
CC.id, 
CC.name, 
CC.picture, 
CC.role,
((SELECT COUNT(C.id) FROM checklists_checklist C WHERE C.is_complete = false AND CC.id = C.template_id) > 0) AS has_incomplete_checklists,
(SELECT (COUNT(C.id) > 0)::bool FROM checklists_checklist C WHERE CC.id = C.template_id) AS has_derived_items
FROM checklists_checklisttemplate CC WHERE CC.company_id = _companyid AND CC.id = _id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_checklisttemplate_properties
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_checklisttemplate_properties"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_checklisttemplate_properties"("_companyid" int4)
  RETURNS TABLE("id" int4, "company_id" int4, "checklisttemplate_id" int4, "property_id" int4, "propertyvalue_id" int4, "primary_int_value" int4, "secondary_int_value" int4, "primary_decimal_value" numeric, "secondary_decimal_value" numeric, "primary_string_value" text, "secondary_string_value" text, "bool_value" bool, "custom_value_type_display" varchar, "custom_title_display" varchar, "is_required" bool, "index" int4) AS $BODY$BEGIN
	RETURN QUERY
SELECT 
ATP.id, 
ATP.company_id, 
ATP.checklisttemplate_id, 
ATP.property_id, 
ATP.propertyvalue_id, 
ATP.primary_int_value, 
ATP.secondary_int_value, 
ATP.primary_decimal_value, 
ATP.secondary_decimal_value, 
ATP.primary_string_value, 
ATP.secondary_string_value, 
ATP.bool_value, 
ATP.custom_value_type_display, 
ATP.custom_title_display, 
ATP.is_required, 
ATP.index
FROM checklists_checklisttemplate_properties ATP
WHERE ATP.company_id = _companyid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_checklisttemplates
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_checklisttemplates"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_checklisttemplates"("_companyid" int4, "_timestamp" timestamp=NULL::timestamp without time zone, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("area_id" int4, "company_id" int4, "description" text, "double_signature_required" bool, "signature_required" bool, "id" int4, "name" varchar, "picture" varchar, "role" varchar, "has_derived_items" bool) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
CC.area_id, 
CC.company_id, 
CC.description, 
CC.double_signature_required, 
CC.signature_required,
CC.id, 
CC.name, 
CC.picture, 
CC.role,
(SELECT (COUNT(C.id) > 0)::bool FROM checklists_checklist C WHERE CC.id = C.template_id) AS has_derived_items
FROM checklists_checklisttemplate CC 
WHERE CC.company_id = _companyid AND CC.is_active = true
AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = CC.area_id) OR _areaid= 0) 
AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_checklisttemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = CC.id) OR _userid = 0) 
AND (CC.modified_at < _timestamp OR _timestamp IS NULL)
ORDER BY CC.name ASC, CC.id
LIMIT CASE WHEN (_limit > 0) THEN _limit END 
OFFSET CASE WHEN (_offset > 0) THEN _offset END
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_comment
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_comment"("_companyid" int4, "_commentid" int4);
CREATE OR REPLACE FUNCTION "public"."get_comment"("_companyid" int4, "_commentid" int4)
  RETURNS TABLE("id" int4, "company_id" int4, "user_id" int4, "task_id" int4, "tasktemplate_id" int4, "comment" text, "comment_date" timestamp, "description" text, "attachments" text, "created_at" timestamp, "modified_at" timestamp, "created_by" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	C.id, 
	C.company_id, 
	C.user_id, 
	C.task_id, 
	C.tasktemplate_id,
	C.comment, 
	C.comment_date, 
	C.description, 
	C.attachments, 
	C.created_at, 
	C.modified_at,
	CONCAT(PU.first_name, ' ', PU.last_name)::varchar AS created_by	
	FROM comments C
	LEFT JOIN profiles_user PU ON PU.id = C.user_id AND PU.company_id = _companyid
	WHERE C.company_id = _companyid AND C.id = _commentid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_comments
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_comments"("_companyid" int4, "_userid" int4, "_taskid" int4, "_tasktemplateid" int4, "_timestamp" timestamp, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_comments"("_companyid" int4, "_userid" int4=NULL::integer, "_taskid" int4=NULL::integer, "_tasktemplateid" int4=NULL::integer, "_timestamp" timestamp=NULL::timestamp without time zone, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("id" int4, "company_id" int4, "user_id" int4, "task_id" int4, "tasktemplate_id" int4, "comment" text, "comment_date" timestamp, "description" text, "attachments" text, "created_at" timestamp, "modified_at" timestamp, "created_by" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	C.id, 
	C.company_id, 
	C.user_id, 
	C.task_id, 
	C.tasktemplate_id,
	C.comment, 
	C.comment_date, 
	C.description, 
	C.attachments, 
	C.created_at, 
	C.modified_at,
  CONCAT(PU.first_name, ' ', PU.last_name)::varchar AS created_by	
	FROM comments C
	LEFT JOIN profiles_user PU ON PU.id = C.user_id AND PU.company_id = _companyid
	WHERE C.company_id = _companyid AND C.is_active = true
	AND (C.user_id = _userid OR _userid IS NULL)
	AND (C.task_id = _taskid OR _taskid IS NULL)
	AND (C.tasktemplate_id = _tasktemplateid OR _tasktemplateid IS NULL)
	AND (C.comment_date < _timestamp OR _timestamp IS NULL)
	ORDER BY C.comment_date DESC, C.modified_at DESC, C.id ASC
	LIMIT CASE WHEN (_limit > 0) THEN _limit END 
  OFFSET CASE WHEN (_offset > 0) THEN _offset END;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_companies
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_companies"();
CREATE OR REPLACE FUNCTION "public"."get_companies"()
  RETURNS TABLE("description" text, "id" int4, "manager_id" int4, "name" varchar, "picture" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
CC.description, 
CC.id, 
CC.manager_id, 
CC.name, 
CC.picture
FROM companies_company CC WHERE CC.is_active = true
ORDER BY CC.name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_company"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_company"("_companyid" int4, "_id" int4)
  RETURNS TABLE("description" text, "id" int4, "manager_id" int4, "name" varchar, "picture" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
CC.description, 
CC.id, 
CC.manager_id, 
CC.name, 
CC.picture
FROM companies_company CC WHERE CC.is_active = true AND CC.id = _id AND CC.id = _companyid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_company"("_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_company"("_id" int4)
  RETURNS TABLE("description" text, "id" int4, "manager_id" int4, "name" varchar, "picture" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
CC.description, 
CC.id, 
CC.manager_id, 
CC.name, 
CC.picture
FROM companies_company CC WHERE CC.is_active = true AND CC.id = _id
ORDER BY CC.name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_company_roles
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_company_roles"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_company_roles"("_companyid" int4)
  RETURNS TABLE("id" int4, "basic_role_display_name" varchar, "manager_role_display_name" varchar, "shift_leader_role_display_name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
				CC.id,
				CC.basic_role_display_name,
				CC.manager_role_display_name,
				CC.shift_leader_role_display_name
	FROM companies_company CC 
	WHERE CC.is_active = true AND CC.id = _companyid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_companyid_by_token
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_companyid_by_token"("token" varchar);
CREATE OR REPLACE FUNCTION "public"."get_companyid_by_token"("token" varchar)
  RETURNS SETOF "pg_catalog"."int4" AS $BODY$
  BEGIN 
	RETURN QUERY 
	SELECT company_id FROM authtoken_token ATT
	INNER JOIN profiles_user PU ON PU.id = ATT.user_id
	WHERE ATT.key = token;
	END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_data_row_json
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_data_row_json"("_table_name" varchar, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_data_row_json"("_table_name" varchar, "_id" int4)
  RETURNS "pg_catalog"."text" AS $BODY$
	DECLARE 
		result text; 
BEGIN
		EXECUTE 'SELECT row_to_json(' || _table_name || ') FROM ' || quote_ident(_table_name) || ' WHERE ' || quote_ident(_table_name) || '.id = ' || _id::varchar || ' LIMIT 1' 
		INTO result;
	RETURN result;
END;
$BODY$
  LANGUAGE plpgsql STABLE
  COST 100;

-- ----------------------------
-- Function structure for get_factoryfeedmessages
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_factoryfeedmessages"("_companyid" int4, "_factoryfeedid" int4, "_user" int4, "_timestamp" timestamp, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_factoryfeedmessages"("_companyid" int4, "_factoryfeedid" int4=NULL::integer, "_user" int4=NULL::integer, "_timestamp" timestamp=NULL::timestamp without time zone, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("id" int4, "company_id" int4, "factoryfeed_id" int4, "user_id" int4, "title" varchar, "description" text, "attachments" text, "is_sticky" bool, "is_highlighted" bool, "message_type" int4, "data" text, "message_date" timestamp, "created_at" timestamp, "modified_at" timestamp, "parent_id" int4) AS $BODY$BEGIN
	RETURN QUERY
		SELECT 
		FF.id, 
		FF.company_id, 
		FF.factoryfeed_id, 
		FF.user_id, 
		FF.title, 
		FF.description, 
		FF.attachments, 
		FF.is_sticky, 
		FF.is_highlighted, 
		FF.message_type, 
		FF.data, 
		FF.message_date, 
		FF.created_at, 
		FF.modified_at,
		FF.parent_id
		FROM factoryfeed_messages FF
		WHERE FF.company_id = _companyid AND FF.is_active = true
		AND (FF.factoryfeed_id = _factoryfeedid OR _factoryfeedid IS NULL)
		AND (FF.user_id = _user OR _user IS NULL)
		AND (FF.message_date < _timestamp OR _timestamp IS NULL)
		ORDER BY FF.is_sticky DESC, FF.message_date DESC, FF.modified_at DESC, FF.id ASC
		LIMIT CASE WHEN (_limit > 0) THEN _limit END 
		OFFSET CASE WHEN (_offset > 0) THEN _offset END;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_factoryfeeds
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_factoryfeeds"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_factoryfeeds"("_companyid" int4)
  RETURNS TABLE("id" int4, "company_id" int4, "name" varchar, "description" text, "attachments" text, "data" text, "feed_type" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT FF.id, FF.company_id, FF.name, FF.description, FF.attachments, FF.data, FF.feed_type FROM factoryfeeds FF WHERE FF.company_id = _companyid;	
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_factoryfeeds_by_type
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_factoryfeeds_by_type"("_companyid" int4, "_feedtype" int4);
CREATE OR REPLACE FUNCTION "public"."get_factoryfeeds_by_type"("_companyid" int4, "_feedtype" int4)
  RETURNS TABLE("id" int4, "company_id" int4, "name" varchar, "description" text, "attachments" text, "data" text, "feed_type" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT FF.id, FF.company_id, FF.name, FF.description, FF.attachments, FF.data, FF.feed_type FROM factoryfeeds FF WHERE FF.company_id = _companyid AND FF.feed_type = _feedtype;	
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_properties
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_properties"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_properties"("_companyid" int4)
  RETURNS TABLE("id" int4, "propertygroup_id" int4, "propertyvaluekind_id" int4, "propertyvalue_id" int4, "name" varchar, "description" text, "shortname" varchar, "field_type" int4, "value_type" int4, "display_value_type" int4, "display_type" int4, "type" int4, "resource_key_name" varchar, "is_customer_specific" bool, "is_system" bool, "is_active" bool, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
P.id, 
P.propertygroup_id, 
P.propertyvaluekind_id, 
P.propertyvalue_id, 
P.name, 
P.description, 
P.shortname, 
P.field_type, 
P.value_type, 
P.display_value_type, 
P.display_type, 
P."type", 
P.resource_key_name, 
P.is_customer_specific, 
P.is_system, 
P.is_active, 
P.created_at, 
P.modified_at
FROM properties P
WHERE 
(P.is_system = true OR P.id IN (SELECT CP.property_id FROM companies_properties CP WHERE CP.company_id = _companyid))
AND p.is_active = true 
ORDER BY P.name
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_properties_with_audittemplates
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_properties_with_audittemplates"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_properties_with_audittemplates"("_companyid" int4)
  RETURNS TABLE("id" int4, "template_id" int4, "propertygroup_id" int4, "propertyvaluekind_id" int4, "propertyvalue_id" int4, "name" varchar, "description" text, "shortname" varchar, "field_type" int4, "value_type" int4, "display_value_type" int4, "display_type" int4, "type" int4, "resource_key_name" varchar, "is_customer_specific" bool, "is_system" bool, "is_active" bool, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
P.id, 
ATP.audittemplate_id AS template_id,
P.propertygroup_id, 
P.propertyvaluekind_id, 
P.propertyvalue_id, 
P.name, 
P.description, 
P.shortname, 
P.field_type, 
P.value_type, 
P.display_value_type, 
P.display_type, 
P."type", 
P.resource_key_name, 
P.is_customer_specific, 
P.is_system, 
P.is_active, 
P.created_at, 
P.modified_at
FROM properties P
INNER JOIN audits_audittemplate_properties ATP ON ATP.property_id = P.id
WHERE ATP.company_id = _companyid
ORDER BY P.name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_properties_with_checklisttemplates
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_properties_with_checklisttemplates"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_properties_with_checklisttemplates"("_companyid" int4)
  RETURNS TABLE("id" int4, "template_id" int4, "propertygroup_id" int4, "propertyvaluekind_id" int4, "propertyvalue_id" int4, "name" varchar, "description" text, "shortname" varchar, "field_type" int4, "value_type" int4, "display_value_type" int4, "display_type" int4, "type" int4, "resource_key_name" varchar, "is_customer_specific" bool, "is_system" bool, "is_active" bool, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
P.id, 
CTP.checklisttemplate_id AS template_id,
P.propertygroup_id, 
P.propertyvaluekind_id, 
P.propertyvalue_id, 
P.name, 
P.description, 
P.shortname, 
P.field_type, 
P.value_type, 
P.display_value_type, 
P.display_type, 
P."type", 
P.resource_key_name, 
P.is_customer_specific, 
P.is_system, 
P.is_active, 
P.created_at, 
P.modified_at
FROM properties P
INNER JOIN checklists_checklisttemplate_properties CTP ON CTP.property_id = P.id
WHERE CTP.company_id = _companyid
ORDER BY P.name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_properties_with_group
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_properties_with_group"("_companyid" int4, "_groupid" int4);
CREATE OR REPLACE FUNCTION "public"."get_properties_with_group"("_companyid" int4, "_groupid" int4)
  RETURNS TABLE("id" int4, "propertygroup_id" int4, "propertyvaluekind_id" int4, "propertyvalue_id" int4, "name" varchar, "description" text, "shortname" varchar, "field_type" int4, "value_type" int4, "display_value_type" int4, "display_type" int4, "type" int4, "resource_key_name" varchar, "is_customer_specific" bool, "is_system" bool, "is_active" bool, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
P.id, 
P.propertygroup_id, 
P.propertyvaluekind_id, 
P.propertyvalue_id, 
P.name, 
P.description, 
P.shortname, 
P.field_type, 
P.value_type, 
P.display_value_type, 
P.display_type, 
P."type", 
P.resource_key_name, 
P.is_customer_specific, 
P.is_system, 
P.is_active, 
P.created_at, 
P.modified_at
FROM properties P
INNER JOIN propertygroups PG ON PG.id = P.propertygroup_id AND PG.id = _groupid
WHERE 
(P.is_system = true OR P.id IN (SELECT CP.property_id FROM companies_properties CP WHERE CP.company_id = _companyid))
AND p.is_active = true 
ORDER BY P.name
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_properties_with_tasks
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_properties_with_tasks"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_properties_with_tasks"("_companyid" int4)
  RETURNS TABLE("id" int4, "template_id" int4, "propertygroup_id" int4, "propertyvaluekind_id" int4, "propertyvalue_id" int4, "name" varchar, "description" text, "shortname" varchar, "field_type" int4, "value_type" int4, "display_value_type" int4, "display_type" int4, "type" int4, "resource_key_name" varchar, "is_customer_specific" bool, "is_system" bool, "is_active" bool, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
P.id, 
TP.task_id AS task_id,
P.propertygroup_id, 
P.propertyvaluekind_id, 
P.propertyvalue_id, 
P.name, 
P.description, 
P.shortname, 
P.field_type, 
P.value_type, 
P.display_value_type, 
P.display_type, 
P."type", 
P.resource_key_name, 
P.is_customer_specific, 
P.is_system, 
P.is_active, 
P.created_at, 
P.modified_at
FROM properties P
INNER JOIN task_properties TP ON TP.property_id = P.id
WHERE ATP.company_id = _companyid
ORDER BY P.name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_properties_with_tasktemplates
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_properties_with_tasktemplates"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_properties_with_tasktemplates"("_companyid" int4)
  RETURNS TABLE("id" int4, "template_id" int4, "propertygroup_id" int4, "propertyvaluekind_id" int4, "propertyvalue_id" int4, "name" varchar, "description" text, "shortname" varchar, "field_type" int4, "value_type" int4, "display_value_type" int4, "display_type" int4, "type" int4, "resource_key_name" varchar, "is_customer_specific" bool, "is_system" bool, "is_active" bool, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
P.id, 
ATP.tasktemplate_id AS template_id,
P.propertygroup_id, 
P.propertyvaluekind_id, 
P.propertyvalue_id, 
P.name, 
P.description, 
P.shortname, 
P.field_type, 
P.value_type, 
P.display_value_type, 
P.display_type, 
P."type", 
P.resource_key_name, 
P.is_customer_specific, 
P.is_system, 
P.is_active, 
P.created_at, 
P.modified_at
FROM properties P
INNER JOIN tasks_tasktemplate_properties ATP ON ATP.property_id = P.id
WHERE ATP.company_id = _companyid
ORDER BY P.name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_property
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_property"("_companyid" int4, "_propertyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_property"("_companyid" int4, "_propertyid" int4)
  RETURNS TABLE("id" int4, "propertygroup_id" int4, "propertyvaluekind_id" int4, "propertyvalue_id" int4, "name" varchar, "description" text, "shortname" varchar, "field_type" int4, "value_type" int4, "display_value_type" int4, "display_type" int4, "type" int4, "resource_key_name" varchar, "is_customer_specific" bool, "is_system" bool, "is_active" bool, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
P.id, 
P.propertygroup_id, 
P.propertyvaluekind_id, 
P.propertyvalue_id, 
P.name, 
P.description, 
P.shortname, 
P.field_type, 
P.value_type, 
P.display_value_type, 
P.display_type, 
P."type", 
P.resource_key_name, 
P.is_customer_specific, 
P.is_system, 
P.is_active, 
P.created_at, 
P.modified_at
FROM properties P
WHERE P.id = _propertyid AND p.is_active = true 
ORDER BY P.name
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_propertygroups
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_propertygroups"();
CREATE OR REPLACE FUNCTION "public"."get_propertygroups"()
  RETURNS TABLE("id" int4, "name" varchar, "description" text, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
		SELECT PG."id", PG."name", PG."description", PG."created_at", PG."modified_at" FROM propertygroups PG WHERE PG.is_active = true
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_propertyvaluekinds
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_propertyvaluekinds"();
CREATE OR REPLACE FUNCTION "public"."get_propertyvaluekinds"()
  RETURNS TABLE("id" int4, "name" varchar, "description" text, "resource_key_name" varchar, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
		SELECT PVK.id, PVK.name, PVK.description, PVK.resource_key_name, PVK.created_at, PVK.modified_at 
		FROM propertyvaluekind PVK 
		WHERE PVK.is_active = true ORDER BY Name
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_propertyvalues
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_propertyvalues"();
CREATE OR REPLACE FUNCTION "public"."get_propertyvalues"()
  RETURNS TABLE("id" int4, "propertyvaluekind_id" int4, "name" varchar, "description" text, "value_symbol" varchar, "value_abbreviation" varchar, "default_value_type" int4, "resource_key_name" varchar, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
SELECT 
PV.id, 
PV.propertyvaluekind_id, 
PV.name, 
PV.description, 
PV.value_symbol, 
PV.value_abbreviation, 
PV.default_value_type, 
PV.resource_key_name, 
PV.created_at, 
PV.modified_at 
FROM propertyvalue PV
WHERE PV.is_active = true
ORDER BY propertyvaluekind_id, name
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_recurrency_shift_ids
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_recurrency_shift_ids"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_recurrency_shift_ids"("_companyid" int4)
  RETURNS TABLE("id" int4, "shift_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT TTR.id AS taskrecurrency_id, TTRS.shift_id FROM tasks_taskrecurrency TTR 
	INNER JOIN tasks_taskrecurrency_shifts TTRS ON TTRS.taskrecurrency_id = TTR.id
	WHERE TTR.is_active = true AND TTR.company_id = _companyid
	UNION
	SELECT TTR.id AS taskrecurrency_id, TTRS.shift_id FROM tasks_taskrecurrency TTR 
	INNER JOIN tasks_taskrecurrency_one_time_shifts TTRS ON TTRS.taskrecurrency_id = TTR.id
	WHERE TTR.is_active = true AND TTR.company_id = _companyid
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_recurrency_shift_ids_by_id
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_recurrency_shift_ids_by_id"("_companyid" int4, "_taskrecurrencyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_recurrency_shift_ids_by_id"("_companyid" int4, "_taskrecurrencyid" int4)
  RETURNS TABLE("id" int4, "shift_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT TTR.id AS taskrecurrency_id, TTRS.shift_id FROM tasks_taskrecurrency TTR 
	INNER JOIN tasks_taskrecurrency_shifts TTRS ON TTRS.taskrecurrency_id = TTR.id
	WHERE TTR.is_active = true AND TTR.company_id = _companyid AND TTR.id = _taskrecurrencyid
	UNION
	SELECT TTR.id AS taskrecurrency_id, TTRS.shift_id FROM tasks_taskrecurrency TTR 
	INNER JOIN tasks_taskrecurrency_one_time_shifts TTRS ON TTRS.taskrecurrency_id = TTR.id
	WHERE TTR.is_active = true AND TTR.company_id = _companyid AND TTR.id = _taskrecurrencyid
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_resource_language
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_resource_language"("_culture" varchar);
CREATE OR REPLACE FUNCTION "public"."get_resource_language"("_culture" varchar)
  RETURNS TABLE("id" int4, "resource_key" varchar, "resource_guid" varchar, "description" text, "resource_value" text) AS $BODY$BEGIN
	RETURN QUERY
	--SELECT RL."id", RL."resource_key", RL."resource_guid", RL."description", RL."en_gb" AS "resource_value" FROM "public"."resource_languages" RL;
	EXECUTE format('SELECT RL."id", RL."resource_key", RL."resource_guid", RL."description", %I AS "resource_value" FROM "public"."resource_languages" RL WHERE "type" = 1', _culture);
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_resource_language_management
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_resource_language_management"("_culture" varchar);
CREATE OR REPLACE FUNCTION "public"."get_resource_language_management"("_culture" varchar)
  RETURNS TABLE("id" int4, "resource_key" varchar, "resource_guid" varchar, "description" text, "resource_value" text) AS $BODY$BEGIN
	RETURN QUERY
	--SELECT RL."id", RL."resource_key", RL."resource_guid", RL."description", RL."en_gb" AS "resource_value" FROM "public"."resource_languages" RL;
	EXECUTE format('SELECT RL."id", RL."resource_key", RL."resource_guid", RL."description", %I AS "resource_value" FROM "public"."resource_languages" RL WHERE "type" = 2', _culture);
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_resource_settings
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_resource_settings"();
CREATE OR REPLACE FUNCTION "public"."get_resource_settings"()
  RETURNS TABLE("id" int4, "name" varchar, "description" text, "settingskey" varchar, "settingstype" int4, "settingvalue" text) AS $BODY$BEGIN
	RETURN QUERY
	SELECT RS.id, RS.name, RS.description, RS.settingskey, RS.settingstype, RS.settingvalue FROM resource_settings RS;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_resource_settings_by_key
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_resource_settings_by_key"("_settingkey" varchar);
CREATE OR REPLACE FUNCTION "public"."get_resource_settings_by_key"("_settingkey" varchar)
  RETURNS TABLE("id" int4, "name" varchar, "description" text, "settingskey" varchar, "settingstype" int4, "settingvalue" text) AS $BODY$BEGIN
	RETURN QUERY
	SELECT RS.id, RS.name, RS.description, RS.settingskey, RS.settingstype, RS.settingvalue FROM resource_settings RS
	WHERE RS.settingskey = _settingkey;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_resource_settings_companies
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_resource_settings_companies"();
CREATE OR REPLACE FUNCTION "public"."get_resource_settings_companies"()
  RETURNS TABLE("id" int4, "company_id" int4, "value" text, "description" text, "resource_setting_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT RS.id, RS.company_id, RS.value, RS.description, RS.resource_setting_id FROM companies_setting RS;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_resource_settings_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_resource_settings_company"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_resource_settings_company"("_companyid" int4)
  RETURNS TABLE("id" int4, "company_id" int4, "value" text, "description" text, "resource_setting_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT RS.id, RS.company_id, RS.value, RS.description, RS.resource_setting_id FROM companies_setting RS
	WHERE RS.company_id = _companyid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_resourcesetting_dblogging_enabled
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_resourcesetting_dblogging_enabled"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_resourcesetting_dblogging_enabled"("_companyid" int4)
  RETURNS SETOF "pg_catalog"."bool" AS $BODY$
  BEGIN 
	RETURN QUERY 
	SELECT COUNT(T.company_id) > 0 AS company_id_found FROM (
		SELECT S.company_id::int4 AS company_id FROM (
			SELECT unnest(string_to_array(RS.settingvalue, ',')) AS "company_id" FROM resource_settings RS WHERE id = 15
			) AS S
	) AS T
	WHERE T.company_id = _companyid;
	END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_resourcesetting_dblogging_enabled_by_user
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_resourcesetting_dblogging_enabled_by_user"("_userid" int4);
CREATE OR REPLACE FUNCTION "public"."get_resourcesetting_dblogging_enabled_by_user"("_userid" int4)
  RETURNS SETOF "pg_catalog"."bool" AS $BODY$
  BEGIN 
	RETURN QUERY 
	SELECT COUNT(T.company_id) > 0 AS company_id_found FROM (
		SELECT S.company_id::int4 AS company_id FROM (
			SELECT unnest(string_to_array(RS.settingvalue, ',')) AS "company_id" FROM resource_settings RS WHERE id = 15
			) AS S
	) AS T
	WHERE T.company_id = (SELECT PU.company_id FROM profiles_user PU WHERE PU.id = _userid LIMIT 1);
	END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_shift
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_shift"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_shift"("_companyid" int4, "_id" int4)
  RETURNS TABLE("area_id" int4, "company_id" int4, "day" int2, "end" time, "id" int4, "start" time, "weekday" int2) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	CS."area_id", 
	CS."company_id",
  CS."day", 
  CS."end", 
  CS."id", 
  CS."start", 
  CS."weekday" 
	FROM companies_shift CS WHERE CS.company_id = _companyid AND CS.id = _id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_shift_by_timestamp
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_shift_by_timestamp"("_companyid" int4, "_timestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_shift_by_timestamp"("_companyid" int4, "_timestamp" timestamp)
  RETURNS TABLE("id" int4, "start" time, "end" time, "start_date" timestamp, "end_date" timestamp, "weekday" int4, "day_date" date) AS $BODY$BEGIN
	RETURN QUERY 
	  SELECT * FROM (
			SELECT T."id", T."start", T."end", 
					T."day_date" + T."start" AS start_date,
					CASE WHEN T.end < T.start THEN
						(T."day_date" + '1 day'::interval) + T."end"
					ELSE
						T."day_date" + T."end"
					END AS end_date,
					T.weekday,
					T.day_date
			FROM (
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, _timestamp::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from _timestamp::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true AND CS."start" <= _timestamp::time 
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '1 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '1 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '2 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '2 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '3 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '3 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '4 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '4 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '5 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '5 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '6 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '6 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
				) AS T 
				ORDER BY T.day_date DESC, T.weekday DESC, T."start" DESC, T."end" ASC
			) AS S WHERE S.end_date > _timestamp AND S.start_date <= _timestamp
			LIMIT 1
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_shift_first_last_for_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_shift_first_last_for_company"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_shift_first_last_for_company"("_companyid" int4)
  RETURNS TABLE("first_start" time, "first_end" time, "first_shift_id" int4, "last_start" time, "last_end" time, "last_shift_id" int4, "weekday" int4) AS $BODY$BEGIN
	RETURN QUERY
		SELECT DISTINCT * FROM (
			SELECT 
				FIRST_VALUE(CS."start") OVER(PARTITION BY CS.weekday ORDER BY CS."start") AS first_start, 
				FIRST_VALUE(CS."end") OVER(PARTITION BY CS.weekday ORDER BY CS."start") AS first_end, 
				FIRST_VALUE(CS."id") OVER(PARTITION BY CS.weekday ORDER BY CS."start") AS first_shift_id,
				FIRST_VALUE(CS."start") OVER(PARTITION BY CS.weekday ORDER BY CS."start" DESC) AS last_start, 
				FIRST_VALUE(CS."end") OVER(PARTITION BY CS.weekday ORDER BY CS."start" DESC) AS last_end, 
				FIRST_VALUE(CS."id") OVER(PARTITION BY CS.weekday ORDER BY CS."start" DESC) AS last_shift_id,
				CS.weekday::int4 AS weekday
			FROM companies_shift CS 
			WHERE CS.company_id = _companyid AND CS.is_active = true AND area_id IS NULL) AS T 
		ORDER BY T.weekday;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_shift_first_last_for_company_by_weekday
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_shift_first_last_for_company_by_weekday"("_companyid" int4, "_weekday" int4);
CREATE OR REPLACE FUNCTION "public"."get_shift_first_last_for_company_by_weekday"("_companyid" int4, "_weekday" int4)
  RETURNS TABLE("first_start" time, "first_end" time, "first_shift_id" int4, "last_start" time, "last_end" time, "last_shift_id" int4, "weekday" int4) AS $BODY$BEGIN
	RETURN QUERY
		SELECT DISTINCT * FROM (
			SELECT 
				FIRST_VALUE(CS."start") OVER(PARTITION BY CS.weekday ORDER BY CS."start") AS first_start, 
				FIRST_VALUE(CS."end") OVER(PARTITION BY CS.weekday ORDER BY CS."start") AS first_end, 
				FIRST_VALUE(CS."id") OVER(PARTITION BY CS.weekday ORDER BY CS."start") AS first_shift_id,
				FIRST_VALUE(CS."start") OVER(PARTITION BY CS.weekday ORDER BY CS."start" DESC) AS last_start, 
				FIRST_VALUE(CS."end") OVER(PARTITION BY CS.weekday ORDER BY CS."start" DESC) AS last_end, 
				FIRST_VALUE(CS."id") OVER(PARTITION BY CS.weekday ORDER BY CS."start" DESC) AS last_shift_id,
				CS.weekday::int4 AS weekday
			FROM companies_shift CS 
			WHERE CS.company_id = _companyid AND CS.is_active = true AND CS.area_id IS NULL AND CS.weekday = _weekday) AS T 
		ORDER BY T.weekday;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_shift_first_last_on_day_by_isodow
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_shift_first_last_on_day_by_isodow"("_companyid" int4, "_isodow" int4);
CREATE OR REPLACE FUNCTION "public"."get_shift_first_last_on_day_by_isodow"("_companyid" int4, "_isodow" int4)
  RETURNS TABLE("first_start" time, "first_end" time, "first_shift_id" int4, "last_start" time, "last_end" time, "last_shift_id" int4) AS $BODY$BEGIN
	RETURN QUERY
		SELECT DISTINCT * FROM (
		SELECT 
			FIRST_VALUE("start") OVER(ORDER BY "start") AS first_start, 
			FIRST_VALUE("end") OVER(ORDER BY "start") AS first_end, 
			FIRST_VALUE("id") OVER(ORDER BY "start") AS first_shift_id,
			FIRST_VALUE("start") OVER(ORDER BY "start" DESC) AS last_start, 
			FIRST_VALUE("end") OVER(ORDER BY "start" DESC) AS last_end, 
			FIRST_VALUE("id") OVER(ORDER BY "start" DESC) AS last_shift_id
		FROM companies_shift 
		WHERE weekday = _isodow - 1 AND company_id = _companyid and is_active = true
		) AS T;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_shift_first_last_on_day_by_timestamp
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_shift_first_last_on_day_by_timestamp"("_companyid" int4, "_timestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_shift_first_last_on_day_by_timestamp"("_companyid" int4, "_timestamp" timestamp)
  RETURNS TABLE("first_start" time, "first_end" time, "first_shift_id" int4, "last_start" time, "last_end" time, "last_shift_id" int4) AS $BODY$BEGIN
	RETURN QUERY
		SELECT DISTINCT * FROM (
		SELECT 
			FIRST_VALUE("start") OVER(ORDER BY "start") AS first_start, 
			FIRST_VALUE("end") OVER(ORDER BY "start") AS first_end, 
			FIRST_VALUE("id") OVER(ORDER BY "start") AS first_shift_id,
			FIRST_VALUE("start") OVER(ORDER BY "start" DESC) AS last_start, 
			FIRST_VALUE("end") OVER(ORDER BY "start" DESC) AS last_end, 
			FIRST_VALUE("id") OVER(ORDER BY "start" DESC) AS last_shift_id
		FROM companies_shift 
		WHERE weekday = (EXTRACT(ISODOW from (_timestamp::date))::int - 1) AND company_id = _companyid and is_active = true
		) AS T;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_shift_previous_by_timestamp
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_shift_previous_by_timestamp"("_companyid" int4, "_timestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_shift_previous_by_timestamp"("_companyid" int4, "_timestamp" timestamp)
  RETURNS TABLE("id" int4, "start" time, "end" time, "start_date" timestamp, "end_date" timestamp, "weekday" int4, "day_date" date) AS $BODY$BEGIN
	RETURN QUERY 
	  SELECT * FROM (
			SELECT T."id", T."start", T."end", 
					T."day_date" + T."start" AS start_date,
					CASE WHEN T.end < T.start THEN
						(T."day_date" + '1 day'::interval) + T."end"
					ELSE
						T."day_date" + T."end"
					END AS end_date,
					T.weekday,
					T.day_date
			FROM (
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, _timestamp::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from _timestamp::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true AND CS."start" < _timestamp::time AND CS."end" <= _timestamp::time 
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '1 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '1 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '2 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '2 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '3 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '3 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '4 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '4 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '5 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '5 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '6 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '6 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
				) AS T 
				ORDER BY T.day_date DESC, T.weekday DESC, T."start" DESC, T."end" ASC
			) AS S WHERE S.end_date < _timestamp
			LIMIT 1
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_shifts
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_shifts"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_shifts"("_companyid" int4)
  RETURNS TABLE("area_id" int4, "company_id" int4, "day" int2, "end" time, "id" int4, "start" time, "weekday" int2, "shiftnr" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	CS."area_id", 
	CS."company_id",
  CS."day", 
  CS."end", 
  CS."id", 
  CS."start", 
  CS."weekday",
  (row_number() OVER (PARTITION BY CS.day, CS.area_id ORDER BY CS.day, CS.area_id DESC, CS.start))::int AS shiftnr	
	FROM companies_shift CS WHERE CS.company_id = _companyid AND CS.is_active = true ORDER BY CS.weekday, CS."start", CS."end";
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_shifts_by_timestamp
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_shifts_by_timestamp"("_companyid" int4, "_timestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_shifts_by_timestamp"("_companyid" int4, "_timestamp" timestamp)
  RETURNS TABLE("id" int4, "start" time, "end" time, "start_date" timestamp, "end_date" timestamp, "weekday" int4, "day_date" date) AS $BODY$BEGIN
	RETURN QUERY 
		SELECT * FROM (
			SELECT T."id", T."start", T."end", 
					T."day_date" + T."start" AS start_date,
					CASE WHEN T.end < T.start THEN
						(T."day_date" + '1 day'::interval) + T."end"
					ELSE
						T."day_date" + T."end"
					END AS end_date,
					T.weekday,
					T.day_date 
			FROM (
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, _timestamp::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from _timestamp::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true 
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp::date- '1 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp::date - '1 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp::date - '2 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp::date - '2 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp::date - '3 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp::date- '3 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp::date - '4 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp::date - '4 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp::date - '5 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp::date - '5 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp::date - '6 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp::date - '6 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
				) AS T 
				ORDER BY T.day_date DESC, T.weekday DESC, T."start" DESC
			) AS S;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_shifts_datetimes_on_day_by_timestamp
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_shifts_datetimes_on_day_by_timestamp"("_companyid" int4, "_timestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_shifts_datetimes_on_day_by_timestamp"("_companyid" int4, "_timestamp" timestamp)
  RETURNS TABLE("start_date" timestamp, "end_date" timestamp, "weekday" int4, "day_date" date) AS $BODY$BEGIN
	RETURN QUERY 
		SELECT 
					MIN(S.start_date) AS start_date, 
					MAX(S.end_date) AS end_date, 
					MIN(S.weekday) AS weekday,
					MIN(S.day_date) AS day_date
		FROM (
					SELECT T."id", T."start", T."end", 
							T."day_date" + T."start" AS start_date,
							CASE WHEN T.end < T.start THEN
								(T."day_date" + '1 day'::interval) + T."end"
							ELSE
								T."day_date" + T."end"
							END AS end_date,
							T.weekday,
							T.day_date 
					FROM (
							SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, _timestamp::date AS day_date FROM companies_shift CS 
							WHERE CS.weekday = ((EXTRACT(ISODOW from _timestamp::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true 
							UNION
							SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp::date - '1 day'::interval)::date AS day_date FROM companies_shift CS 
							WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp::date - '1 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
							UNION
							SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp::date - '2 day'::interval)::date AS day_date FROM companies_shift CS 
							WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp::date - '2 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
							UNION
							SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp::date - '3 day'::interval)::date AS day_date FROM companies_shift CS 
							WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp::date - '3 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
							UNION
							SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp::date - '4 day'::interval)::date AS day_date FROM companies_shift CS 
							WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp::date - '4 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
							UNION
							SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp::date - '5 day'::interval)::date AS day_date FROM companies_shift CS 
							WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp::date - '5 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
							UNION
							SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp::date - '6 day'::interval)::date AS day_date FROM companies_shift CS 
							WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp::date - '6 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
						) AS T 
					ORDER BY T.day_date DESC, T.weekday DESC, T."start" DESC
		) AS S 
		WHERE S.start_date <= _timestamp::timestamp AND S.end_date > _timestamp::timestamp
		GROUP BY S.weekday
		ORDER BY start_date DESC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_shifts_past_by_timestamp
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_shifts_past_by_timestamp"("_companyid" int4, "_timestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_shifts_past_by_timestamp"("_companyid" int4, "_timestamp" timestamp)
  RETURNS TABLE("id" int4, "start" time, "end" time, "start_date" timestamp, "end_date" timestamp, "weekday" int4, "day_date" date) AS $BODY$BEGIN
	RETURN QUERY 
		SELECT * FROM (
			SELECT T."id", T."start", T."end", 
					T."day_date" + T."start" AS start_date,
					CASE WHEN T.end < T.start THEN
						(T."day_date" + '1 day'::interval) + T."end"
					ELSE
						T."day_date" + T."end"
					END AS end_date,
					T.weekday,
					T.day_date 
			FROM (
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, _timestamp::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from _timestamp::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true AND CS."start" < _timestamp::time AND CS."end" <= _timestamp::time 
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '1 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '1 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '2 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '2 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '3 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '3 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '4 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '4 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '5 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '5 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					UNION
					SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '6 day'::interval)::date AS day_date FROM companies_shift CS 
					WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '6 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
				) AS T 
				ORDER BY T.day_date DESC, T.weekday DESC, T."start" DESC
			) AS S WHERE S.end_date < _timestamp;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_shifts_past_day_by_timestamp
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_shifts_past_day_by_timestamp"("_companyid" int4, "_timestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_shifts_past_day_by_timestamp"("_companyid" int4, "_timestamp" timestamp)
  RETURNS TABLE("id" int4, "start" time, "end" time, "start_date" timestamp, "end_date" timestamp, "weekday" int4, "day_date" date) AS $BODY$
	DECLARE 
		_current_shift_weekday int;
		_previous_weekday int;
	BEGIN
	_current_shift_weekday = (SELECT T.weekday FROM get_shift_by_timestamp(_companyid::int, _timestamp) AS T LIMIT 1);
	SELECT 
	CASE WHEN (_current_shift_weekday - 1)::int < 0 THEN
			6::int
	ELSE 
			(_current_shift_weekday - 1)::int
	END AS resultweekday INTO _previous_weekday; 
	
	RETURN QUERY 
		SELECT * FROM (
			SELECT * FROM (
				SELECT T."id", T."start", T."end", 
						T."day_date" + T."start" AS start_date,
						CASE WHEN T.end < T.start THEN
							(T."day_date" + '1 day'::interval) + T."end"
						ELSE
							T."day_date" + T."end"
						END AS end_date,
						T.weekday,
						T.day_date 
				FROM (
						SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, _timestamp::date AS day_date FROM companies_shift CS 
						WHERE CS.weekday = ((EXTRACT(ISODOW from _timestamp::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true AND CS."start" < _timestamp::time AND CS."end" <= _timestamp::time 
						UNION
						SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '1 day'::interval)::date AS day_date FROM companies_shift CS 
						WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '1 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
						UNION
						SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '2 day'::interval)::date AS day_date FROM companies_shift CS 
						WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '2 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
						UNION
						SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '3 day'::interval)::date AS day_date FROM companies_shift CS 
						WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '3 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
						UNION
						SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '4 day'::interval)::date AS day_date FROM companies_shift CS 
						WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '4 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
						UNION
						SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '5 day'::interval)::date AS day_date FROM companies_shift CS 
						WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '5 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
						UNION
						SELECT CS.id, CS."start", CS."end", CS."weekday"::int4, (_timestamp - '6 day'::interval)::date AS day_date FROM companies_shift CS 
						WHERE CS.weekday = ((EXTRACT(ISODOW from (_timestamp - '6 day'::interval)::date)::int - 1)::int) AND CS.company_id = _companyid AND CS.is_active = true
					) AS T 
					ORDER BY T.day_date DESC, T.weekday DESC, T."start" DESC
				) AS S WHERE S.end_date < _timestamp
			) AS F WHERE F.weekday = _previous_weekday;
			
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_shifts_with_tasktemplates
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_shifts_with_tasktemplates"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_shifts_with_tasktemplates"("_companyid" int4)
  RETURNS TABLE("tasktemplate_id" int4, "shift_id" int4, "day" int4, "start" varchar, "end" varchar) AS $BODY$BEGIN
	RETURN QUERY
	 SELECT DISTINCT 
		TT.id AS tasktemplate_id,
		CS.id AS shift_id,
		CS.day::int4 AS "day",  
		CS.start::varchar AS "start",
		CS.end::varchar AS "end"
	FROM tasks_tasktemplate TT 
	LEFT JOIN tasks_taskrecurrency TTR ON TTR.template_id = TT.id and TTR.company_id = _companyid
	LEFT JOIN tasks_taskrecurrency_shifts TTS ON TTS.taskrecurrency_id = TTR.id
	LEFT JOIN companies_shift CS ON (CS.id = TTS.shift_id OR CS.id = TTR.shift_id) AND CS.is_active = true
	LEFT JOIN companies_area CA ON CA.id = TTR.area_id and CA.company_id = _companyid
	WHERE TT.company_id = _companyid
	AND TT.type = 'task' AND TT.is_active = true AND TTR.type = 'shifts'
	ORDER BY TT.id, "day", "start", "end";
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_task
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_task"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_task"("_companyid" int4, "_id" int4)
  RETURNS TABLE("area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "description" text, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "machine_status" varchar, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "template_id" int4, "total_score" int4, "type" varchar, "recurrency_type" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	CASE WHEN TTT.area_id IS NULL THEN
		TTR.area_id
	ELSE 
		TTT.area_id
	END::int AS area_id,
TT.comment, 
TT.company_id, 
TT.created_at, 
TTT.description, 
TT.deviance, 
TT.due_at, 
TT.end_date, 
TT.id, 
TTT.machine_status,
TT.max_score, 
TT.modified_at, 
TTT.name, 
TTT.picture, 
TT.recurrency_id, 
TT.score, 
TT.shift_id, 
TT.signed_at, 
TT.signed_by_id, 
TT.start_at, 
TT.start_date, 
TT.status, 
TT.template_id, 
TT.total_score, 
TTT.type,
TTR.type AS recurrency_type
FROM tasks_task TT 
INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
LEFT JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
WHERE TT.company_id = _companyid AND TT.is_active = true AND TT.id = _id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_task_area_full
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_task_area_full"("area_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_task_area_full"("area_id" int4)
  RETURNS "pg_catalog"."text" AS $BODY$
WITH RECURSIVE Areas AS (
   SELECT id,name,parent_id, level
   FROM companies_area
   WHERE id = area_id
   UNION
   SELECT e.id,e.name,e.parent_id, e.level
   FROM companies_area e
   INNER JOIN Areas s ON s.parent_id = e.id
) 
SELECT string_agg(name, ' -> ') AS area FROM (
	SELECT id,name,parent_id, level
	FROM Areas
	ORDER BY Level
) AS T;
$BODY$
  LANGUAGE sql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for get_task_data_bi
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_task_data_bi"("current_company_id" int4, "start_date_utc" timestamptz, "end_date_utc" timestamptz);
CREATE OR REPLACE FUNCTION "public"."get_task_data_bi"("current_company_id" int4, "start_date_utc" timestamptz, "end_date_utc" timestamptz)
  RETURNS TABLE("tasktemplateid" int4, "taskname" varchar, "taskid" int4, "areaid" int4, "areaname" varchar, "status" varchar, "recurrencetype" varchar, "completedby" varchar, "completedat" timestamptz, "completedatdate" date, "completedattime" time, "completeddayoftheweek" varchar, "completedatshiftday" int2, "completedatshiftnr" int4, "completedatweeknr" int4, "completedatyear" int4, "duedate" timestamptz, "duedatedate" date, "duedatetime" time, "duedatedayofweek" varchar, "duedateshiftday" int2, "duedateshiftnr" int4, "duedateweeknr" int4, "duedateyear" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH shifts AS (
			SELECT row_number() OVER (PARTITION BY day, area_id ORDER BY day, area_id DESC, start) AS shiftnr,* FROM companies_shift 
			WHERE company_id = current_company_id --AND day = 1
			AND is_active = true
			ORDER BY day, area_id, start
	)
	SELECT 
		t.template_id AS TaskTemplateId,   
		tt.name AS TaskName,
		t.id AS TaskId,
		ca.id AS AreaId,
		ca.name AS AreaName,
		t.status AS Status,
		ttr.type AS RecurrenceType,
		CONCAT(pu.first_name,' ',pu.last_name)::varchar AS CompletedBy,
		t.signed_at AS CompletedAt,
		t.signed_at::date AS CompletedAtDate,
		t.signed_at::time CompletedAtTime,
		TO_CHAR(t.signed_at, 'Day')::varchar AS CompletedDayOfTheWeek,
		sec.day AS CompletedAtShiftDay,
		sec.shiftnr::int AS CompletedAtShiftNr,
		TO_CHAR(t.signed_at, 'IW')::int As CompletedAtWeekNr,	
		TO_CHAR(t.signed_at, 'IYYY')::int As CompletedAtYear,
		t.due_at As DueDate,
		t.due_at::date As DueDateDate,
		t.due_at::time As DueDateTime,
		TO_CHAR(t.due_at, 'Day')::varchar AS DueDateDayOfWeek,		
		cs.day AS DueDateShiftDay,	
		sed.shiftNr::int AS DueDateShiftNr,	
		TO_CHAR(t.due_at, 'IW')::int As DueDateWeekNr,	
		TO_CHAR(t.due_at, 'IYYY')::int As DueDateYear
		/* */
		FROM tasks_task t 
	INNER JOIN tasks_tasktemplate tt ON tt.id = t.template_id
	LEFT JOIN tasks_taskrecurrency ttr ON ttr.id = t.recurrency_id
	LEFT JOIN companies_area ca ON ca.id = ttr.area_id
	LEFT JOIN companies_shift cs ON cs.id = t.shift_id
	LEFT JOIN shifts sec ON sec.id = (
																			SELECT id FROM shifts s1
																			WHERE TO_CHAR(t.signed_at, 'D')::INT = day::INT 
																			AND t.signed_at::TIME BETWEEN s1.start AND s1.end 
																		)	
	LEFT JOIN shifts sed ON sed.id = t.shift_id
	LEFT JOIN profiles_user pu ON pu.id = t.signed_by_id
	WHERE 
	t.company_id = current_company_id 	AND
	t.start_at < end_date_utc AND --to
  t.due_at > start_date_utc --from 
	ORDER BY taskname, areaid
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_task_data_bi_by_company_by_startenddate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_task_data_bi_by_company_by_startenddate"("current_company_id" int4, "start_date_utc" timestamptz, "end_date_utc" timestamptz);
CREATE OR REPLACE FUNCTION "public"."get_task_data_bi_by_company_by_startenddate"("current_company_id" int4, "start_date_utc" timestamptz, "end_date_utc" timestamptz)
  RETURNS TABLE("tasktemplateid" int4, "taskname" varchar, "taskid" int4, "areaid" int4, "areaname" varchar, "status" varchar, "recurrencetype" varchar, "completedby" varchar, "completedat" timestamptz, "completedatdate" date, "completedattime" time, "completeddayoftheweek" varchar, "completedatshiftday" int2, "completedatshiftnr" int4, "completedatweeknr" int4, "completedatyear" int4, "duedate" timestamptz, "duedatedate" date, "duedatetime" time, "duedatedayofweek" varchar, "duedateshiftday" int2, "duedateshiftnr" int4, "duedateweeknr" int4, "duedateyear" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH shifts AS (
			SELECT row_number() OVER (PARTITION BY day, area_id ORDER BY day, area_id DESC, start) AS shiftnr,* FROM companies_shift 
			WHERE company_id = current_company_id --AND day = 1
			AND is_active = true
			ORDER BY day, area_id, start
	)
	SELECT 
		t.template_id AS TaskTemplateId,   
		tt.name AS TaskName,
		t.id AS TaskId,
		ca.id AS AreaId,
		ca.name AS AreaName,
		t.status AS Status,
		ttr.type AS RecurrenceType,
		CONCAT(pu.first_name,' ',pu.last_name)::varchar AS CompletedBy,
		t.signed_at AS CompletedAt,
		t.signed_at::date AS CompletedAtDate,
		t.signed_at::time CompletedAtTime,
		TO_CHAR(t.signed_at, 'Day')::varchar AS CompletedDayOfTheWeek,
		sec.day AS CompletedAtShiftDay,
		sec.shiftnr::int AS CompletedAtShiftNr,
		TO_CHAR(t.signed_at, 'IW')::int As CompletedAtWeekNr,	
		TO_CHAR(t.signed_at, 'IYYY')::int As CompletedAtYear,
		t.due_at As DueDate,
		t.due_at::date As DueDateDate,
		t.due_at::time As DueDateTime,
		TO_CHAR(t.due_at, 'Day')::varchar AS DueDateDayOfWeek,		
		cs.day AS DueDateShiftDay,	
		sed.shiftNr::int AS DueDateShiftNr,	
		TO_CHAR(t.due_at, 'IW')::int As DueDateWeekNr,	
		TO_CHAR(t.due_at, 'IYYY')::int As DueDateYear
		/* */
		FROM tasks_task t 
	INNER JOIN tasks_tasktemplate tt ON tt.id = t.template_id
	LEFT JOIN tasks_taskrecurrency ttr ON ttr.id = t.recurrency_id
	LEFT JOIN companies_area ca ON ca.id = ttr.area_id
	LEFT JOIN companies_shift cs ON cs.id = t.shift_id
	LEFT JOIN shifts sec ON sec.id = (
																			SELECT id FROM shifts s1
																			WHERE TO_CHAR(t.signed_at, 'D')::INT = day::INT 
																			AND t.signed_at::TIME BETWEEN s1.start AND s1.end 
																		)	
	LEFT JOIN shifts sed ON sed.id = t.shift_id
	LEFT JOIN profiles_user pu ON pu.id = t.signed_by_id
	WHERE 
	t.company_id = current_company_id 	AND
	t.start_at < end_date_utc AND --to
  t.due_at > start_date_utc --from 
	ORDER BY t.template_id, t.id, areaid
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_taskrecurrencies
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_taskrecurrencies"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_taskrecurrencies"("_companyid" int4)
  RETURNS TABLE("id" int4, "type" varchar, "date" date, "week" int4, "day" int4, "month" int4, "company_id" int4, "area_id" int4, "shift_id" int4, "template_id" int4, "start_date" date, "end_date" date, "weekday0" bool, "weekday1" bool, "weekday2" bool, "weekday3" bool, "weekday4" bool, "weekday5" bool, "weekday6" bool, "month_recurrency" varchar, "weekday" int4, "weekday_number" int4, "is_once_per_week" bool, "is_once_per_month" bool) AS $BODY$BEGIN
	RETURN QUERY
SELECT 
TC.id, 
TC.type, 
TC.date, 
TC.week, 
TC.day, 
TC.month, 
TC.company_id, 
TC.area_id ,
TC.shift_id, 
TC.template_id, 
TC.start_date, 
TC.end_date, 
TC.weekday0, 
TC.weekday1, 
TC.weekday2, 
TC.weekday3, 
TC.weekday4, 
TC.weekday5, 
TC.weekday6, 
TC.month_recurrency, 
TC.weekday, 
TC.weekday_number, 
TC.is_once_per_week, 
TC.is_once_per_month 
FROM tasks_taskrecurrency TC WHERE TC.company_id = _companyid AND TC.is_active = true;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_taskrecurrency
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_taskrecurrency"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_taskrecurrency"("_companyid" int4, "_id" int4)
  RETURNS TABLE("id" int4, "type" varchar, "date" date, "week" int4, "day" int4, "month" int4, "company_id" int4, "area_id" int4, "shift_id" int4, "template_id" int4, "start_date" date, "end_date" date, "weekday0" bool, "weekday1" bool, "weekday2" bool, "weekday3" bool, "weekday4" bool, "weekday5" bool, "weekday6" bool, "month_recurrency" varchar, "weekday" int4, "weekday_number" int4, "is_once_per_week" bool, "is_once_per_month" bool) AS $BODY$BEGIN
	RETURN QUERY
SELECT 
TC.id, 
TC.type, 
TC.date, 
TC.week, 
TC.day, 
TC.month, 
TC.company_id, 
TC.area_id ,
TC.shift_id, 
TC.template_id, 
TC.start_date, 
TC.end_date, 
TC.weekday0, 
TC.weekday1, 
TC.weekday2, 
TC.weekday3, 
TC.weekday4, 
TC.weekday5, 
TC.weekday6, 
TC.month_recurrency, 
TC.weekday, 
TC.weekday_number, 
TC.is_once_per_week, 
TC.is_once_per_month 
FROM tasks_taskrecurrency TC WHERE TC.company_id = _companyid AND TC.id = _id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "deeplink_id" int4, "deeplink_to" varchar, "description" text, "description_file" varchar, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "index" int4, "machine_status" varchar, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "planned_time" int4, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "template_id" int4, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "signed_by" varchar, "time_realized_by" varchar, "video" varchar, "video_thumbnail" varchar, "actionnr" int4, "commentnr" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH taskstoday AS (
			SELECT 
				TT.template_id,
					CASE WHEN TTT.area_id IS NULL THEN
						TTR.area_id
					ELSE 
						TTT.area_id
					END::int AS area_id,
				TT.comment, 
				TT.company_id, 
				TT.created_at, 
				TTT.deeplink_id,
				TTT.deeplink_to,
				TTT.description, 
				TTT.description_file,
				TT.deviance, 
				TT.due_at, 
				TT.end_date, 
				TT.id, 
				TTT.index,
				TTT.machine_status,
				TT.max_score, 
				TT.modified_at, 
				TTT.name, 
				TTT.picture, 
				TTT.planned_time,
				TT.recurrency_id, 
				TT.score, 
				TT.shift_id, 
				TT.signed_at, 
				TT.signed_by_id, 
				TT.start_at, 
				TT.start_date, 
				TT.status,  
				TT.total_score, 
				TTT.type,
				TTR.type AS recurrency_type,
				TT.time_realized_by_id,
				TT.time_taken,
				CASE WHEN PU.id IS NOT NULL THEN
					CONCAT(PU.first_name, ' ', PU.last_name)::varchar
				ELSE
					NULL
				END AS signed_by,
				CASE WHEN PU2.id IS NOT NULL THEN
					CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
				ELSE
					NULL
				END AS time_realized_by,
				TTT.video,
				TTT.video_thumbnail
				FROM tasks_task TT 
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
				LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
				LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
				WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.type = 'task' 
				AND ((_timestamp BETWEEN TT.start_date AND TT.end_date) OR TT.start_date = _timestamp::date OR TT.end_date = _timestamp::date) 
				
				AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id) OR _areaid= 0) 
				--AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 

				ORDER BY TT.start_at, TT.start_date, TTT.name
	),
	tasksweekmonth AS (
		 SELECT 
				DISTINCT ON (TT.template_id) TT.template_id,
					CASE WHEN TTT.area_id IS NULL THEN
						TTR.area_id
					ELSE 
						TTT.area_id
					END::int AS area_id,
				TT.comment, 
				TT.company_id, 
				TT.created_at, 
				TTT.deeplink_id,
				TTT.deeplink_to,
				TTT.description, 
				TTT.description_file,
				TT.deviance, 
				TT.due_at, 
				TT.end_date, 
				TT.id, 
				TTT.index,
				TTT.machine_status,
				TT.max_score, 
				TT.modified_at, 
				TTT.name, 
				TTT.picture, 
				TTT.planned_time,
				TT.recurrency_id, 
				TT.score, 
				TT.shift_id, 
				TT.signed_at, 
				TT.signed_by_id, 
				TT.start_at, 
				TT.start_date, 
				TT.status, 
				TT.total_score, 
				TTT.type,
				TTR.type AS recurrency_type,
				TT.time_realized_by_id,
				TT.time_taken,
				CASE WHEN PU.id IS NOT NULL THEN
					CONCAT(PU.first_name, ' ', PU.last_name)::varchar
				ELSE
					NULL
				END AS signed_by,
				CASE WHEN PU2.id IS NOT NULL THEN
					CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
				ELSE
					NULL
				END AS time_realized_by,
				TTT.video,
				TTT.video_thumbnail
				FROM tasks_task TT 
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
				LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
				LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
				WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.type = 'task' 
				AND (TT.start_at > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) 
				AND TT.start_at < ((_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) + interval '7 day'))
				
				ORDER BY TT.template_id, 
				CASE WHEN TT.due_at > _timestamp::timestamp AND TT.start_at < _timestamp::timestamp AND TT.shift_id IS NULL THEN 0 -- for today or this shift
				     WHEN TT.due_at < _timestamp::timestamp AND TT.start_at < _timestamp::timestamp AND TT.shift_id IS NULL THEN 1 -- previous day or shift
						 WHEN TT.due_at > _timestamp::timestamp AND TT.start_at > _timestamp::timestamp AND TT.shift_id IS NULL  THEN 2 -- next day or shift
						 ELSE 3 END,
				TT.start_at DESC, TT.start_date, TTT.name
	)
	SELECT DISTINCT 
		T.area_id,
		T.comment, 
		T.company_id, 
		T.created_at, 
		T.deeplink_id,
		T.deeplink_to,
		T.description, 
		T.description_file,
		T.deviance, 
		T.due_at, 
		T.end_date, 
		T.id, 
		T.index,
		T.machine_status,
		T.max_score, 
		T.modified_at, 
		T.name, 
		T.picture, 
		T.planned_time,
		T.recurrency_id, 
		T.score, 
		T.shift_id, 
		T.signed_at, 
		T.signed_by_id, 
		T.start_at, 
		T.start_date, 
		T.status, 
		T.template_id, 
		T.total_score, 
		T.type,
		T.recurrency_type,
		T.time_realized_by_id,
		T.time_taken,
		T.signed_by,
		T.time_realized_by,
		T.video,
		T.video_thumbnail,
		(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE (AA.task_id = T.id) AND AA.is_active = true) AS actionnr,
		(SELECT Count(CC.id)::int4 FROM comments CC WHERE (CC.task_id = T.id) AND CC.is_active = true) AS commentnr
		FROM (
		SELECT * FROM (
					-- tasks of type shifts or no recurrency purely based on timestamp.  
				SELECT * FROM taskstoday TD WHERE (TD.recurrency_type = 'shifts' OR TD.recurrency_type = 'no recurrency')
			)
			AS A
			UNION
			-- tasks of type month or week must be distinct based on it's template. 
			SELECT * FROM (
				SELECT * FROM tasksweekmonth TW WHERE (TW.recurrency_type = 'week' OR TW.recurrency_type = 'month')
			)
			AS B
	) AS T 
	WHERE
				(EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = T.area_id) OR _areaid= 0) 
		AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = T.template_id) OR _userid = 0) 
	ORDER BY T.index, T.created_at		
	LIMIT CASE WHEN (_limit > 0) THEN _limit END 
  OFFSET CASE WHEN (_offset > 0) THEN _offset END;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_by_audit
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_by_audit"("_companyid" int4, "_auditid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_by_audit"("_companyid" int4, "_auditid" int4)
  RETURNS TABLE("area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "description" text, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "index" int4, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "template_id" int4, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "actionnr" int4, "commentnr" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT DISTINCT
	TTT.area_id,
TT.comment, 
TT.company_id, 
TT.created_at, 
TTT.description, 
TT.deviance, 
TT.due_at, 
TT.end_date, 
TT.id, 
TTT.index,
TT.max_score, 
TT.modified_at, 
TTT.name, 
TTT.picture, 
TT.recurrency_id, 
TT.score, 
TT.shift_id, 
TT.signed_at, 
TT.signed_by_id, 
TT.start_at, 
TT.start_date, 
TT.status, 
TT.template_id, 
TT.total_score, 
TTT.type,
TTR.type AS recurrency_type,
TT.time_realized_by_id,
TT.time_taken,
(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE (AA.task_id = TT.id) AND AA.is_active = true) AS actionnr,
(SELECT Count(CC.id)::int4 FROM comments CC WHERE (CC.task_id = TT.id) AND CC.is_active = true) AS commentnr
FROM tasks_task TT 
INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
INNER JOIN audits_audit_tasks AAT ON AAT.task_id = TT.id AND AAT.audit_id = _auditid
LEFT JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
WHERE TT.company_id = _companyid AND TT.is_active = true
ORDER BY TTT.index ASC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_by_checklist
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_by_checklist"("_companyid" int4, "_checklistid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_by_checklist"("_companyid" int4, "_checklistid" int4)
  RETURNS TABLE("area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "description" text, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "index" int4, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "template_id" int4, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "actionnr" int4, "commentnr" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT DISTINCT
	TTT.area_id,
TT.comment, 
TT.company_id, 
TT.created_at, 
TTT.description, 
TT.deviance, 
TT.due_at, 
TT.end_date, 
TT.id, 
TTT.index,
TT.max_score, 
TT.modified_at, 
TTT.name, 
TTT.picture, 
TT.recurrency_id, 
TT.score, 
TT.shift_id, 
TT.signed_at, 
TT.signed_by_id, 
TT.start_at, 
TT.start_date, 
TT.status, 
TT.template_id, 
TT.total_score, 
TTT.type,
TTR.type AS recurrency_type,
TT.time_realized_by_id,
TT.time_taken,
(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE (AA.task_id = TT.id) AND AA.is_active = true) AS actionnr,
(SELECT Count(CC.id)::int4 FROM comments CC WHERE (CC.task_id = TT.id) AND CC.is_active = true) AS commentnr
FROM tasks_task TT 
INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
INNER JOIN checklists_checklist_tasks CCT ON CCT.task_id = TT.id AND CCT.checklist_id = _checklistid
LEFT JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
WHERE TT.company_id = _companyid AND TT.is_active = true
ORDER BY TTT.index ASC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_by_shift
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_by_shift"("_companyid" int4, "_timestamp" timestamptz, "_shiftid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_by_shift"("_companyid" int4, "_timestamp" timestamptz, "_shiftid" int4)
  RETURNS TABLE("area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "deeplink_id" int4, "deeplink_to" varchar, "description" text, "description_file" varchar, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "index" int4, "machine_status" varchar, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "planned_time" int4, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "template_id" int4, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "signed_by" varchar, "time_realized_by" varchar, "video" varchar, "video_thumbnail" varchar) AS $BODY$BEGIN
	RETURN QUERY
	WITH taskstoday AS (
			SELECT 
				TT.template_id,
					CASE WHEN TTT.area_id IS NULL THEN
						TTR.area_id
					ELSE 
						TTT.area_id
					END::int AS area_id,
				TT.comment, 
				TT.company_id, 
				TT.created_at, 
				TTT.deeplink_id,
				TTT.deeplink_to,
				TTT.description, 
				TTT.description_file,
				TT.deviance, 
				TT.due_at, 
				TT.end_date, 
				TT.id, 
				TTT.index,
				TTT.machine_status,
				TT.max_score, 
				TT.modified_at, 
				TTT.name, 
				TTT.picture, 
				TTT.planned_time,
				TT.recurrency_id, 
				TT.score, 
				TT.shift_id, 
				TT.signed_at, 
				TT.signed_by_id, 
				TT.start_at, 
				TT.start_date, 
				TT.status,  
				TT.total_score, 
				TTT.type,
				TTR.type AS recurrency_type,
				TT.time_realized_by_id,
				TT.time_taken,
				CASE WHEN PU.id IS NOT NULL THEN
					CONCAT(PU.first_name, ' ', PU.last_name)::varchar
				ELSE
					NULL
				END AS signed_by,
				CASE WHEN PU2.id IS NOT NULL THEN
					CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
				ELSE
					NULL
				END AS time_realized_by,
				TTT.video,
				TTT.video_thumbnail
				FROM tasks_task TT 
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
				LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
				LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
				WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.type = 'task' 
				AND ((_timestamp BETWEEN TT.start_date AND TT.end_date) OR TT.start_date = _timestamp::date OR TT.end_date = _timestamp::date) 
				ORDER BY TT.start_at, TT.start_date, TTT.name
	),
	tasksweekmonth AS (
		 SELECT 
				DISTINCT ON (TT.template_id) TT.template_id,
					CASE WHEN TTT.area_id IS NULL THEN
						TTR.area_id
					ELSE 
						TTT.area_id
					END::int AS area_id,
				TT.comment, 
				TT.company_id, 
				TT.created_at, 
				TTT.deeplink_id,
				TTT.deeplink_to,
				TTT.description, 
				TTT.description_file,
				TT.deviance, 
				TT.due_at, 
				TT.end_date, 
				TT.id, 
				TTT.index,
				TTT.machine_status,
				TT.max_score, 
				TT.modified_at, 
				TTT.name, 
				TTT.picture, 
				TTT.planned_time,
				TT.recurrency_id, 
				TT.score, 
				TT.shift_id, 
				TT.signed_at, 
				TT.signed_by_id, 
				TT.start_at, 
				TT.start_date, 
				TT.status, 
				TT.total_score, 
				TTT.type,
				TTR.type AS recurrency_type,
				TT.time_realized_by_id,
				TT.time_taken,
				CASE WHEN PU.id IS NOT NULL THEN
					CONCAT(PU.first_name, ' ', PU.last_name)::varchar
				ELSE
					NULL
				END AS signed_by,
				CASE WHEN PU2.id IS NOT NULL THEN
					CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
				ELSE
					NULL
				END AS time_realized_by,
				TTT.video,
				TTT.video_thumbnail
				FROM tasks_task TT 
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
				LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
				LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
				WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.type = 'task' 
				AND (TT.due_at > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) AND TT.due_at < ((_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) + interval '7 day'))
				ORDER BY TT.template_id, 
				CASE WHEN TT.due_at::date = _timestamp::date AND TT.start_at::date > _timestamp::date AND TT.shift_id IS NULL THEN 0 
						 WHEN TT.due_at::date = _timestamp::date + '1 day'::interval AND TT.start_at::date = _timestamp::date AND TT.shift_id IS NULL THEN 1 
						 ELSE 2 END,
				TT.start_at, TT.start_date, TTT.name
	)
	SELECT DISTINCT 
		T.area_id,
		T.comment, 
		T.company_id, 
		T.created_at, 
		T.deeplink_id,
		T.deeplink_to,
		T.description, 
		T.description_file,
		T.deviance, 
		T.due_at, 
		T.end_date, 
		T.id, 
		T.index,
		T.machine_status,
		T.max_score, 
		T.modified_at, 
		T.name, 
		T.picture, 
		T.planned_time,
		T.recurrency_id, 
		T.score, 
		T.shift_id, 
		T.signed_at, 
		T.signed_by_id, 
		T.start_at, 
		T.start_date, 
		T.status, 
		T.template_id, 
		T.total_score, 
		T.type,
		T.recurrency_type,
		T.time_realized_by_id,
		T.time_taken,
		T.signed_by,
		T.time_realized_by,
		T.video,
		T.video_thumbnail
		FROM (
		SELECT * FROM (
					-- tasks of type shifts or no recurrency purely based on timestamp.  
				SELECT * FROM taskstoday TD WHERE (TD.recurrency_type = 'shifts' OR TD.recurrency_type = 'no recurrency')
			)
			AS A
			UNION
			-- tasks of type month or week must be distinct based on it's template. 
			SELECT * FROM (
				SELECT * FROM tasksweekmonth TW WHERE (TW.recurrency_type = 'week' OR TW.recurrency_type = 'month')
			)
			AS B
	) AS T 
	WHERE T.shift_id = _shiftid
	ORDER BY T.index;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_by_start_end_date
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_by_start_end_date"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_by_start_end_date"("_companyid" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "deeplink_id" int4, "deeplink_to" varchar, "description" text, "description_file" varchar, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "index" int4, "machine_status" varchar, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "planned_time" int4, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "template_id" int4, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "signed_by" varchar, "time_realized_by" varchar, "video" varchar, "video_thumbnail" varchar, "actionnr" int4, "commentnr" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	CASE WHEN TTT.area_id IS NULL THEN
		TTR.area_id
	ELSE 
		TTT.area_id
	END::int AS area_id,
TT.comment, 
TT.company_id, 
TT.created_at, 
TTT.deeplink_id,
TTT.deeplink_to,
TTT.description, 
TTT.description_file,
TT.deviance, 
TT.due_at, 
TT.end_date, 
TT.id, 
TTT.index,
TTT.machine_status,
TT.max_score, 
TT.modified_at, 
TTT.name, 
TTT.picture, 
TTT.planned_time,
TT.recurrency_id, 
TT.score, 
TT.shift_id, 
TT.signed_at, 
TT.signed_by_id, 
TT.start_at, 
TT.start_date, 
TT.status, 
TT.template_id, 
TT.total_score, 
TTT.type,
TTR.type AS recurrency_type,
TT.time_realized_by_id,
TT.time_taken,
CASE WHEN PU.id IS NOT NULL THEN
	CONCAT(PU.first_name, ' ', PU.last_name)::varchar
ELSE
	NULL
END AS signed_by,
CASE WHEN PU2.id IS NOT NULL THEN
	CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
ELSE
	NULL
END AS time_realized_by,
TTT.video,
TTT.video_thumbnail,
(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE (AA.task_id = TT.id) AND AA.is_active = true) AS actionnr,
(SELECT Count(CC.id)::int4 FROM comments CC WHERE (CC.task_id = TT.id) AND CC.is_active = true) AS commentnr
FROM tasks_task TT 
INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.type = 'task' AND TT.start_at >= _starttimestamp AND TT.due_at <= _endtimestamp
	AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id) OR _areaid= 0) 
	AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
ORDER BY TT.start_at DESC, TT.start_date DESC, TTT.name
	LIMIT CASE WHEN (_limit > 0) THEN _limit END 
  OFFSET CASE WHEN (_offset > 0) THEN _offset END;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_extended_data
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_extended_data"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_extended_data"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0)
  RETURNS TABLE("id" int4, "time_realized_by_id" int4, "time_taken" int4, "time_realized_by" varchar) AS $BODY$BEGIN
	RETURN QUERY
		SELECT TT.id, TT.time_realized_by_id, TT.time_taken, CONCAT(PU.first_name, ' ',PU.last_name)::varchar AS time_realized_by
		FROM tasks_task TT
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TT.template_id
		LEFT JOIN profiles_user PU ON PU.id = TT.time_realized_by_id AND PU.company_id = _companyid
		WHERE ((TT.start_date >= _timestamp AND TT.end_date < _timestamp) 
					 OR TT.start_date = _timestamp::date 
					 OR TT.end_date = _timestamp::date
					 OR TT.signed_at::date = _timestamp::date)
		AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id) OR _areaid= 0) 
		AND TT.company_id = _companyid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_history
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_history"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_history"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0)
  RETURNS TABLE("id" int4, "signed_at" timestamptz, "signed_by_id" int4, "signed_by" varchar, "status" varchar, "template_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT DISTINCT 
		TT.id, 
		TTSR.signed_at, 
		TTSR.signed_by_id, 
		CONCAT(PU.first_name, ' ',PU.last_name)::varchar AS signed_by,
		TTSR.status,
		TT.template_id
		FROM tasks_task TT
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TT.template_id
		INNER JOIN tasks_taskstatusrecord TTSR ON TTSR.task_id = TT.id
		LEFT JOIN profiles_user PU ON PU.id = TTSR.signed_by_id AND PU.company_id = _companyid
		WHERE ((_timestamp BETWEEN TT.start_date AND TT.end_date) OR TT.start_date = _timestamp::date OR TT.end_date = _timestamp::date)
		AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id) OR _areaid= 0) 
		AND TT.company_id = _companyid
		ORDER BY TT.id, TTSR.signed_at;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_history_firsts
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_history_firsts"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_history_firsts"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0)
  RETURNS TABLE("id" int4, "signed_at" timestamptz, "signed_by_id" int4, "signed_by" varchar, "status" varchar, "template_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT DISTINCT ON (TTSR.task_id)
		TT.id, 
		TTSR.signed_at, 
		TTSR.signed_by_id, 
		CONCAT(PU.first_name, ' ',PU.last_name)::varchar AS signed_by,
		TTSR.status,
		TT.template_id
		FROM tasks_task TT
		INNER JOIN tasks_taskstatusrecord TTSR ON TTSR.task_id = TT.id
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TT.template_id
		LEFT JOIN profiles_user PU ON PU.id = TTSR.signed_by_id AND PU.company_id = _companyid
		WHERE ((TT.start_date > (_timestamp::timestamp-'6 day'::interval)::date AND TT.end_date < (_timestamp::timestamp + '1 day'::interval)::date) 
					OR TT.start_date = _timestamp::date 
					OR TT.end_date = _timestamp::date
					OR TT.signed_at::date = _timestamp::date)
		AND TT.company_id = _companyid
		AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id) OR _areaid= 0) 
		ORDER BY TTSR.task_id ASC, TTSR.signed_at ASC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_overdue
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_overdue"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_overdue"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("template_id" int4, "area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "deeplink_id" int4, "deeplink_to" varchar, "description" text, "description_file" varchar, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "machine_status" varchar, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "planned_time" int4, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "signed_by" varchar, "time_realized_by" varchar, "video" varchar, "video_thumbnail" varchar, "actionnr" int4, "commentnr" int4) AS $BODY$
	DECLARE 
	_start_date timestamp;
	_start_date_wt timestamp;
	_end_date timestamp;
	_end_date_wt timestamp;
	BEGIN
	SELECT S.start_date, S.end_date, 
					 get_timestamp_without_companytimezone(_companyid ,S.start_date::timestamp) AS start_date_wt, 
					 get_timestamp_without_companytimezone(_companyid ,S.end_date::timestamp) AS end_date_wt 
					 INTO _start_date, _end_date, _start_date_wt, _end_date_wt
					 FROM get_shifts_datetimes_on_day_by_timestamp(_companyid, _timestamp) AS S;
					 
	RETURN QUERY
			WITH excludedtemplates_for_today AS ( 
			  -- exclude all items that have a active task now
				SELECT DISTINCT TT.template_id FROM tasks_task TT 
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.type <> 'shifts' AND TTR.is_active = true
				WHERE TT.start_at <= _timestamp::timestamp AND TT.due_at >= _timestamp::timestamp AND TT.company_id = _companyid AND TT.is_active = true
				AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id)  OR _areaid= 0) 
			)
			SELECT * FROM (
					SELECT * FROM (
						SELECT DISTINCT ON (TT.template_id) TT.template_id, 
						CASE WHEN TTT.area_id IS NULL THEN
							TTR.area_id
						ELSE 
							TTT.area_id
						END::int AS area_id,
						TT.comment, 
						TT.company_id, 
						TT.created_at, 
						TTT.deeplink_id,
						TTT.deeplink_to,
						TTT.description, 
						TTT.description_file,
						TT.deviance, 
						TT.due_at, 
						TT.end_date, 
						TT.id, 
						TTT.machine_status,
						TT.max_score, 
						TT.modified_at, 
						TTT.name, 
						TTT.picture, 
						TTT.planned_time,
						TT.recurrency_id, 
						TT.score, 
						TT.shift_id, 
						TT.signed_at, 
						TT.signed_by_id, 
						TT.start_at, 
						TT.start_date, 
						TT.status, 
						TT.total_score, 
						TTT.type,
						TTR.type AS recurrency_type,
						TT.time_realized_by_id,
						TT.time_taken,
						CASE WHEN PU.id IS NOT NULL THEN
							CONCAT(PU.first_name, ' ', PU.last_name)::varchar
						ELSE
							NULL
						END AS signed_by,
						CASE WHEN PU2.id IS NOT NULL THEN
							CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
						ELSE
							NULL
						END AS time_realized_by,
						TTT.video,
						TTT.video_thumbnail,
						(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE (AA.task_id = TT.id) AND AA.is_active = true) AS actionnr,
						(SELECT Count(CC.id)::int4 FROM comments CC WHERE (CC.task_id = TT.id) AND CC.is_active = true) AS commentnr 
						FROM tasks_task TT 
						INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
						INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true
						INNER JOIN companies_area CA ON CA.id = TTR.area_id AND CA.is_active = true
						LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
						LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
						WHERE TT.company_id = _companyid AND TTT.is_active = true AND TT.is_active = true AND TT.signed_at IS NULL AND (TTR.type <> 'shifts')
						AND (TTR.end_date > _timestamp::timestamp OR TTR.end_date IS NULL) -- exclude non accassable tasks
						AND TT.due_at < _timestamp::timestamp 
						AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id)  OR _areaid= 0) 
						AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
						
						-- exclude all the items that the last task before the current date that have a filled in (skipped, ok, not ok) status. 
							AND NOT (EXISTS	(SELECT ETD.template_id FROM (SELECT T.template_id FROM (
												SELECT DISTINCT ON (TT.template_id) TT.template_id, TT.id, TT.status, TT.signed_at, TT.start_at, TT.due_at FROM tasks_task TT 
												INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
												INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND  TTR.type <> 'shifts' AND TTR.is_active = true
												WHERE TT.company_id = _companyid AND TT.due_at < _timestamp::timestamp AND TT.is_active = true
												AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id)  OR _areaid= 0) 
												ORDER BY TT.template_id, TT.start_at DESC, TT.start_date DESC, TT.end_date DESC
											) AS T
											WHERE T.signed_at IS NOT NULL) AS ETD WHERE ETD.template_id = TT.template_id))
						
						
						-- exclude all items that are month or week and have a still to fill in task this week where the due_at is not passed the timestamp
					  -- week and month items that have a earlier item in the week but not this day are excluded from this list
							AND NOT (EXISTS	(SELECT ETW.template_id FROM (SELECT TT.template_id FROM tasks_task TT 
															INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true
															INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true
															WHERE TTT.company_id = _companyid AND (TTR.type = 'week' OR TTR.type = 'month')
															AND TT.start_date > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval)
															AND TT.end_date < ((_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) + interval '7 day')
															AND TT.due_at > _timestamp::timestamp AND TT.is_active = true
															AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id)  OR _areaid= 0) 
															AND NOT EXISTS ( 
																	SELECT T.template_id FROM (
																				SELECT DISTINCT ON (TT.template_id) TT.template_id, TT.id, TT.signed_at FROM tasks_task TT 
																				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
																				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true
																				WHERE TT.company_id = _companyid AND TT.due_at < _timestamp::timestamp AND TT.start_date > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval)
																				AND (TTR.type = 'week' OR TTR.type = 'month') AND TT.is_active = true
																				ORDER BY TT.template_id, TT.start_at DESC, TT.start_date DESC, TT.end_date DESC
																	) AS T WHERE T.signed_at IS NULL
																		AND NOT EXISTS  ( 
																			 SELECT excludedtemplates_for_today.template_id FROM excludedtemplates_for_today WHERE excludedtemplates_for_today.template_id = T.template_id
																	) AND T.template_id = TT.template_id 
															)
									) AS ETW WHERE ETW.template_id = TT.template_id))	
						
						
						AND NOT (EXISTS (SELECT excludedtemplates_for_today.template_id FROM excludedtemplates_for_today WHERE excludedtemplates_for_today.template_id = TT.template_id )) 
						AND TT.status = 'todo'
						ORDER BY TT.template_id, TT.start_at DESC, TT.start_date DESC, TT.end_date, TTT.name DESC
					) AS T
					UNION
					SELECT TT.template_id, 
						CASE WHEN TTT.area_id IS NULL THEN
							TTR.area_id
						ELSE 
							TTT.area_id
						END::int AS area_id,
						TT.comment, 
						TT.company_id, 
						TT.created_at, 
						TTT.deeplink_id,
						TTT.deeplink_to,
						TTT.description, 
						TTT.description_file,
						TT.deviance, 
						TT.due_at, 
						TT.end_date, 
						TT.id, 
						TTT.machine_status,
						TT.max_score, 
						TT.modified_at, 
						TTT.name, 
						TTT.picture, 
						TTT.planned_time,
						TT.recurrency_id, 
						TT.score, 
						TT.shift_id, 
						TT.signed_at, 
						TT.signed_by_id, 
						TT.start_at, 
						TT.start_date, 
						TT.status, 
						TT.total_score, 
						TTT.type,
						TTR.type AS recurrency_type,
						TT.time_realized_by_id,
						TT.time_taken,
						CASE WHEN PU.id IS NOT NULL THEN
							CONCAT(PU.first_name, ' ', PU.last_name)::varchar
						ELSE
							NULL
						END AS signed_by,
						CASE WHEN PU2.id IS NOT NULL THEN
							CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
						ELSE
							NULL
						END AS time_realized_by,
						TTT.video,
						TTT.video_thumbnail,
						(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE (AA.task_id = TT.id) AND AA.is_active = true) AS actionnr,
						(SELECT Count(CC.id)::int4 FROM comments CC WHERE (CC.task_id = TT.id) AND CC.is_active = true) AS commentnr 
					FROM tasks_task TT
					INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
					INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true
					LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
					LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
					WHERE TT.signed_at::timestamp BETWEEN _start_date_wt AND _end_date_wt
					AND TT.signed_at::timestamp > get_timestamp_without_companytimezone(_companyid , TT.due_at::timestamp)
					AND TT.company_id = _companyid
					AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id)  OR _areaid= 0) 
					AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
			) AS C
			ORDER BY C.start_at DESC, C.start_date DESC, C.end_date, C.name DESC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_properties
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_properties"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_properties"("_companyid" int4)
  RETURNS TABLE("id" int4, "company_id" int4, "task_id" int4, "property_id" int4, "template_property_id" int4, "user_id" int4, "value_int" int4, "value_string" text, "value_decimal" numeric, "value_time" time, "value_date" timestamp, "value_bool" bool, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
		SELECT 
		TP.id, 
		TP.company_id, 
		TP.task_id, 
		TP.property_id, 
		TP.template_property_id, 
		TP.user_id, 
		TP.value_int, 
		TP.value_string, 
		TP.value_decimal, 
		TP.value_time, 
		TP.value_date, 
		TP.value_bool, 
		TP.created_at, 
		TP.modified_at
		FROM tasks_properties TP
		WHERE TP.company_id = _companyid
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_properties_user_data
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_properties_user_data"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_properties_user_data"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0)
  RETURNS TABLE("id" int4, "company_id" int4, "task_id" int4, "property_id" int4, "template_property_id" int4, "user_id" int4, "value_int" int4, "value_string" text, "value_decimal" numeric, "value_time" time, "value_date" timestamp, "value_bool" bool, "created_at" timestamp, "modified_at" timestamp, "modified_by" varchar) AS $BODY$BEGIN
	RETURN QUERY
		SELECT 
		TP.id, TP.company_id, TP.task_id, TP.property_id, TP.template_property_id, TP.user_id, 
		TP.value_int, TP.value_string, TP.value_decimal, TP.value_time, TP.value_date, TP.value_bool, TP.created_at, TP.modified_at, 
		CONCAT(PU.first_name, ' ',PU.last_name)::varchar AS modified_by
		FROM tasks_properties TP
		INNER JOIN tasks_task TT ON TT.id = TP.task_id AND TT.is_active = true AND TT.company_id = _companyid
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true AND TTT.company_id = _companyid
		INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TT.template_id AND TTR.is_active = true AND TTR.company_id = _companyid
		LEFT JOIN profiles_user PU ON PU.id = TP.user_id AND PU.company_id = _companyid
		WHERE ((TT.start_date >= _timestamp AND TT.end_date < _timestamp) 
					 OR TT.start_date = _timestamp::date 
					 OR TT.end_date = _timestamp::date
					 OR TT.signed_at::date = _timestamp::date
					 OR TP.modified_at::date = _timestamp::date)
		AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id) OR _areaid= 0) 
		AND TT.company_id = _companyid
		AND TT.is_active = true
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_related_to_lastweek
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_related_to_lastweek"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4, "_timespanindays" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_related_to_lastweek"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0, "_timespanindays" int4=0)
  RETURNS TABLE("area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "deeplink_id" int4, "deeplink_to" varchar, "description" text, "description_file" varchar, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "index" int4, "machine_status" varchar, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "planned_time" int4, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "template_id" int4, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "signed_by" varchar, "time_realized_by" varchar, "video" varchar, "video_thumbnail" varchar, "actionnr" int4, "commentnr" int4) AS $BODY$
DECLARE 
	_start_date timestamp;
	_start_date_wt timestamp;
	_end_date timestamp;
	_end_date_wt timestamp;
BEGIN
		SELECT ST.start_date , get_timestamp_without_companytimezone(_companyid , ST.start_date) AS start_date_wt INTO _start_date, _start_date_wt FROM (
			SELECT *,
				 _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER-7 + '1 day'::interval + S.start AS start_date
			FROM (
				SELECT first_shift_id AS id, first_start AS start FROM get_shift_first_last_on_day_by_timestamp(_companyid,  _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER-7 + '1 day'::interval) 
			) AS S 
		) AS ST;
		SELECT ST.end_date, get_timestamp_without_companytimezone(_companyid , ST.end_date) AS end_date_wt INTO _end_date, _end_date_wt FROM (
			SELECT *, 
				CASE WHEN S.end > S.start THEN
					 _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER + S.end 
				ELSE
					 _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER + '1 day'::interval + S.end
				END AS end_date
				FROM (
					SELECT last_shift_id AS id, last_end AS end, first_start AS start FROM get_shift_first_last_on_day_by_timestamp(_companyid,  _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER-7 + '7 day'::interval) 
			) AS S 
		) AS ST;
		
		IF _start_date IS NULL AND _end_date IS NULL THEN
				_start_date = _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER-7 + '1 day'::interval;
				_end_date = _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER-7 + '8 day'::interval;
				_start_date_wt = get_timestamp_without_companytimezone(_companyid , _start_date::timestamp);  
				_end_date_wt = get_timestamp_without_companytimezone(_companyid , _end_date::timestamp);  
		END IF;
		IF _start_date IS NOT NULL AND _end_date IS NULL THEN
				_end_date = _start_date + '7 day'::interval;
				_end_date_wt = get_timestamp_without_companytimezone(_companyid , _end_date::timestamp);  
		END IF; 
		IF _start_date IS NULL AND _end_date IS NOT NULL THEN
				_start_date = _end_date - '7 day'::interval;
				_start_date_wt = get_timestamp_without_companytimezone(_companyid , _start_date::timestamp);  
		END IF;
		
	RETURN QUERY
	SELECT 	T.area_id,
		T.comment, 
		T.company_id, 
		T.created_at, 
		T.deeplink_id,
		T.deeplink_to,
		T.description, 
		T.description_file,
		T.deviance, 
		T.due_at, 
		T.end_date, 
		T.id, 
		T.index,
		T.machine_status,
		T.max_score, 
		T.modified_at, 
		T.name, 
		T.picture, 
		T.planned_time,
		T.recurrency_id, 
		T.score, 
		T.shift_id, 
		T.signed_at, 
		T.signed_by_id, 
		T.start_at, 
		T.start_date, 
		T.status, 
		T.template_id, 
		T.total_score, 
		T.type,
		T.recurrency_type,
		T.time_realized_by_id,
		T.time_taken,
		T.signed_by,
		T.time_realized_by,
		T.video,
		T.video_thumbnail,
		(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE (AA.task_id = T.id) AND AA.is_active = true) AS actionnr,
		(SELECT Count(CC.id)::int4 FROM comments CC WHERE (CC.task_id = T.id) AND CC.is_active = true) AS commentnr
 FROM (
  SELECT 
		TT.template_id,
			CASE WHEN TTT.area_id IS NULL THEN
				TTR.area_id
			ELSE 
				TTT.area_id
			END::int AS area_id,
		TT.comment, 
		TT.company_id, 
		TT.created_at, 
		TTT.deeplink_id,
		TTT.deeplink_to,
		TTT.description, 
		TTT.description_file,
		TT.deviance, 
		TT.due_at, 
		TT.end_date, 
		TT.id, 
		TTT.index,
		TTT.machine_status,
		TT.max_score, 
		TT.modified_at, 
		TTT.name, 
		TTT.picture, 
		TTT.planned_time,
		TT.recurrency_id, 
		TT.score, 
		TT.shift_id, 
		TT.signed_at, 
		TT.signed_by_id, 
		TT.start_at, 
		TT.start_date, 
		TT.status,  
		TT.total_score, 
		TTT.type,
		TTR.type AS recurrency_type,
		TT.time_realized_by_id,
		TT.time_taken,
		CASE WHEN PU.id IS NOT NULL THEN
			CONCAT(PU.first_name, ' ', PU.last_name)::varchar
		ELSE
			NULL
		END AS signed_by,
		CASE WHEN PU2.id IS NOT NULL THEN
			CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
		ELSE
			NULL
		END AS time_realized_by,
		TTT.video,
		TTT.video_thumbnail
	FROM tasks_task TT
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
	INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
	LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
	LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
	WHERE TT.company_id = _companyid 
	AND TTT.is_active = true AND TT.is_active = true AND TTT.is_active = true
	AND ((TT.start_at >= _start_date::timestamp AND TT.due_at <= _end_date::timestamp) 
					OR (TT.signed_at::timestamp BETWEEN _start_date_wt::timestamp AND _end_date_wt::timestamp)
					OR (TT.due_at > _start_date::timestamp AND TT.due_at <= _end_date::timestamp)
				)
 ) AS T
	WHERE (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = T.area_id) OR _areaid= 0) 
		AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = T.template_id) OR _userid = 0) 
	ORDER BY T.index --, T.created_at
	LIMIT CASE WHEN (_limit > 0) THEN _limit END 
  OFFSET CASE WHEN (_offset > 0) THEN _offset END;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_related_to_previous_shift_times
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_related_to_previous_shift_times"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4, "_timespanindays" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_related_to_previous_shift_times"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0, "_timespanindays" int4=0)
  RETURNS TABLE("area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "deeplink_id" int4, "deeplink_to" varchar, "description" text, "description_file" varchar, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "index" int4, "machine_status" varchar, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "planned_time" int4, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "template_id" int4, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "signed_by" varchar, "time_realized_by" varchar, "video" varchar, "video_thumbnail" varchar, "actionnr" int4, "commentnr" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 	T.area_id,
		T.comment, 
		T.company_id, 
		T.created_at, 
		T.deeplink_id,
		T.deeplink_to,
		T.description, 
		T.description_file,
		T.deviance, 
		T.due_at, 
		T.end_date, 
		T.id, 
		T.index,
		T.machine_status,
		T.max_score, 
		T.modified_at, 
		T.name, 
		T.picture, 
		T.planned_time,
		T.recurrency_id, 
		T.score, 
		T.shift_id, 
		T.signed_at, 
		T.signed_by_id, 
		T.start_at, 
		T.start_date, 
		T.status, 
		T.template_id, 
		T.total_score, 
		T.type,
		T.recurrency_type,
		T.time_realized_by_id,
		T.time_taken,
		T.signed_by,
		T.time_realized_by,
		T.video,
		T.video_thumbnail, 
		(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE (AA.task_id = T.id) AND AA.is_active = true) AS actionnr,
		(SELECT Count(CC.id)::int4 FROM comments CC WHERE (CC.task_id = T.id) AND CC.is_active = true) AS commentnr
	FROM (
    SELECT 
		TT.template_id,
			CASE WHEN TTT.area_id IS NULL THEN
				TTR.area_id
			ELSE 
				TTT.area_id
			END::int AS area_id,
		TT.comment, 
		TT.company_id, 
		TT.created_at, 
		TTT.deeplink_id,
		TTT.deeplink_to,
		TTT.description, 
		TTT.description_file,
		TT.deviance, 
		TT.due_at, 
		TT.end_date, 
		TT.id, 
		TTT.index,
		TTT.machine_status,
		TT.max_score, 
		TT.modified_at, 
		TTT.name, 
		TTT.picture, 
		TTT.planned_time,
		TT.recurrency_id, 
		TT.score, 
		TT.shift_id, 
		TT.signed_at, 
		TT.signed_by_id, 
		TT.start_at, 
		TT.start_date, 
		TT.status,  
		TT.total_score, 
		TTT.type,
		TTR.type AS recurrency_type,
		TT.time_realized_by_id,
		TT.time_taken,
		CASE WHEN PU.id IS NOT NULL THEN
			CONCAT(PU.first_name, ' ', PU.last_name)::varchar
		ELSE
			NULL
		END AS signed_by,
		CASE WHEN PU2.id IS NOT NULL THEN
			CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
		ELSE
			NULL
		END AS time_realized_by,
		TTT.video,
		TTT.video_thumbnail
	FROM tasks_task TT
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
	INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id AND TTR.type <> 'shifts'
	LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
	LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id 
	WHERE TT.company_id = _companyid 
	AND TTT.is_active = true AND TT.is_active = true AND TTT.is_active = true
	AND	(TT.signed_at::timestamp BETWEEN (SELECT get_timestamp_without_companytimezone(_companyid, S.start_date::timestamp) AS start_date_wt FROM get_shift_previous_by_timestamp(_companyid, _timestamp::timestamp) S LIMIT 1)::timestamp AND 
																			 (SELECT get_timestamp_without_companytimezone(_companyid, S.end_date::timestamp) AS end_date_wt FROM get_shift_previous_by_timestamp(_companyid, _timestamp::timestamp) S LIMIT 1)::timestamp
			 OR TT.due_at BETWEEN (SELECT S.start_date::timestamp FROM get_shift_previous_by_timestamp(_companyid, _timestamp::timestamp) S LIMIT 1)::timestamp AND 
														(SELECT S.end_date::timestamp FROM get_shift_previous_by_timestamp(_companyid, _timestamp::timestamp) S LIMIT 1)::timestamp
			 OR TT.due_at = (SELECT S.end_date::timestamp FROM get_shift_previous_by_timestamp(_companyid, _timestamp::timestamp) S LIMIT 1)::timestamp
			 )
		
	UNION

	SELECT 
		TT.template_id,
			CASE WHEN TTT.area_id IS NULL THEN
				TTR.area_id
			ELSE 
				TTT.area_id
			END::int AS area_id,
		TT.comment, 
		TT.company_id, 
		TT.created_at, 
		TTT.deeplink_id,
		TTT.deeplink_to,
		TTT.description, 
		TTT.description_file,
		TT.deviance, 
		TT.due_at, 
		TT.end_date, 
		TT.id, 
		TTT.index,
		TTT.machine_status,
		TT.max_score, 
		TT.modified_at, 
		TTT.name, 
		TTT.picture, 
		TTT.planned_time,
		TT.recurrency_id, 
		TT.score, 
		TT.shift_id, 
		TT.signed_at, 
		TT.signed_by_id, 
		TT.start_at, 
		TT.start_date, 
		TT.status,  
		TT.total_score, 
		TTT.type,
		TTR.type AS recurrency_type,
		TT.time_realized_by_id,
		TT.time_taken,
		CASE WHEN PU.id IS NOT NULL THEN
			CONCAT(PU.first_name, ' ', PU.last_name)::varchar
		ELSE
			NULL
		END AS signed_by,
		CASE WHEN PU2.id IS NOT NULL THEN
			CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
		ELSE
			NULL
		END AS time_realized_by,
		TTT.video,
		TTT.video_thumbnail
		FROM tasks_task TT 
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
		INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.type = 'shifts' 
		LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
		LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
		--INNER JOIN availableshift A ON A.id = TT.shift_id -- join on TT.shift id for getting shift only. 
		WHERE TT.company_id = _companyid AND TT.is_active = true 
			--AND TT.start_at = A.start_date AND TT.due_at = A.end_date
			AND TT.start_at = (SELECT S.start_date::timestamp FROM get_shift_previous_by_timestamp(_companyid, _timestamp::timestamp) S LIMIT 1)::timestamp 
			AND TT.due_at = (SELECT S.end_date::timestamp FROM get_shift_previous_by_timestamp(_companyid, _timestamp::timestamp) S LIMIT 1)::timestamp
			
			
 ) AS T 
 WHERE (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = T.area_id) OR _areaid= 0) 
		AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = T.template_id) OR _userid = 0) 
	ORDER BY T.index --, T.created_at
	LIMIT CASE WHEN (_limit > 0) THEN _limit END 
  OFFSET CASE WHEN (_offset > 0) THEN _offset END
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_related_to_shift_times
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_related_to_shift_times"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4, "_timespanindays" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_related_to_shift_times"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0, "_timespanindays" int4=0)
  RETURNS TABLE("area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "deeplink_id" int4, "deeplink_to" varchar, "description" text, "description_file" varchar, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "index" int4, "machine_status" varchar, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "planned_time" int4, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "template_id" int4, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "signed_by" varchar, "time_realized_by" varchar, "video" varchar, "video_thumbnail" varchar, "actionnr" int4, "commentnr" int4) AS $BODY$
	DECLARE
		_start_date timestamp;
		_start_date_wt timestamp;
		_end_date timestamp;
		_end_date_wt timestamp;
	BEGIN
	SELECT S.start_date, 
				 S.end_date,
				 get_timestamp_without_companytimezone(_companyid ,S.start_date::timestamp) AS start_date_wt, 
				 get_timestamp_without_companytimezone(_companyid ,S.end_date::timestamp) AS end_date_wt
				 INTO  _start_date, _end_date, _start_date_wt, _end_date_wt
	FROM get_shift_by_timestamp(_companyid, _timestamp::timestamp) AS S;
	RETURN QUERY
	SELECT 	T.area_id,
		T.comment, 
		T.company_id, 
		T.created_at, 
		T.deeplink_id,
		T.deeplink_to,
		T.description, 
		T.description_file,
		T.deviance, 
		T.due_at, 
		T.end_date, 
		T.id, 
		T.index,
		T.machine_status,
		T.max_score, 
		T.modified_at, 
		T.name, 
		T.picture, 
		T.planned_time,
		T.recurrency_id, 
		T.score, 
		T.shift_id, 
		T.signed_at, 
		T.signed_by_id, 
		T.start_at, 
		T.start_date, 
		T.status, 
		T.template_id, 
		T.total_score, 
		T.type,
		T.recurrency_type,
		T.time_realized_by_id,
		T.time_taken,
		T.signed_by,
		T.time_realized_by,
		T.video,
		T.video_thumbnail, 
		(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE (AA.task_id = T.id) AND AA.is_active = true) AS actionnr,
		(SELECT Count(CC.id)::int4 FROM comments CC WHERE (CC.task_id = T.id) AND CC.is_active = true) AS commentnr
	FROM (
  SELECT 
		TT.template_id,
			CASE WHEN TTT.area_id IS NULL THEN
				TTR.area_id
			ELSE 
				TTT.area_id
			END::int AS area_id,
		TT.comment, 
		TT.company_id, 
		TT.created_at, 
		TTT.deeplink_id,
		TTT.deeplink_to,
		TTT.description, 
		TTT.description_file,
		TT.deviance, 
		TT.due_at, 
		TT.end_date, 
		TT.id, 
		TTT.index,
		TTT.machine_status,
		TT.max_score, 
		TT.modified_at, 
		TTT.name, 
		TTT.picture, 
		TTT.planned_time,
		TT.recurrency_id, 
		TT.score, 
		TT.shift_id, 
		TT.signed_at, 
		TT.signed_by_id, 
		TT.start_at, 
		TT.start_date, 
		TT.status,  
		TT.total_score, 
		TTT.type,
		TTR.type AS recurrency_type,
		TT.time_realized_by_id,
		TT.time_taken,
		CASE WHEN PU.id IS NOT NULL THEN
			CONCAT(PU.first_name, ' ', PU.last_name)::varchar
		ELSE
			NULL
		END AS signed_by,
		CASE WHEN PU2.id IS NOT NULL THEN
			CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
		ELSE
			NULL
		END AS time_realized_by,
		TTT.video,
		TTT.video_thumbnail
	FROM tasks_task TT
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
	INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id AND TTR.type <> 'shifts'
	LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
	LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
	WHERE TT.company_id = _companyid 
	AND TTT.is_active = true AND TT.is_active = true AND TTT.is_active = true
	AND ((TT.signed_at::timestamp BETWEEN _start_date_wt AND _end_date_wt) OR (TT.due_at > _start_date AND TT.due_at < _end_date) OR TT.due_at = _end_date)
	
	UNION

	SELECT 
		TT.template_id,
			CASE WHEN TTT.area_id IS NULL THEN
				TTR.area_id
			ELSE 
				TTT.area_id
			END::int AS area_id,
		TT.comment, 
		TT.company_id, 
		TT.created_at, 
		TTT.deeplink_id,
		TTT.deeplink_to,
		TTT.description, 
		TTT.description_file,
		TT.deviance, 
		TT.due_at, 
		TT.end_date, 
		TT.id, 
		TTT.index,
		TTT.machine_status,
		TT.max_score, 
		TT.modified_at, 
		TTT.name, 
		TTT.picture, 
		TTT.planned_time,
		TT.recurrency_id, 
		TT.score, 
		TT.shift_id, 
		TT.signed_at, 
		TT.signed_by_id, 
		TT.start_at, 
		TT.start_date, 
		TT.status,  
		TT.total_score, 
		TTT.type,
		TTR.type AS recurrency_type,
		TT.time_realized_by_id,
		TT.time_taken,
		CASE WHEN PU.id IS NOT NULL THEN
			CONCAT(PU.first_name, ' ', PU.last_name)::varchar
		ELSE
			NULL
		END AS signed_by,
		CASE WHEN PU2.id IS NOT NULL THEN
			CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
		ELSE
			NULL
		END AS time_realized_by,
		TTT.video,
		TTT.video_thumbnail
		FROM tasks_task TT 
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
		INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.type = 'shifts' 
		LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
		LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
		WHERE TT.company_id = _companyid AND TT.is_active = true 
			AND TT.start_at = _start_date AND TT.due_at = _end_date
 ) AS T 
  WHERE (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = T.area_id) OR _areaid= 0) 
		AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = T.template_id) OR _userid = 0) 
	ORDER BY T.index --, T.created_at
	LIMIT CASE WHEN (_limit > 0) THEN _limit END 
  OFFSET CASE WHEN (_offset > 0) THEN _offset END
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_related_to_yesterday
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_related_to_yesterday"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4, "_timespanindays" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_related_to_yesterday"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0, "_timespanindays" int4=0)
  RETURNS TABLE("area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "deeplink_id" int4, "deeplink_to" varchar, "description" text, "description_file" varchar, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "index" int4, "machine_status" varchar, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "planned_time" int4, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "template_id" int4, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "signed_by" varchar, "time_realized_by" varchar, "video" varchar, "video_thumbnail" varchar, "actionnr" int4, "commentnr" int4) AS $BODY$
DECLARE
		_start_date timestamp;
		_start_date_wt timestamp;
		_end_date timestamp;
		_end_date_wt timestamp;
	BEGIN
			SELECT get_timestamp_without_companytimezone(_companyid ,ST.start_date::timestamp) AS start_date_wt, 
						 ST.start_date, 
						 ST.end_date, 
						 get_timestamp_without_companytimezone(_companyid ,ST.end_date::timestamp) AS end_date_wt
						 
						 INTO 
						 _start_date_wt, _start_date, _end_date, _end_date_wt
						 
			FROM (
				SELECT MIN(S.start_date) AS start_date, MAX(S.end_date) AS end_date, S.day_date, S.weekday FROM get_shifts_past_day_by_timestamp(_companyid::int, _timestamp::timestamp) AS S
				GROUP BY S.weekday,S.day_date
				ORDER BY S.day_date DESC
				LIMIT 1
			) AS ST;
			
		IF _start_date IS NULL AND _end_date IS NULL THEN
				_start_date = (_timestamp - '1 day'::interval)::date::timestamp; 
				_end_date = (_timestamp)::date::timestamp; 
				_start_date_wt = get_timestamp_without_companytimezone(_companyid , _start_date::timestamp);  
				_end_date_wt = get_timestamp_without_companytimezone(_companyid , _end_date::timestamp);  
		END IF;
		IF _start_date IS NOT NULL AND _end_date IS NULL THEN
				_end_date = (_timestamp)::date::timestamp; 
				_end_date_wt = get_timestamp_without_companytimezone(_companyid , _end_date::timestamp);  
		END IF; 
		IF _start_date IS NULL AND _end_date IS NOT NULL THEN
				_start_date = (_timestamp - '1 day'::interval)::date::timestamp; 
				_start_date_wt = get_timestamp_without_companytimezone(_companyid , _start_date::timestamp);  
		END IF;
		
	
	--get_shifts_past_day_by_timestamp
	RETURN QUERY
	SELECT 	T.area_id,
		T.comment, 
		T.company_id, 
		T.created_at, 
		T.deeplink_id,
		T.deeplink_to,
		T.description, 
		T.description_file,
		T.deviance, 
		T.due_at, 
		T.end_date, 
		T.id, 
		T.index,
		T.machine_status,
		T.max_score, 
		T.modified_at, 
		T.name, 
		T.picture, 
		T.planned_time,
		T.recurrency_id, 
		T.score, 
		T.shift_id, 
		T.signed_at, 
		T.signed_by_id, 
		T.start_at, 
		T.start_date, 
		T.status, 
		T.template_id, 
		T.total_score, 
		T.type,
		T.recurrency_type,
		T.time_realized_by_id,
		T.time_taken,
		T.signed_by,
		T.time_realized_by,
		T.video,
		T.video_thumbnail,
		(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE (AA.task_id = T.id) AND AA.is_active = true) AS actionnr,
		(SELECT Count(CC.id)::int4 FROM comments CC WHERE (CC.task_id = T.id) AND CC.is_active = true) AS commentnr
	FROM (
		SELECT 
			TT.template_id,
				CASE WHEN TTT.area_id IS NULL THEN
					TTR.area_id
				ELSE 
					TTT.area_id
				END::int AS area_id,
			TT.comment, 
			TT.company_id, 
			TT.created_at, 
			TTT.deeplink_id,
			TTT.deeplink_to,
			TTT.description, 
			TTT.description_file,
			TT.deviance, 
			TT.due_at, 
			TT.end_date, 
			TT.id, 
			TTT.index,
			TTT.machine_status,
			TT.max_score, 
			TT.modified_at, 
			TTT.name, 
			TTT.picture, 
			TTT.planned_time,
			TT.recurrency_id, 
			TT.score, 
			TT.shift_id, 
			TT.signed_at, 
			TT.signed_by_id, 
			TT.start_at, 
			TT.start_date, 
			TT.status,  
			TT.total_score, 
			TTT.type,
			TTR.type AS recurrency_type,
			TT.time_realized_by_id,
			TT.time_taken,
			CASE WHEN PU.id IS NOT NULL THEN
				CONCAT(PU.first_name, ' ', PU.last_name)::varchar
			ELSE
				NULL
			END AS signed_by,
			CASE WHEN PU2.id IS NOT NULL THEN
				CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
			ELSE
				NULL
			END AS time_realized_by,
			TTT.video,
			TTT.video_thumbnail
		FROM tasks_task TT
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
		LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
		LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
		WHERE TT.company_id = _companyid 
		AND TTT.is_active = true AND TT.is_active = true AND TTT.is_active = true
		AND ((TT.start_at >= _start_date AND TT.due_at <= _end_date) 
						OR (TT.signed_at::timestamp BETWEEN _start_date_wt::timestamp AND _end_date_wt::timestamp)
						OR (TT.due_at > _start_date AND TT.due_at <= _end_date)
					)
					
 ) AS T 
 WHERE (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = T.area_id) OR _areaid= 0) 
	 AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = T.template_id) OR _userid = 0)
 ORDER BY T.index ,T.created_at
	LIMIT CASE WHEN (_limit > 0) THEN _limit END 
  OFFSET CASE WHEN (_offset > 0) THEN _offset END;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_statusses
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_statusses"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_statusses"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0)
  RETURNS TABLE("id" int4, "signed_at" timestamptz, "signed_by_id" int4, "signed_by" varchar, "status" varchar, "template_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT DISTINCT 
		TT.id, 
		TT.signed_at, 
		TT.signed_by_id, 
		CONCAT(PU.first_name, ' ',PU.last_name)::varchar AS signed_by,
		TT.status,
		TT.template_id
		FROM tasks_task TT
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TT.template_id
		LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id AND PU.company_id = _companyid
		WHERE ((TT.start_date >= _timestamp AND TT.end_date < _timestamp) 
					 OR TT.start_date = _timestamp::date 
					 OR TT.end_date = _timestamp::date
					 OR TT.signed_at::date = _timestamp::date)
		AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id) OR _areaid= 0) 
		AND TT.company_id = _companyid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_test
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_test"("_companyid" int4, "_timestamp" timestamptz);
CREATE OR REPLACE FUNCTION "public"."get_tasks_test"("_companyid" int4, "_timestamp" timestamptz)
  RETURNS TABLE("area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "deeplink_id" int4, "deeplink_to" varchar, "description" text, "description_file" varchar, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "machine_status" varchar, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "planned_time" int4, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "template_id" int4, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "signed_by" varchar, "time_realized_by" varchar, "video" varchar, "video_thumbnail" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT DISTINCT * FROM 
	(
		SELECT * FROM (
				SELECT 
					CASE WHEN TTT.area_id IS NULL THEN
						TTR.area_id
					ELSE 
						TTT.area_id
					END::int AS area_id,
				TT.comment, 
				TT.company_id, 
				TT.created_at, 
				TTT.deeplink_id,
				TTT.deeplink_to,
				TTT.description, 
				TTT.description_file,
				TT.deviance, 
				TT.due_at, 
				TT.end_date, 
				TT.id, 
				TTT.machine_status,
				TT.max_score, 
				TT.modified_at, 
				TTT.name, 
				TTT.picture, 
				TTT.planned_time,
				TT.recurrency_id, 
				TT.score, 
				TT.shift_id, 
				TT.signed_at, 
				TT.signed_by_id, 
				TT.start_at, 
				TT.start_date, 
				TT.status, 
				TT.template_id, 
				TT.total_score, 
				TTT.type,
				TTR.type AS recurrency_type,
				TT.time_realized_by_id,
				TT.time_taken,
				CASE WHEN PU.id IS NOT NULL THEN
					CONCAT(PU.first_name, ' ', PU.last_name)::varchar
				ELSE
					NULL
				END AS signed_by,
				CASE WHEN PU2.id IS NOT NULL THEN
					CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
				ELSE
					NULL
				END AS time_realized_by,
				TTT.video,
				TTT.video_thumbnail
				FROM tasks_task TT 
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
				LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
				LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
				WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.type = 'task' 
				AND (
							((_timestamp BETWEEN TT.start_date AND TT.end_date) OR TT.start_date =_timestamp::date OR TT.end_date = _timestamp::date) OR
							((TTR.type = 'week' OR TTR.type = 'month') AND TT.due_at > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) AND TT.due_at < ((_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) + interval '7 day'))
						)

				ORDER BY TT.start_at, TT.start_date, TTT.name
			) AS A
			UNION
			SELECT * FROM (
				SELECT 
					CASE WHEN TTT.area_id IS NULL THEN
						TTR.area_id
					ELSE 
						TTT.area_id
					END::int AS area_id,
				TT.comment, 
				TT.company_id, 
				TT.created_at, 
				TTT.deeplink_id,
				TTT.deeplink_to,
				TTT.description, 
				TTT.description_file,
				TT.deviance, 
				TT.due_at, 
				TT.end_date, 
				TT.id, 
				TTT.machine_status,
				TT.max_score, 
				TT.modified_at, 
				TTT.name, 
				TTT.picture, 
				TTT.planned_time,
				TT.recurrency_id, 
				TT.score, 
				TT.shift_id, 
				TT.signed_at, 
				TT.signed_by_id, 
				TT.start_at, 
				TT.start_date, 
				TT.status, 
				TT.template_id, 
				TT.total_score, 
				TTT.type,
				TTR.type AS recurrency_type,
				TT.time_realized_by_id,
				TT.time_taken,
				CASE WHEN PU.id IS NOT NULL THEN
					CONCAT(PU.first_name, ' ', PU.last_name)::varchar
				ELSE
					NULL
				END AS signed_by,
				CASE WHEN PU2.id IS NOT NULL THEN
					CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
				ELSE
					NULL
				END AS time_realized_by,
				TTT.video,
				TTT.video_thumbnail
				FROM tasks_task TT 
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
				LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
				LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
				WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.type = 'task' 
				AND (
							((_timestamp BETWEEN TT.start_date AND TT.end_date) OR TT.start_date =_timestamp::date OR TT.end_date = _timestamp::date) OR
							((TTR.type = 'week' OR TTR.type = 'month') AND TT.due_at > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) AND TT.due_at < ((_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) + interval '7 day'))
						)

				ORDER BY TT.start_at, TT.start_date, TTT.name
			) AS B
		) AS T;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_with_actions
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_with_actions"("_companyid" int4, "_isresolved" bool, "_createdbyid" int4, "_timestamp" timestamp, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_with_actions"("_companyid" int4, "_isresolved" bool=NULL::boolean, "_createdbyid" int4=NULL::integer, "_timestamp" timestamp=NULL::timestamp without time zone, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("template_id" int4, "area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "deeplink_id" int4, "deeplink_to" varchar, "description" text, "description_file" varchar, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "machine_status" varchar, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "planned_time" int4, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "signed_by" varchar, "time_realized_by" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT DISTINCT TT.template_id,
		CASE WHEN TTT.area_id IS NULL THEN
			TTR.area_id
		ELSE 
			TTT.area_id
		END::int AS area_id,
		TT.comment, 
		TT.company_id, 
		TT.created_at, 
		TTT.deeplink_id,
		TTT.deeplink_to,
		TTT.description, 
		TTT.description_file,
		TT.deviance, 
		TT.due_at, 
		TT.end_date, 
		TT.id, 
		TTT.machine_status,
		TT.max_score, 
		TT.modified_at, 
		TTT.name, 
		TTT.picture, 
		TTT.planned_time,
		TT.recurrency_id, 
		TT.score, 
		TT.shift_id, 
		TT.signed_at, 
		TT.signed_by_id, 
		TT.start_at, 
		TT.start_date, 
		TT.status, 
		TT.total_score, 
		TTT.type,
		TTR.type AS recurrency_type,
		TT.time_realized_by_id,
		TT.time_taken,
		''::varchar AS signed_by,
		CASE WHEN PU2.id IS NOT NULL THEN
			CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
		ELSE
			NULL
		END AS time_realized_by
	FROM tasks_task TT 
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
	LEFT JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true
	INNER JOIN actions_action AA ON AA.task_id = TT.id AND AA.is_active = true
	LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
	LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
	WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.type = 'task'
	
	AND AA.id IN (
		SELECT AA1.id FROM actions_action AA1 
		WHERE AA1.company_id = _companyid AND AA1.is_active = true
		AND (AA1.created_by_id = _createdbyid OR _createdbyid IS NULL)
		AND (AA1.is_resolved = _isresolved OR _isresolved IS NULL)
		AND (AA1.created_at < _timestamp OR _timestamp IS NULL)
		ORDER BY AA1.due_date DESC, AA1.modified_at DESC, AA1.created_at DESC, AA1.id ASC
		LIMIT CASE WHEN (_limit > 0) THEN _limit END 
		OFFSET CASE WHEN (_offset > 0) THEN _offset END
	)

	ORDER BY TT.template_id, TT.start_at DESC, TT.start_date DESC, TT.end_date, TTT.name DESC
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_with_audits
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_with_audits"("_companyid" int4, "_iscomplete" bool, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4, "_timespanindays" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_tasks_with_audits"("_companyid" int4, "_iscomplete" bool=NULL::boolean, "_timestamp" timestamp=NULL::timestamp without time zone, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0, "_timespanindays" int4=0, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("area_id" int4, "audit_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "description" text, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "index" int4, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "template_id" int4, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "actionnr" int4, "commentnr" int4) AS $BODY$BEGIN
	RETURN QUERY
		SELECT DISTINCT
			AATT.area_id,
			AAT.audit_id,
			TT.comment, 
			TT.company_id, 
			TT.created_at, 
			TTT.description, 
			TT.deviance, 
			TT.due_at, 
			TT.end_date, 
			TT.id, 
			TTT.index,
			TT.max_score, 
			TT.modified_at, 
			TTT.name, 
			TTT.picture, 
			TT.recurrency_id, 
			TT.score, 
			TT.shift_id, 
			TT.signed_at, 
			TT.signed_by_id, 
			TT.start_at, 
			TT.start_date, 
			TT.status, 
			TT.template_id, 
			TT.total_score, 
			TTT.type,
			TTR.type AS recurrency_type,
			TT.time_realized_by_id,
			TT.time_taken,
			(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE (AA.task_id = TT.id) AND AA.is_active = true) AS actionnr,
			(SELECT Count(CC.id)::int4 FROM comments CC WHERE (CC.task_id = TT.id) AND CC.is_active = true) AS commentnr
		FROM tasks_task TT 
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
		INNER JOIN audits_audit_tasks AAT ON AAT.task_id = TT.id
		INNER JOIN audits_audit AA ON AA.id = AAT.audit_id
		INNER JOIN audits_audittemplate AATT ON AATT.id = AA.template_id
		LEFT JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
		WHERE TT.company_id = _companyid AND TT.is_active = true

		AND AA.id IN (SELECT AA1.id FROM audits_audit AA1 
								 INNER JOIN audits_audittemplate AAT1 ON AAT1.id = AA1.template_id AND AA1.company_id = AAT1.company_id AND AAT1.is_active = true 
								 WHERE AA1.company_id = _companyid AND AA1.is_active = true
								 AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = AAT1.area_id) OR _areaid= 0) 
								 AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_audittemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = AAT1.id) OR _userid = 0) 
								 AND (AA1.signed_at_1 >= get_timestamp_without_companytimezone(_companyid ,_starttimestamp) OR _starttimestamp IS NULL)
								 AND (AA1.signed_at_1 <= get_timestamp_without_companytimezone(_companyid ,_endtimestamp) OR _endtimestamp IS NULL)
								 AND (AA1.signed_at_1::timestamp < get_timestamp_without_companytimezone(_companyid , _timestamp::timestamp) OR _timestamp IS NULL)
								 AND (AA1.created_at > (NOW()::date - CONCAT(_timespanindays,' days')::interval) OR _timespanindays = 0) -- note when partial items can be submitted, this must change
								 AND (AA1.is_complete = _iscomplete OR _iscomplete IS NULL)
								 ORDER BY AA1.signed_at_1 DESC, AAT1.name, AA1.id
								 LIMIT CASE WHEN (_limit > 0) THEN _limit END 
								 OFFSET CASE WHEN (_offset > 0) THEN _offset END)
								 
		ORDER BY AAT.audit_id
		;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_with_checklists
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_with_checklists"("_companyid" int4, "_iscomplete" bool, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4, "_timespanindays" int4, "_starttimestamp" timestamp, "_endtimestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_tasks_with_checklists"("_companyid" int4, "_iscomplete" bool=NULL::boolean, "_timestamp" timestamp=NULL::timestamp without time zone, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0, "_timespanindays" int4=0, "_starttimestamp" timestamp=NULL::timestamp without time zone, "_endtimestamp" timestamp=NULL::timestamp without time zone)
  RETURNS TABLE("area_id" int4, "checklist_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "description" text, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "index" int4, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "template_id" int4, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "video" varchar, "video_thumbnail" varchar, "actionnr" int4, "commentnr" int4) AS $BODY$BEGIN
	RETURN QUERY
		SELECT DISTINCT
		AATT.area_id,
		CCT.checklist_id,
		TT.comment, 
		TT.company_id, 
		TT.created_at, 
		TTT.description, 
		TT.deviance, 
		TT.due_at, 
		TT.end_date, 
		TT.id, 
		TTT.index,
		TT.max_score, 
		TT.modified_at, 
		TTT.name, 
		TTT.picture, 
		TT.recurrency_id, 
		TT.score, 
		TT.shift_id, 
		TT.signed_at, 
		TT.signed_by_id, 
		TT.start_at, 
		TT.start_date, 
		TT.status, 
		TT.template_id, 
		TT.total_score, 
		TTT.type,
		TTR.type AS recurrency_type,
		TT.time_realized_by_id,
		TT.time_taken,
		TTT.video,
		TTT.video_thumbnail,
		(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE (AA.task_id = TT.id) AND AA.is_active = true) AS actionnr,
		(SELECT Count(CC.id)::int4 FROM comments CC WHERE (CC.task_id = TT.id) AND CC.is_active = true) AS commentnr
		FROM tasks_task TT 
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
		INNER JOIN checklists_checklist_tasks CCT ON CCT.task_id = TT.id
		INNER JOIN checklists_checklist AA ON AA.id = CCT.checklist_id
		INNER JOIN checklists_checklisttemplate AATT ON AATT.id = AA.template_id
		LEFT JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
		WHERE TT.company_id = _companyid AND TT.is_active = true
		
		AND AA.id IN ( 
				SELECT CC1.id 
				FROM checklists_checklist CC1 
				INNER JOIN checklists_checklisttemplate CCT1 ON CCT1.id = CC1.template_id AND CC1.company_id = CCT1.company_id AND CCT1.is_active = true 
				WHERE CC1.is_active = true AND CC1.company_id = _companyid
				AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = CCT1.area_id) OR _areaid= 0) 
				AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_checklisttemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = CCT1.id) OR _userid = 0) 
				AND (CC1.signed_at_1::timestamp < get_timestamp_without_companytimezone(_companyid , _timestamp::timestamp) OR _timestamp IS NULL)
				AND (CC1.signed_at_1 >= get_timestamp_without_companytimezone(_companyid ,_starttimestamp) OR _starttimestamp IS NULL)
				AND (CC1.signed_at_1 <= get_timestamp_without_companytimezone(_companyid ,_endtimestamp) OR _endtimestamp IS NULL)
				AND (CC1.created_at > (NOW()::date - CONCAT(_timespanindays,' days')::interval) OR _timespanindays = 0) -- note when partial items can be submitted, this must change
				AND (CC1.is_complete = _iscomplete OR _iscomplete IS NULL)
				ORDER BY CC1.signed_at_1 DESC, CCT1.name ASC, CCT1.id
				LIMIT CASE WHEN (_limit > 0) THEN _limit END 
				OFFSET CASE WHEN (_offset > 0) THEN _offset END
		)

		ORDER BY CCT.checklist_id ASC, TTT.index ASC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasks_with_comments
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasks_with_comments"("_companyid" int4, "_isresolved" bool, "_createdbyid" int4, "_timestamp" timestamp, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasks_with_comments"("_companyid" int4, "_isresolved" bool=NULL::boolean, "_createdbyid" int4=NULL::integer, "_timestamp" timestamp=NULL::timestamp without time zone, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("template_id" int4, "area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "deeplink_id" int4, "deeplink_to" varchar, "description" text, "description_file" varchar, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "machine_status" varchar, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "planned_time" int4, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "signed_by" varchar, "time_realized_by" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT DISTINCT TT.template_id,
		CASE WHEN TTT.area_id IS NULL THEN
			TTR.area_id
		ELSE 
			TTT.area_id
		END::int AS area_id,
		TT.comment, 
		TT.company_id, 
		TT.created_at, 
		TTT.deeplink_id,
		TTT.deeplink_to,
		TTT.description, 
		TTT.description_file,
		TT.deviance, 
		TT.due_at, 
		TT.end_date, 
		TT.id, 
		TTT.machine_status,
		TT.max_score, 
		TT.modified_at, 
		TTT.name, 
		TTT.picture, 
		TTT.planned_time,
		TT.recurrency_id, 
		TT.score, 
		TT.shift_id, 
		TT.signed_at, 
		TT.signed_by_id, 
		TT.start_at, 
		TT.start_date, 
		TT.status, 
		TT.total_score, 
		TTT.type,
		TTR.type AS recurrency_type,
		TT.time_realized_by_id,
		TT.time_taken,
		''::varchar AS signed_by,
		CASE WHEN PU2.id IS NOT NULL THEN
			CONCAT(PU2.first_name, ' ', PU2.last_name)::varchar
		ELSE
			NULL
		END AS time_realized_by
	FROM tasks_task TT 
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
	LEFT JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true
	INNER JOIN comments C ON C.task_id = TT.id AND C.is_active = true
	LEFT JOIN profiles_user PU ON PU.id = TT.signed_by_id
	LEFT JOIN profiles_user PU2 ON PU2.id = TT.time_realized_by_id
	WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.type = 'task'
	
	AND C.id IN (
		SELECT C1.id FROM comments C1 
		WHERE C1.company_id = _companyid AND C.is_active = true
		AND (C1.user_id = _createdbyid OR _createdbyid IS NULL)
		AND (C1.created_at < _timestamp OR _timestamp IS NULL)
		ORDER BY C1.modified_at DESC, C1.created_at DESC, C1.id ASC
		LIMIT CASE WHEN (_limit > 0) THEN _limit END 
		OFFSET CASE WHEN (_offset > 0) THEN _offset END
	)

	ORDER BY TT.template_id, TT.start_at DESC, TT.start_date DESC, TT.end_date, TTT.name DESC
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_taskstatistics
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_taskstatistics"("_companyid" int4, "_currentdatetime" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_taskstatistics"("_companyid" int4, "_currentdatetime" timestamp)
  RETURNS TABLE("nr" int4, "status" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT * FROM (SELECT Count(id)::int4 AS Nr, TT.Status FROM tasks_task TT WHERE TT.company_id = _companyid AND _currentdatetime::timestamp BETWEEN TT.start_at AND TT.due_at GROUP BY TT.status) AS T ORDER BY status;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplate"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplate"("_companyid" int4, "_id" int4)
  RETURNS TABLE("area_id" int4, "company_id" int4, "description" text, "description_file" varchar, "deeplink_id" int4, "deeplink_to" varchar, "id" int4, "name" varchar, "picture" varchar, "role" varchar, "type" varchar, "video" varchar, "video_thumbnail" varchar, "weight" numeric, "planned_time" int4, "machine_status" varchar, "recurrency_type" varchar, "stepnr" int4, "has_derived_items" bool) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
		CASE WHEN TTR.area_id IS NULL THEN
					TT.area_id
		ELSE 
			TTR.area_id
		END::int4 AS area_id,
--TT.area_id, 
TT.company_id, 
TT.description, 
TT.description_file, 
TT.deeplink_id,
TT.deeplink_to,
TT.id, 
TT.name, 
TT.picture, 
TT.role, 
TT.type, 
TT.video, 
TT.video_thumbnail, 
TT.weight ,
TT.planned_time,
TT.machine_status,
TTR.type AS recurrency_type,
(SELECT COUNT(*) FROM tasks_tasktemplatestep TTS 
INNER JOIN tasks_tasktemplate TTT ON TTT.id = TTS.template_id
WHERE  TTS.is_active = true AND TTT.company_id = TT.company_id AND TTS.template_id = TT.id)::int AS stepnr,
(SELECT (COUNT(T.id) > 0)::bool FROM tasks_task T WHERE TT.id = T.template_id) AS has_derived_items
FROM tasks_tasktemplate TT 
LEFT JOIN tasks_taskrecurrency TTR ON TTR.template_id = TT.id
WHERE 
TT.is_active = true 
AND TT.company_id = _companyid 
AND TT.id = _id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplate_data_bi
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplate_data_bi"("current_company_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplate_data_bi"("current_company_id" int4)
  RETURNS TABLE("TaakID" int4, "TaakTitel" varchar, "AreaID" int4, "AreaName" text, "RecurrenceType" varchar, "RecurEveryWeekOrMonth" int4, "Specific" text, "DayNumber" int4, "WeekNumber" int4, "Ma" int4, "Di" int4, "Wo" int4, "Do" int4, "Vr" int4, "Za" int4, "Zo" int4, "StartDatum" varchar, "EindDatum" varchar) AS $BODY$BEGIN
	RETURN QUERY
	/*
		•	TaakID
		•	TaakTitel
		•	AreaID
		•	AreaNaam
		•	RecurrenceType (once, shifts, weeks, months)
		•	En daarna afhankelijk van recurrencetype nog deze exta info in kolommen:
		o	Indien Weekly
					Kol 1: Om de hoeveel weken (wat nu ingevuld is in portal bij “recur every X weeks”)
					Kol 5 t/m 11: Een 1 in de kolom als die weekdag (ma – vr) is aangevinkt: meerdere vinkjes mogelijk dus 1 tot 7 kolommen gevuld met een 1
		o	Indien Monthly
					Kol 1: Om de hoeveel maanden
					Kol 2: Type: specific date of specific week
					Kol 3: Indien specific date: welke maanddag dan (getal 1-31)
					Kol 4: Indien specific week: hoeveelste week (getal 1-4)
					Kol 5 t/m 11: Indien specific week: Een 1 in de kolom van de specifieke weekdag die gekozen is (hier is maar 1 weekdag mogelijk)
	*/		
		SELECT 
		tt.id AS TaakID, -- TaakTemplateID 
		tt.name AS TaakTitel, -- TaakTitel
		--t.id AS TaskId, -- TaakID
		ca.id AS AreaID, -- AreaId
		--ca.name AS AreaNaam, -- AreaName
		get_task_area_full(ca.id) AS AreaName,
		ttr.type AS RecurrenceType, -- RecurrenceType
		
		CASE WHEN ttr.type = 'month' THEN ttr.month
				 WHEN ttr.type = 'week' THEN ttr.week
				 ELSE NULL
	  END AS RecurEveryWeekOrMonth, -- Om de hoeveel weken (wat nu ingevuld is in portal bij “recur every X weeks”) / Om de hoeveel maanden
		
		--	En daarna afhankelijk van recurrencetype nog deze exta info in kolommen:
		
		CASE WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' THEN 'Specific Week'
				 WHEN ttr.type = 'month' AND ttr.month_recurrency = 'day_of_month' THEN 'Specific Date'
				 ELSE NULL
	  END AS Specific, -- Type: specific date of specific week
		
		CASE WHEN ttr.type = 'month' AND ttr.month_recurrency = 'day_of_month' THEN ttr.day
				 ELSE NULL
	  END AS DayNumber, -- Indien specific date: welke maanddag dan (getal 1-31)
		
		CASE WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND ttr.weekday_number IS NULL THEN 1
				 WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND ttr.weekday_number IS NOT NULL THEN ttr.weekday_number
				 --WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' THEN ttr.week
				 ELSE NULL
	  END AS WeekNumber, -- Indien specific week: hoeveelste week (getal 1-4)
		
		-- Indien Weekly Een 1 in de kolom als die weekdag (ma – vr) is aangevinkt: meerdere vinkjes mogelijk dus 1 tot 7 kolommen gevuld met een 1
		-- Indien Monthly En Indien specific week: Een 1 in de kolom van de specifieke weekdag die gekozen is (hier is maar 1 weekdag mogelijk)
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday1 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 2 THEN 1
		WHEN ttr.type = 'week' AND weekday1 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday1 AND weekday = 2 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END AS Ma, 
		
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday2 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 3 THEN 1
		WHEN ttr.type = 'week' AND weekday2 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday2 AND weekday = 3 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END AS Di,
		
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday3 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 4 THEN 1
		WHEN ttr.type = 'week' AND weekday3 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday3 AND weekday = 4 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END AS Wo,
		
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday4 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 5 THEN 1
		WHEN ttr.type = 'week' AND weekday4 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday4 AND weekday = 5 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END AS Do,
		
		CASE 
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday5 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 6 THEN 1
		WHEN ttr.type = 'week' AND weekday5 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday5 AND weekday = 6 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END AS Vr,
		
		CASE 	
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday6 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 7 THEN 1
		WHEN ttr.type = 'week' AND weekday6 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday6 AND weekday = 7 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END AS Za,
		
		CASE 		
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday0 AND weekday IS NULL THEN 1
		WHEN ttr.type = 'month' AND ttr.month_recurrency = 'weekday' AND weekday = 1 THEN 1
		WHEN ttr.type = 'week' AND weekday0 THEN 1
		WHEN ttr.type = 'week' AND NOT weekday0 AND weekday = 1 THEN 1
		WHEN (ttr.type = 'week' OR (ttr.type = 'month' AND ttr.month_recurrency = 'weekday')) THEN 0
		ELSE NULL
		END AS Zo,
		-- possible start and end dates.
		CASE 
		WHEN ttr.type = 'month' OR ttr.type = 'week' THEN to_char(ttr.start_date, 'DD-MM-YYYY')::varchar 
		ELSE '' 
		END AS StartDatum,
		CASE WHEN ttr.type = 'month' OR ttr.type = 'week' THEN 
		to_char(ttr.end_date, 'DD-MM-YYYY')::varchar 
		ELSE '' 
		END AS EindDatum
	FROM tasks_tasktemplate tt 
	LEFT JOIN tasks_taskrecurrency ttr ON ttr.template_id = tt.id and ttr.company_id = current_company_id
	LEFT JOIN companies_area ca ON ca.id = ttr.area_id and ca.company_id = current_company_id
	WHERE tt.company_id = current_company_id
	AND tt.type = 'task' AND tt.is_active = true;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplate_properties
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplate_properties"("_companyid" int4, "_tasktemplate_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplate_properties"("_companyid" int4, "_tasktemplate_id" int4)
  RETURNS TABLE("id" int4, "company_id" int4, "tasktemplate_id" int4, "property_id" int4, "propertyvalue_id" int4, "primary_int_value" int4, "secondary_int_value" int4, "primary_decimal_value" numeric, "secondary_decimal_value" numeric, "primary_string_value" text, "secondary_string_value" text, "primary_datetime_value" timestamp, "secondary_datetime_value" timestamp, "primary_time_value" time, "secondary_time_value" time, "bool_value" bool, "custom_value_type_display" varchar, "custom_title_display" varchar, "is_required" bool, "index" int4) AS $BODY$BEGIN
	RETURN QUERY
SELECT 
TTP.id, 
TTP.company_id, 
TTP.tasktemplate_id, 
TTP.property_id, 
TTP.propertyvalue_id, 
TTP.primary_int_value, 
TTP.secondary_int_value, 
TTP.primary_decimal_value, 
TTP.secondary_decimal_value, 
TTP.primary_string_value, 
TTP.secondary_string_value,
TTP.primary_datetime_value,
TTP.secondary_datetime_value,
TTP.primary_time_value,
TTP.secondary_time_value,
TTP.bool_value, 
TTP.custom_value_type_display, 
TTP.custom_title_display, 
TTP.is_required, 
TTP.index
FROM tasks_tasktemplate_properties TTP
WHERE TTP.company_id = _companyid AND TTP.tasktemplate_id = _tasktemplate_id
ORDER BY index;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplates
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplates"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplates"("_companyid" int4, "_timestamp" timestamp=NULL::timestamp without time zone, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("area_id" int4, "company_id" int4, "description" text, "description_file" varchar, "deeplink_id" int4, "deeplink_to" varchar, "id" int4, "index" int4, "name" varchar, "picture" varchar, "role" varchar, "type" varchar, "video" varchar, "video_thumbnail" varchar, "weight" numeric, "planned_time" int4, "machine_status" varchar, "recurrency_type" varchar, "actionnr" int4, "stepnr" int4, "has_derived_items" bool) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	CASE WHEN TT.area_id IS NULL THEN
		TTR.area_id
	ELSE 
		TT.area_id
	END::int AS area_id, 
	TT.company_id, 
	TT.description, 
	TT.description_file, 
	TT.deeplink_id,
	TT.deeplink_to,
	TT.id, 
	TT.index,
	TT.name, 
	TT.picture, 
	TT.role, 
	TT.type, 
	TT.video, 
	TT.video_thumbnail, 
	TT.weight,
	TT.planned_time,
	TT.machine_status,
	TTR.type AS recurrency_type,
	(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE AA.task_template_id = TT.id AND AA.is_resolved = false AND AA.is_active = true) AS actionnr,
	(SELECT COUNT(TTS.id) FROM tasks_tasktemplatestep TTS 
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TTS.template_id
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	WHERE TTS.is_active = true AND TTT.company_id = TT.company_id AND TTS.template_id = TT.id)::int AS stepnr,
	(SELECT (COUNT(T.id) > 0)::bool FROM tasks_task T WHERE TT.id = T.template_id) AS has_derived_items
FROM tasks_tasktemplate TT 
INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TT.id
WHERE TT.is_active = true AND TT.company_id = _companyid 

AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id) OR _areaid= 0) 
AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = TT.id) OR _userid = 0) 
AND (TT.created_at::timestamp < get_timestamp_without_companytimezone(_companyid ,_timestamp) OR _timestamp IS NULL)

ORDER BY TT.index, TT.name, TT.id
LIMIT CASE WHEN (_limit > 0) THEN _limit END 
OFFSET CASE WHEN (_offset > 0) THEN _offset END;

END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplates_by_audittemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplates_by_audittemplate"("_companyid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplates_by_audittemplate"("_companyid" int4, "_audittemplateid" int4)
  RETURNS TABLE("area_id" int4, "company_id" int4, "description" text, "description_file" varchar, "deeplink_id" int4, "deeplink_to" varchar, "id" int4, "index" int4, "name" varchar, "picture" varchar, "role" varchar, "type" varchar, "video" varchar, "video_thumbnail" varchar, "weight" numeric, "planned_time" int4, "machine_status" varchar, "actionnr" int4, "stepnr" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
TT.area_id, 
TT.company_id, 
TT.description, 
TT.description_file, 
TT.deeplink_id,
TT.deeplink_to,
TT.id, 
TT.index,
TT.name, 
TT.picture, 
TT.role, 
TT.type, 
TT.video, 
TT.video_thumbnail, 
TT.weight,
TT.planned_time,
TT.machine_status,
(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE AA.task_template_id = TT.id AND AA.is_resolved = false AND AA.is_active = true) AS actionnr,
(SELECT COUNT(TTT.id) FROM tasks_tasktemplatestep TTS 
INNER JOIN tasks_tasktemplate TTT ON TTT.id = TTS.template_id
WHERE  TTS.is_active = true AND TTT.company_id = TT.company_id AND TTS.template_id = TT.id)::int AS stepnr
FROM tasks_tasktemplate TT 
INNER JOIN audits_audittemplate_tasks CCT ON CCT.tasktemplate_id = TT.id AND CCT.audittemplate_id = _audittemplateid
WHERE TT.is_active = true AND TT.company_id = _companyid ORDER BY index, name, id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplates_by_checklisttemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplates_by_checklisttemplate"("_companyid" int4, "_checklisttemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplates_by_checklisttemplate"("_companyid" int4, "_checklisttemplateid" int4)
  RETURNS TABLE("area_id" int4, "company_id" int4, "description" text, "description_file" varchar, "deeplink_id" int4, "deeplink_to" varchar, "id" int4, "index" int4, "name" varchar, "picture" varchar, "role" varchar, "type" varchar, "video" varchar, "video_thumbnail" varchar, "weight" numeric, "planned_time" int4, "machine_status" varchar, "actionnr" int4, "stepnr" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
TT.area_id, 
TT.company_id, 
TT.description, 
TT.description_file, 
TT.deeplink_id,
TT.deeplink_to,
TT.id, 
TT.index,
TT.name, 
TT.picture, 
TT.role, 
TT.type, 
TT.video, 
TT.video_thumbnail, 
TT.weight,
TT.planned_time,
TT.machine_status,
(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE AA.task_template_id = TT.id AND AA.is_resolved = false AND AA.is_active = true) AS actionnr,
(SELECT COUNT(TTT.id) FROM tasks_tasktemplatestep TTS 
INNER JOIN tasks_tasktemplate TTT ON TTT.id = TTS.template_id
WHERE  TTS.is_active = true AND TTT.company_id = TT.company_id AND TTS.template_id = TT.id)::int AS stepnr
FROM tasks_tasktemplate TT 
INNER JOIN checklists_checklisttemplate_tasks CCT ON CCT.tasktemplate_id = TT.id AND CCT.checklisttemplate_id = _checklisttemplateid
WHERE TT.is_active = true AND TT.company_id = _companyid ORDER BY index, name, id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplates_properties
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplates_properties"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplates_properties"("_companyid" int4)
  RETURNS TABLE("id" int4, "company_id" int4, "property_id" int4, "propertyvalue_id" int4, "tasktemplate_id" int4, "primary_int_value" int4, "secondary_int_value" int4, "primary_decimal_value" numeric, "secondary_decimal_value" numeric, "primary_string_value" text, "secondary_string_value" text, "primary_datetime_value" timestamp, "secondary_datetime_value" timestamp, "primary_time_value" time, "secondary_time_value" time, "bool_value" bool, "custom_value_type_display" varchar, "custom_title_display" varchar, "custom_display_type" varchar, "display_type" int4, "is_required" bool, "index" int4, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
		SELECT 
		TTP.id, 
		TTP.company_id, 
		TTP.property_id, 
		TTP.propertyvalue_id, 
		TTP.tasktemplate_id,
		TTP.primary_int_value, 
		TTP.secondary_int_value, 
		TTP.primary_decimal_value, 
		TTP.secondary_decimal_value, 
		TTP.primary_string_value, 
		TTP.secondary_string_value, 
		TTP.primary_datetime_value,
		TTP.secondary_datetime_value,
		TTP.primary_time_value,
		TTP.secondary_time_value,
		TTP.bool_value, 
		TTP.custom_value_type_display, 
		TTP.custom_title_display, 
		TTP.custom_display_type,
		TTP.display_type,
		TTP.is_required, 
		TTP.index, 
		TTP.created_at, 
		TTP.modified_at 
		FROM tasks_tasktemplate_properties TTP
		WHERE TTP.company_id = _companyid
		AND TTP.is_active = true
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplates_properties_by_tasktemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplates_properties_by_tasktemplate"("_companyid" int4, "_tasktemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplates_properties_by_tasktemplate"("_companyid" int4, "_tasktemplateid" int4)
  RETURNS TABLE("id" int4, "company_id" int4, "property_id" int4, "propertyvalue_id" int4, "tasktemplate_id" int4, "primary_int_value" int4, "secondary_int_value" int4, "primary_decimal_value" numeric, "secondary_decimal_value" numeric, "primary_string_value" text, "secondary_string_value" text, "primary_datetime_value" timestamp, "secondary_datetime_value" timestamp, "primary_time_value" time, "secondary_time_value" time, "bool_value" bool, "custom_value_type_display" varchar, "custom_title_display" varchar, "custom_display_type" varchar, "display_type" int4, "is_required" bool, "index" int4, "created_at" timestamp, "modified_at" timestamp) AS $BODY$BEGIN
	RETURN QUERY
		SELECT 
		TTP.id, 
		TTP.company_id, 
		TTP.property_id, 
		TTP.propertyvalue_id, 
		TTP.tasktemplate_id,
		TTP.primary_int_value, 
		TTP.secondary_int_value, 
		TTP.primary_decimal_value, 
		TTP.secondary_decimal_value, 
		TTP.primary_string_value, 
		TTP.secondary_string_value, 
		TTP.primary_datetime_value,
		TTP.secondary_datetime_value,
		TTP.primary_time_value,
		TTP.secondary_time_value,
		TTP.bool_value, 
		TTP.custom_value_type_display, 
		TTP.custom_title_display, 
		TTP.custom_display_type,
		TTP.display_type,
		TTP.is_required, 
		TTP.index, 
		TTP.created_at, 
		TTP.modified_at 
		FROM tasks_tasktemplate_properties TTP
		WHERE TTP.company_id = _companyid AND TTP.tasktemplate_id = _tasktemplateid
		AND TTP.is_active = true
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplates_with_actions
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplates_with_actions"("_companyid" int4, "_isresolved" bool, "_createdbyid" int4, "_timestamp" timestamp, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplates_with_actions"("_companyid" int4, "_isresolved" bool=NULL::boolean, "_createdbyid" int4=NULL::integer, "_timestamp" timestamp=NULL::timestamp without time zone, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("area_id" int4, "company_id" int4, "description" text, "description_file" varchar, "deeplink_id" int4, "deeplink_to" varchar, "id" int4, "index" int4, "name" varchar, "picture" varchar, "role" varchar, "type" varchar, "video" varchar, "video_thumbnail" varchar, "weight" numeric, "planned_time" int4, "machine_status" varchar, "recurrency_type" varchar, "actionnr" int4, "stepnr" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	CASE WHEN TT.area_id IS NULL THEN
		TTR.area_id
	ELSE 
		TT.area_id
	END::int AS area_id,  
TT.company_id, 
TT.description, 
TT.description_file, 
TT.deeplink_id,
TT.deeplink_to,
TT.id, 
TT.index,
TT.name, 
TT.picture, 
TT.role, 
TT.type, 
TT.video, 
TT.video_thumbnail, 
TT.weight,
TT.planned_time,
TT.machine_status,
TTR.type AS recurrency_type,
(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE AA.task_template_id = TT.id AND AA.is_resolved = false AND AA.is_active = true) AS actionnr,
(SELECT COUNT(TTS.id) FROM tasks_tasktemplatestep TTS 
INNER JOIN tasks_tasktemplate TTT ON TTT.id = TTS.template_id
WHERE TTS.is_active = true AND TTT.company_id = TT.company_id AND TTS.template_id = TT.id)::int AS stepnr
FROM tasks_tasktemplate TT 
INNER JOIN actions_action A ON A.task_template_id = TT.id AND A.is_active = true
LEFT JOIN tasks_taskrecurrency TTR ON TTR.template_id = TT.id
WHERE TT.is_active = true AND TT.company_id = _companyid 

	AND A.id IN (
		SELECT AA1.id FROM actions_action AA1 
		WHERE AA1.company_id = _companyid AND AA1.is_active = true
		AND (AA1.created_by_id = _createdbyid OR _createdbyid IS NULL)
		AND (AA1.is_resolved = _isresolved OR _isresolved IS NULL)
		AND (AA1.created_at < _timestamp OR _timestamp IS NULL)
		ORDER BY AA1.due_date DESC, AA1.modified_at DESC, AA1.created_at DESC, AA1.id ASC
		LIMIT CASE WHEN (_limit > 0) THEN _limit END 
		OFFSET CASE WHEN (_offset > 0) THEN _offset END
	)
	
ORDER BY index, name, id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplates_with_audittemplates
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplates_with_audittemplates"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplates_with_audittemplates"("_companyid" int4, "_timestamp" timestamp=NULL::timestamp without time zone, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("area_id" int4, "audittemplate_id" int4, "company_id" int4, "description" text, "description_file" varchar, "deeplink_id" int4, "deeplink_to" varchar, "id" int4, "index" int4, "name" varchar, "picture" varchar, "role" varchar, "type" varchar, "video" varchar, "video_thumbnail" varchar, "weight" numeric, "planned_time" int4, "machine_status" varchar, "actionnr" int4, "stepnr" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
TT.area_id, 
AAT.audittemplate_id,
TT.company_id, 
TT.description, 
TT.description_file, 
TT.deeplink_id,
TT.deeplink_to,
TT.id, 
TT.index,
TT.name, 
TT.picture, 
TT.role, 
TT.type, 
TT.video, 
TT.video_thumbnail, 
TT.weight,
TT.planned_time,
TT.machine_status,
(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE AA.task_template_id = TT.id AND AA.is_resolved = false AND AA.is_active = true) AS actionnr,
(SELECT COUNT(TTT.id) FROM tasks_tasktemplatestep TTS 
INNER JOIN tasks_tasktemplate TTT ON TTT.id = TTS.template_id
WHERE  TTS.is_active = true AND TTT.company_id = TT.company_id AND TTS.template_id = TT.id)::int AS stepnr
FROM tasks_tasktemplate TT 
INNER JOIN audits_audittemplate_tasks AAT ON AAT.tasktemplate_id = TT.id
WHERE TT.is_active = true AND TT.company_id = _companyid 
AND AAT.audittemplate_id IN (SELECT AA1.id FROM audits_audittemplate AA1 
														 WHERE AA1.company_id = _companyid AND AA1.is_active = true
														 AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = AA1.area_id) OR _areaid= 0) 
														 AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_audittemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = AA1.id) OR _userid = 0) 
														 AND (AA1.modified_at < _timestamp OR _timestamp IS NULL)
														 ORDER BY AA1.Name ASC, AA1.id
														 LIMIT CASE WHEN (_limit > 0) THEN _limit END 
														 OFFSET CASE WHEN (_offset > 0) THEN _offset END)
ORDER BY AAT.audittemplate_id DESC, TT.index, TT.name, TT.id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplates_with_checklisttemplates
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplates_with_checklisttemplates"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplates_with_checklisttemplates"("_companyid" int4, "_timestamp" timestamp=NULL::timestamp without time zone, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("area_id" int4, "checklisttemplate_id" int4, "company_id" int4, "description" text, "description_file" varchar, "deeplink_id" int4, "deeplink_to" varchar, "id" int4, "index" int4, "name" varchar, "picture" varchar, "role" varchar, "type" varchar, "video" varchar, "video_thumbnail" varchar, "weight" numeric, "planned_time" int4, "machine_status" varchar, "actionnr" int4, "stepnr" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
TT.area_id, 
CCT.checklisttemplate_id,
TT.company_id, 
TT.description, 
TT.description_file, 
TT.deeplink_id,
TT.deeplink_to,
TT.id, 
TT.index,
TT.name, 
TT.picture, 
TT.role, 
TT.type, 
TT.video, 
TT.video_thumbnail, 
TT.weight,
TT.planned_time,
TT.machine_status,
(SELECT Count(AA.id)::int4 FROM actions_action AA WHERE AA.task_template_id = TT.id AND AA.is_resolved = false AND AA.is_active = true) AS actionnr,
(SELECT COUNT(TTT.id) FROM tasks_tasktemplatestep TTS 
INNER JOIN tasks_tasktemplate TTT ON TTT.id = TTS.template_id
WHERE  TTS.is_active = true AND TTT.company_id = TT.company_id AND TTS.template_id = TT.id)::int AS stepnr
FROM tasks_tasktemplate TT 
INNER JOIN checklists_checklisttemplate_tasks CCT ON CCT.tasktemplate_id = TT.id
WHERE TT.is_active = true AND TT.company_id = _companyid 
AND CCT.checklisttemplate_id IN (
		SELECT CC1.id FROM checklists_checklisttemplate CC1 
		WHERE CC1.company_id = _companyid AND CC1.is_active = true
		AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = CC1.area_id) OR _areaid= 0) 
		AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_checklisttemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = CC1.id) OR _userid = 0) 
		AND (CC1.modified_at < _timestamp OR _timestamp IS NULL)
		ORDER BY CC1.name ASC, CC1.id
		LIMIT CASE WHEN (_limit > 0) THEN _limit END 
		OFFSET CASE WHEN (_offset > 0) THEN _offset END
)
ORDER BY CCT.checklisttemplate_id DESC, TT.index, TT.name, TT.id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplatestep
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplatestep"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplatestep"("_companyid" int4, "_id" int4)
  RETURNS TABLE("id" int4, "index" int4, "description" text, "picture" varchar, "template_id" int4, "video" varchar, "video_thumbnail" varchar) AS $BODY$BEGIN
	RETURN QUERY
 SELECT TS.id, TS.index, TS.description, TS.picture, TS.template_id, TS.video, TS.video_thumbnail FROM tasks_tasktemplatestep TS 
	 INNER JOIN tasks_tasktemplate TT ON TT.id = TS.template_id AND TT.is_active = true AND TT.company_id = _companyid
	 WHERE TS.is_active = true AND TS.id = _id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplatesteps
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplatesteps"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplatesteps"("_companyid" int4, "_timestamp" timestamp=NULL::timestamp without time zone, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("id" int4, "index" int4, "description" text, "picture" varchar, "template_id" int4, "video" varchar, "video_thumbnail" varchar) AS $BODY$BEGIN
	RETURN QUERY
	 SELECT TS.id, TS.index,TS.description, TS.picture, TS.template_id, TS.video, TS.video_thumbnail FROM tasks_tasktemplatestep TS 
	 INNER JOIN tasks_tasktemplate TT ON TT.id = TS.template_id AND TT.is_active = true 
	 WHERE TS.is_active = true AND TT.company_id = _companyid 
	 /*AND TT.id IN ( 
									SELECT T2.id FROM tasks_tasktemplate T2 
									INNER JOIN tasks_taskrecurrency TTR2 ON TTR2.template_id = T2.id
									WHERE T2.is_active = true AND T2.company_id = _companyid 

									AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR2.area_id) OR _areaid= 0) 
									AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_checklisttemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = T2.id) OR _userid = 0) 
									AND (T2.created_at::timestamp < get_timestamp_without_companytimezone(_companyid, _timestamp) OR _timestamp IS NULL)

									ORDER BY TT.index, TT.name, TT.id
									LIMIT CASE WHEN (_limit > 0) THEN _limit END 
									OFFSET CASE WHEN (_offset > 0) THEN _offset END
								)*/
	 
	 ORDER BY TS.template_id, TS.index;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplatesteps_by_tasktemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplatesteps_by_tasktemplate"("_companyid" int4, "_tasktemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplatesteps_by_tasktemplate"("_companyid" int4, "_tasktemplateid" int4)
  RETURNS TABLE("id" int4, "index" int4, "description" text, "picture" varchar, "template_id" int4, "video" varchar, "video_thumbnail" varchar) AS $BODY$BEGIN
	RETURN QUERY
 SELECT TS.id, TS.index, TS.description, TS.picture, TS.template_id, TS.video, TS.video_thumbnail FROM tasks_tasktemplatestep TS 
	 INNER JOIN tasks_tasktemplate TT ON TT.id = TS.template_id AND TT.is_active = true AND TT.company_id = _companyid
	 WHERE TS.is_active = true AND TS.template_id = _tasktemplateid ORDER BY TS.index;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplatesteps_with_audittemplates
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplatesteps_with_audittemplates"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplatesteps_with_audittemplates"("_companyid" int4, "_timestamp" timestamp=NULL::timestamp without time zone, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("id" int4, "index" int4, "description" text, "picture" varchar, "template_id" int4, "video" varchar, "video_thumbnail" varchar) AS $BODY$BEGIN
	RETURN QUERY
	 SELECT TS.id, TS.index,TS.description, TS.picture, TS.template_id, TS.video, TS.video_thumbnail FROM tasks_tasktemplatestep TS 
	 INNER JOIN tasks_tasktemplate TT ON TT.id = TS.template_id AND TT.is_active = true 
	 INNER JOIN audits_audittemplate_tasks AAT ON AAT.tasktemplate_id = TT.id
	 WHERE TS.is_active = true AND TT.company_id = _companyid 
	 AND AAT.audittemplate_id IN (SELECT AA1.id FROM audits_audittemplate AA1 
														 WHERE AA1.company_id = _companyid AND AA1.is_active = true
														 AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = AA1.area_id) OR _areaid= 0) 
														 AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_audittemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = AA1.id) OR _userid = 0) 
														 AND (AA1.modified_at < _timestamp OR _timestamp IS NULL)
														 ORDER BY AA1.Name ASC, AA1.id
														 LIMIT CASE WHEN (_limit > 0) THEN _limit END 
														 OFFSET CASE WHEN (_offset > 0) THEN _offset END)
	  ORDER BY TS.template_id, TS.index;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tasktemplatesteps_with_checklisttemplates
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tasktemplatesteps_with_checklisttemplates"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4, "_limit" int4, "_offset" int4);
CREATE OR REPLACE FUNCTION "public"."get_tasktemplatesteps_with_checklisttemplates"("_companyid" int4, "_timestamp" timestamp=NULL::timestamp without time zone, "_areaid" int4=0, "_userid" int4=0, "_limit" int4=0, "_offset" int4=0)
  RETURNS TABLE("id" int4, "index" int4, "description" text, "picture" varchar, "template_id" int4, "video" varchar, "video_thumbnail" varchar) AS $BODY$BEGIN
	RETURN QUERY
	 SELECT TS.id, TS.index,TS.description, TS.picture, TS.template_id, TS.video, TS.video_thumbnail FROM tasks_tasktemplatestep TS 
	 INNER JOIN tasks_tasktemplate TT ON TT.id = TS.template_id AND TT.is_active = true 
	 INNER JOIN checklists_checklisttemplate_tasks CCT ON CCT.tasktemplate_id = TT.id
	 WHERE TS.is_active = true AND TT.company_id = _companyid 
	 AND CCT.checklisttemplate_id IN (
				SELECT CC1.id FROM checklists_checklisttemplate CC1 
				WHERE CC1.company_id = _companyid AND CC1.is_active = true
				AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = CC1.area_id) OR _areaid= 0) 
				AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_checklisttemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = CC1.id) OR _userid = 0) 
				AND (CC1.modified_at < _timestamp OR _timestamp IS NULL)
				ORDER BY CC1.name ASC, CC1.id
				LIMIT CASE WHEN (_limit > 0) THEN _limit END 
				OFFSET CASE WHEN (_offset > 0) THEN _offset END
		)
	 ORDER BY TS.template_id, TS.index;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_timestamp_with_companytimezone
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_timestamp_with_companytimezone"("_companyid" int4, "_timestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_timestamp_with_companytimezone"("_companyid" int4, "_timestamp" timestamp)
  RETURNS "pg_catalog"."timestamp" AS $BODY$
DECLARE 
	_convertedtimestamp timestamp;
	_timezone varchar;
BEGIN
		-- get company setting, based on resource setting id 1: company timezone;
		SELECT value INTO _timezone FROM companies_setting WHERE resource_setting_id = 1 and company_id = _companyid;
		IF (_timezone <> '') THEN
			_convertedtimestamp = timezone(_timezone, _timestamp::timestamptz);
		ELSE
			_convertedtimestamp = _timestamp; -- no timezone available don't convert
		END IF;
		-- outputted value will be the timestamp + the company offset.
	  RETURN _convertedtimestamp;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for get_timestamp_without_companytimezone
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_timestamp_without_companytimezone"("_companyid" int4, "_timestamp" timestamp);
CREATE OR REPLACE FUNCTION "public"."get_timestamp_without_companytimezone"("_companyid" int4, "_timestamp" timestamp)
  RETURNS "pg_catalog"."timestamp" AS $BODY$
DECLARE 
	_convertedtimestamp timestamp;
	_timezone varchar;
BEGIN
		-- get company setting, based on resource setting id 1: company timezone;
		SELECT value INTO _timezone FROM companies_setting WHERE resource_setting_id = 1 and company_id = _companyid;
		IF (_timezone <> '') THEN
			_convertedtimestamp = timezone(_timezone, _timestamp::timestamp);
		ELSE
			_convertedtimestamp = _timestamp; -- no timezone available don't convert
		END IF;
		-- outputted value will be the timestamp - company timestamp (e.g. normally utc output).
	  RETURN _convertedtimestamp;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for get_timezone_with_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_timezone_with_company"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_timezone_with_company"("_companyid" int4)
  RETURNS "pg_catalog"."varchar" AS $BODY$
DECLARE 
	_timezone varchar;
BEGIN
		-- get company setting, based on resource setting id 1: company timezone;
		SELECT value INTO _timezone FROM companies_setting WHERE resource_setting_id = 1 and company_id = _companyid;
		IF (_timezone IS NULL OR _timezone = '') THEN
			_timezone = 'Europe/Amsterdam'; -- default, fallback is NL
		END IF;
	  RETURN _timezone;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for get_token_by_username_and_password
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_token_by_username_and_password"("_username" varchar, "_password" varchar);
CREATE OR REPLACE FUNCTION "public"."get_token_by_username_and_password"("_username" varchar, "_password" varchar)
  RETURNS SETOF "pg_catalog"."varchar" AS $BODY$
	BEGIN
	RETURN QUERY
	SELECT AT.key FROM profiles_user PU INNER JOIN authtoken_token AT ON AT.user_id = PU.id WHERE PU.username = _username AND PU.password = _password AND PU.is_active = true AND PU.is_deleted = false LIMIT 1;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tools_database_timezones
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tools_database_timezones"();
CREATE OR REPLACE FUNCTION "public"."get_tools_database_timezones"()
  RETURNS TABLE("name" varchar, "abbrev" varchar, "utc_offset" varchar, "is_dst" bool) AS $BODY$BEGIN
	RETURN QUERY
	SELECT TN.name::varchar AS name, TN.abbrev::varchar AS abbrev, TN.utc_offset::varchar, TN.is_dst::bool 
	FROM pg_timezone_names TN
	ORDER BY name;
	END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tools_latest_auditlogs
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tools_latest_auditlogs"();
CREATE OR REPLACE FUNCTION "public"."get_tools_latest_auditlogs"()
  RETURNS TABLE("id" int8, "original_object" text, "mutated_object" text, "object_type" varchar, "object_id" int4, "company_id" int4, "user_id" int4, "description" text, "created_on" timestamptz) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	LDA.id, 
	LDA.original_object, 
	LDA.mutated_object, 
	LDA.object_type, 
	LDA.object_id, 
	LDA.company_id, 
	LDA.user_id, 
	LDA.description, 
	LDA.created_on 
	FROM logging_data_auditing LDA
	WHERE LDA.created_on > CURRENT_TIMESTAMP - INTERVAL '1 months'
	ORDER BY LDA.created_on DESC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tools_latest_auditlogs_company
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tools_latest_auditlogs_company"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tools_latest_auditlogs_company"("_companyid" int4)
  RETURNS TABLE("id" int8, "original_object" text, "mutated_object" text, "object_type" varchar, "object_id" int4, "company_id" int4, "user_id" int4, "description" text, "created_on" timestamptz) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	LDA.id, 
	LDA.original_object, 
	LDA.mutated_object, 
	LDA.object_type, 
	LDA.object_id, 
	LDA.company_id, 
	LDA.user_id, 
	LDA.description, 
	LDA.created_on 
	FROM logging_data_auditing LDA
	WHERE LDA.company_id = _companyid
	AND LDA.created_on > CURRENT_TIMESTAMP - INTERVAL '1 months'
	ORDER BY LDA.created_on DESC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tools_latest_auditlogs_user
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tools_latest_auditlogs_user"("_userid" int4, "_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_tools_latest_auditlogs_user"("_userid" int4, "_companyid" int4)
  RETURNS TABLE("id" int8, "original_object" text, "mutated_object" text, "object_type" varchar, "object_id" int4, "company_id" int4, "user_id" int4, "description" text, "created_on" timestamptz) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	LDA.id, 
	LDA.original_object, 
	LDA.mutated_object, 
	LDA.object_type, 
	LDA.object_id, 
	LDA.company_id, 
	LDA.user_id, 
	LDA.description, 
	LDA.created_on 
	FROM logging_data_auditing LDA
	WHERE LDA.company_id = _companyid AND LDA.user_id = _userid
	AND LDA.created_on > CURRENT_TIMESTAMP - INTERVAL '1 months'
	ORDER BY LDA.created_on DESC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_tools_latest_logs
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tools_latest_logs"();
CREATE OR REPLACE FUNCTION "public"."get_tools_latest_logs"()
  RETURNS "pg_catalog"."text" AS $BODY$
	SELECT to_json(json_agg(T.*))::text AS results FROM ( 
	SELECT * FROM logging_log ORDER BY id DESC LIMIT 25
	) AS T;
$BODY$
  LANGUAGE sql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for get_tools_latest_logs_requestresponses
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_tools_latest_logs_requestresponses"();
CREATE OR REPLACE FUNCTION "public"."get_tools_latest_logs_requestresponses"()
  RETURNS "pg_catalog"."text" AS $BODY$
			SELECT to_json(json_agg(T.*))::text AS results FROM ( 
	SELECT * FROM logging_requestresponse ORDER BY id DESC LIMIT 25
	) AS T;
$BODY$
  LANGUAGE sql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for get_user_allowed_audittemplateids
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_user_allowed_audittemplateids"("_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."get_user_allowed_audittemplateids"("_companyid" int4, "_userid" int4)
  RETURNS TABLE("id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT AAT.id FROM audits_audittemplate AAT
	INNER JOIN profiles_user_allowed_areas PUAA ON PUAA.area_id = AAT.area_id AND PUAA.user_id = _userid
	INNER JOIN profiles_user PU ON PU.id = PUAA.user_id
	INNER JOIN companies_area CA ON CA.id = PUAA.area_id AND CA.is_active = true
	WHERE AAT.company_id = _companyid AND AAT.is_active = true 
	AND (AAT.role = PU.role -- for basic role, only items where basic = basic
			 OR PU.role = 'manager' -- for manager role, can see everything
			 OR PU.role = 'shift_leader' AND (AAT.role = 'basic' OR AAT.role = 'shift_leader') -- for shift_leader role, see shift leader and basic roles
			 )
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_user_allowed_checklisttemplateids
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_user_allowed_checklisttemplateids"("_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."get_user_allowed_checklisttemplateids"("_companyid" int4, "_userid" int4)
  RETURNS TABLE("id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT CCT.id FROM checklists_checklisttemplate CCT
	INNER JOIN profiles_user_allowed_areas PUAA ON PUAA.area_id = CCT.area_id AND PUAA.user_id = _userid
	INNER JOIN profiles_user PU ON PU.id = PUAA.user_id
	INNER JOIN companies_area CA ON CA.id = PUAA.area_id AND CA.is_active = true
	WHERE CCT.company_id = _companyid AND CCT.is_active = true 
	AND (CCT.role = PU.role -- for basic role, only items where basic = basic
			 OR PU.role = 'manager' -- for manager role, can see everything
			 OR PU.role = 'shift_leader' AND (CCT.role = 'basic' OR CCT.role = 'shift_leader') -- for shift_leader role, see shift leader and basic roles
			 )
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_user_allowed_tasktemplateids
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_user_allowed_tasktemplateids"("_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."get_user_allowed_tasktemplateids"("_companyid" int4, "_userid" int4)
  RETURNS TABLE("id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT TTT.id FROM tasks_tasktemplate TTT
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	INNER JOIN profiles_user_allowed_areas PUAA ON (PUAA.area_id = TTR.area_id OR PUAA.area_id = TTT.area_id) AND PUAA.user_id = _userid
	INNER JOIN profiles_user PU ON PU.id = PUAA.user_id
	INNER JOIN companies_area CA ON CA.id = PUAA.area_id AND CA.is_active = true
	WHERE TTT.company_id = _companyid AND TTT.is_active = true
		AND (TTT.role = PU.role -- for basic role, only items where basic = basic
			 OR PU.role = 'manager' -- for manager role, can see everything
			 OR PU.role = 'shift_leader' AND (TTT.role = 'basic' OR TTT.role = 'shift_leader') -- for shift_leader role, see shift leader and basic roles
			 )
	;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_user_areas
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_user_areas"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_user_areas"("_companyid" int4)
  RETURNS TABLE("id" int4, "name" varchar, "area_name_full" varchar, "user_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT CA.id, CA.name, get_task_area_full(CA.id)::varchar AS area_full, PUA.user_id FROM profiles_user_allowed_areas PUA
INNER JOIN companies_area CA ON CA.id = PUA.area_id
WHERE company_id = _companyid ORDER BY PUA.user_id, area_full, CA.level, CA.parent_id;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_userid_by_token
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_userid_by_token"("token" varchar);
CREATE OR REPLACE FUNCTION "public"."get_userid_by_token"("token" varchar)
  RETURNS SETOF "pg_catalog"."int4" AS $BODY$
  BEGIN 
	RETURN QUERY 
	SELECT PU.id FROM authtoken_token ATT
	INNER JOIN profiles_user PU ON PU.id = ATT.user_id
	WHERE ATT.key = token;
	END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_userid_companyid_by_token
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_userid_companyid_by_token"("_token" varchar);
CREATE OR REPLACE FUNCTION "public"."get_userid_companyid_by_token"("_token" varchar)
  RETURNS TABLE("company_id" int4, "user_id" int4) AS $BODY$BEGIN 
	RETURN QUERY 
	SELECT pu.company_id, pu.id AS user_id FROM authtoken_token ATT
	INNER JOIN profiles_user PU ON PU.id = ATT.user_id
	WHERE ATT.key = _token;
	END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_userpassword_by_userid
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_userpassword_by_userid"("_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_userpassword_by_userid"("_id" int4)
  RETURNS SETOF "pg_catalog"."varchar" AS $BODY$
  BEGIN
    RETURN QUERY
    SELECT PU.password FROM profiles_user PU
    WHERE PU.id = _id;
    END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_userpassword_by_username
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_userpassword_by_username"("_username" varchar);
CREATE OR REPLACE FUNCTION "public"."get_userpassword_by_username"("_username" varchar)
  RETURNS SETOF "pg_catalog"."varchar" AS $BODY$
  BEGIN 
	RETURN QUERY 
	SELECT PU.password FROM profiles_user PU
	WHERE PU.username = _username;
	END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_userprofile
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_userprofile"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."get_userprofile"("_companyid" int4, "_id" int4)
  RETURNS TABLE("id" int4, "first_name" varchar, "last_name" varchar, "email" varchar, "picture" varchar, "role" varchar, "is_staff" bool, "is_superuser" bool, "upn" varchar, "username" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT PU.id, PU.first_name, PU.last_name, PU.email, PU.picture, PU.role, PU.is_staff, PU.is_superuser, PU.upn, PU.username FROM profiles_user PU WHERE PU.company_id = _companyid AND PU.is_active = true AND PU.is_deleted = false  AND PU.id = _id ORDER BY PU.last_name, PU.first_name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_userprofile_by_token
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_userprofile_by_token"("_companyid" int4, "_token" varchar);
CREATE OR REPLACE FUNCTION "public"."get_userprofile_by_token"("_companyid" int4, "_token" varchar)
  RETURNS TABLE("id" int4, "first_name" varchar, "last_name" varchar, "email" varchar, "picture" varchar, "role" varchar, "is_staff" bool, "is_superuser" bool, "upn" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT PU.id, PU.first_name, PU.last_name, PU.email, PU.picture, PU.role, PU.is_staff, PU.is_superuser, PU.upn FROM profiles_user PU INNER JOIN authtoken_token AT ON AT.user_id = PU.id WHERE PU.company_id = _companyid AND AT.key = _token AND PU.is_active = true AND PU.is_deleted = false LIMIT 1;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_userprofiles
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_userprofiles"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."get_userprofiles"("_companyid" int4)
  RETURNS TABLE("id" int4, "first_name" varchar, "last_name" varchar, "email" varchar, "picture" varchar, "role" varchar, "is_staff" bool, "is_superuser" bool) AS $BODY$BEGIN
	RETURN QUERY
	SELECT PU.id, PU.first_name, PU.last_name, PU.email, PU.picture, PU.role, PU.is_staff, PU.is_superuser FROM profiles_user PU WHERE PU.company_id = _companyid AND PU.is_active = true AND PU.is_deleted = false ORDER BY PU.last_name, PU.first_name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for get_viewedcommentuserids_by_comment
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."get_viewedcommentuserids_by_comment"("_companyid" int4, "_commentid" int4);
CREATE OR REPLACE FUNCTION "public"."get_viewedcommentuserids_by_comment"("_companyid" int4, "_commentid" int4)
  RETURNS TABLE("user_id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT VC.user_id 
	FROM actions_actioncommentviewed VC
	INNER JOIN actions_actioncomment AC ON AC.id = VC.comment_id
	INNER JOIN actions_action AA ON AA.id = AC.action_id
	WHERE AA.company_id = _companyid AND VC.comment_id = _commentid;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for offline_media_images
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."offline_media_images"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."offline_media_images"("_companyid" int4)
  RETURNS TABLE("MediaType" varchar, "MediaUri" varchar, "ModifiedAt" timestamptz) AS $BODY$BEGIN
	RETURN QUERY
	-- Media Used:
	-- actions_action : image_0,image_1, image_2, image_3, image_4, image_5, video_0,video_1, video_2, video_3, video_4, video_5, video_thumbnail_0,video_thumbnail_1, video_thumbnail_2, video_thumbnail_3, video_thumbnail_4, video_thumbnail_5
	-- actions_actioncomment: image_0,image_1, image_2, image_3, image_4, image_5, video, video_thumbnail
	-- audits_audit: signature_1, signature_2
	-- audits_audittemplate: picture
	-- checklists_checklist: signature_1, signature_2
	-- checklists_checklisttemplate: picture
	-- companies_company: picture
	-- profiles_user: picture
	-- tasks_tasktemplate: picture, video, video_thumbnail
	-- tasks_tasktemplatestep: picture, video, video_thumbnail
	SELECT MediaType, MediaUri, modified_at AS ModifiedAt FROM (
	SELECT 'I'::varchar AS MediaType,I.image_0 AS MediaUri, I.modified_at FROM actions_action I WHERE I.image_0 IS NOT NULL AND I.image_0 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.image_1 AS MediaUri, I.modified_at FROM actions_action I WHERE I.image_1 IS NOT NULL AND I.image_0 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.image_2 AS MediaUri, I.modified_at FROM actions_action I WHERE I.image_2 IS NOT NULL AND I.image_0 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.image_3 AS MediaUri, I.modified_at FROM actions_action I WHERE I.image_3 IS NOT NULL AND I.image_0 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.image_4 AS MediaUri, I.modified_at FROM actions_action I WHERE I.image_4 IS NOT NULL AND I.image_0 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.image_5 AS MediaUri, I.modified_at FROM actions_action I WHERE I.image_5 IS NOT NULL AND I.image_0 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'V'::varchar AS MediaType,I.video_0 AS MediaUri, I.modified_at FROM actions_action I WHERE I.video_0 IS NOT NULL AND I.video_0 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'V'::varchar AS MediaType,I.video_1 AS MediaUri, I.modified_at FROM actions_action I WHERE I.video_1 IS NOT NULL AND I.video_1 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'V'::varchar AS MediaType,I.video_2 AS MediaUri, I.modified_at FROM actions_action I WHERE I.video_2 IS NOT NULL AND I.video_2 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'V'::varchar AS MediaType,I.video_3 AS MediaUri, I.modified_at FROM actions_action I WHERE I.video_3 IS NOT NULL AND I.video_3 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'V'::varchar AS MediaType,I.video_4 AS MediaUri, I.modified_at FROM actions_action I WHERE I.video_4 IS NOT NULL AND I.video_4 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'V'::varchar AS MediaType,I.video_5 AS MediaUri, I.modified_at FROM actions_action I WHERE I.video_5 IS NOT NULL AND I.video_5 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.video_thumbnail_0 AS MediaUri, I.modified_at FROM actions_action I WHERE I.video_thumbnail_0 IS NOT NULL AND I.video_thumbnail_0 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.video_thumbnail_1 AS MediaUri, I.modified_at FROM actions_action I WHERE I.video_thumbnail_1 IS NOT NULL AND I.video_thumbnail_1 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.video_thumbnail_2 AS MediaUri, I.modified_at FROM actions_action I WHERE I.video_thumbnail_2 IS NOT NULL AND I.video_thumbnail_2 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.video_thumbnail_3 AS MediaUri, I.modified_at FROM actions_action I WHERE I.video_thumbnail_3 IS NOT NULL AND I.video_thumbnail_3 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.video_thumbnail_4 AS MediaUri, I.modified_at FROM actions_action I WHERE I.video_thumbnail_4 IS NOT NULL AND I.video_thumbnail_4 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.video_thumbnail_5 AS MediaUri, I.modified_at FROM actions_action I WHERE I.video_thumbnail_5 IS NOT NULL AND I.video_thumbnail_5 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.video_thumbnail AS MediaUri, I.modified_at FROM actions_action I WHERE I.video_thumbnail IS NOT NULL AND I.video_thumbnail <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'V'::varchar AS MediaType,I.video AS MediaUri, I.modified_at FROM actions_action I WHERE I.video IS NOT NULL AND I.video <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.image_0 AS MediaUri, I.modified_at FROM actions_actioncomment I INNER JOIN actions_action A ON A.id = I.action_id WHERE I.video IS NOT NULL AND I.video <> '' AND A.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.image_1 AS MediaUri, I.modified_at FROM actions_actioncomment I INNER JOIN actions_action A ON A.id = I.action_id WHERE I.video IS NOT NULL AND I.video <> '' AND A.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.image_2 AS MediaUri, I.modified_at FROM actions_actioncomment I INNER JOIN actions_action A ON A.id = I.action_id WHERE I.video IS NOT NULL AND I.video <> '' AND A.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.image_3 AS MediaUri, I.modified_at FROM actions_actioncomment I INNER JOIN actions_action A ON A.id = I.action_id WHERE I.video IS NOT NULL AND I.video <> '' AND A.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.image_4 AS MediaUri, I.modified_at FROM actions_actioncomment I INNER JOIN actions_action A ON A.id = I.action_id WHERE I.video IS NOT NULL AND I.video <> '' AND A.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'V'::varchar AS MediaType,I.video AS MediaUri, I.modified_at FROM actions_actioncomment I INNER JOIN actions_action A ON A.id = I.action_id WHERE I.video IS NOT NULL AND I.video <> '' AND A.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.video_thumbnail AS MediaUri, I.modified_at FROM actions_actioncomment I INNER JOIN actions_action A ON A.id = I.action_id WHERE I.video IS NOT NULL AND I.video <> '' AND A.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.signature_1 AS MediaUri, I.modified_at FROM audits_audit I WHERE I.signature_1 IS NOT NULL AND I.signature_1 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.signature_2 AS MediaUri, I.modified_at FROM audits_audit I WHERE I.signature_2 IS NOT NULL AND I.signature_2 <> '' AND I.company_id = _companyid AND I.is_active = true
  UNION
	SELECT 'I'::varchar AS MediaType,I.picture AS MediaUri, I.modified_at FROM audits_audittemplate I WHERE I.picture IS NOT NULL AND I.picture <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.signature_1 AS MediaUri, I.modified_at FROM checklists_checklist I WHERE I.signature_1 IS NOT NULL AND I.signature_1 <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
	SELECT 'I'::varchar AS MediaType,I.signature_2 AS MediaUri, I.modified_at FROM checklists_checklist I WHERE I.signature_2 IS NOT NULL AND I.signature_2 <> '' AND I.company_id = _companyid AND I.is_active = true
  UNION
	SELECT 'I'::varchar AS MediaType,I.picture AS MediaUri, I.modified_at FROM checklists_checklisttemplate I WHERE I.picture IS NOT NULL AND I.picture <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION 	
	SELECT 'I'::varchar AS MediaType,I.picture AS MediaUri, I.modified_at FROM companies_company I WHERE I.picture IS NOT NULL AND I.picture <> '' AND I.id = _companyid AND I.is_active = true
	UNION 	
	SELECT 'I'::varchar AS MediaType,I.picture AS MediaUri, I.modified_at FROM profiles_user I WHERE I.picture IS NOT NULL AND I.picture <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
  SELECT 'I'::varchar AS MediaType,I.picture AS MediaUri, I.modified_at FROM tasks_tasktemplate I WHERE I.picture IS NOT NULL AND I.picture <> '' AND I.company_id = _companyid AND I.is_active = true
	UNION
  SELECT 'V'::varchar AS MediaType,I.video AS MediaUri, I.modified_at FROM tasks_tasktemplate I WHERE I.video IS NOT NULL AND I.video <> '' AND I.company_id = _companyid AND I.is_active = true
  UNION
  SELECT 'I'::varchar AS MediaType,I.video_thumbnail AS MediaUri, I.modified_at FROM tasks_tasktemplate I WHERE I.video_thumbnail IS NOT NULL AND I.video_thumbnail <> '' AND I.company_id = _companyid AND I.is_active = true
  UNION
  SELECT 'I'::varchar AS MediaType,I.picture AS MediaUri, I.modified_at FROM tasks_tasktemplatestep I INNER JOIN tasks_tasktemplate A ON A.id = I.template_id WHERE I.picture IS NOT NULL AND I.picture <> '' AND A.company_id = _companyid AND A.is_active = true
	UNION
  SELECT 'V'::varchar AS MediaType,I.video AS MediaUri, I.modified_at FROM tasks_tasktemplatestep I INNER JOIN tasks_tasktemplate A ON A.id = I.template_id WHERE I.video IS NOT NULL AND I.video <> '' AND A.company_id = _companyid AND A.is_active = true
  UNION
  SELECT 'I'::varchar AS MediaType,I.video_thumbnail AS MediaUri, I.modified_at FROM tasks_tasktemplatestep I INNER JOIN tasks_tasktemplate A ON A.id = I.template_id WHERE I.video_thumbnail IS NOT NULL AND I.video_thumbnail <> '' AND A.company_id = _companyid AND A.is_active = true
	) AS T 
	ORDER BY modified_at DESC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for raw_actions
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."raw_actions"("_companyid" int4, "_timestamp" timestamptz);
CREATE OR REPLACE FUNCTION "public"."raw_actions"("_companyid" int4, "_timestamp" timestamptz)
  RETURNS TABLE("comment" text, "company_id" int4, "created_at" timestamptz, "created_by_id" int4, "description" text, "due_date" date, "id" int4, "image_0" varchar, "image_1" varchar, "image_2" varchar, "image_3" varchar, "image_4" varchar, "image_5" varchar, "is_resolved" bool, "modified_at" timestamptz, "resolved_at" timestamptz, "task_id" int4, "task_template_id" int4, "video_0" varchar, "video_1" varchar, "video_2" varchar, "video_3" varchar, "video_4" varchar, "video_5" varchar, "video_thumbnail_0" varchar, "video_thumbnail_1" varchar, "video_thumbnail_2" varchar, "video_thumbnail_3" varchar, "video_thumbnail_4" varchar, "video_thumbnail_5" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	AA.comment, 
	AA.company_id, 
	AA.created_at, 
	AA.created_by_id,
	AA.description, 
	AA.due_date, 
	AA.id, 
	AA.image_0, 
	AA.image_1, 
	AA.image_2, 
	AA.image_3, 
	AA.image_4, 
	AA.image_5, 
	AA.is_resolved, 
	AA.modified_at, 
	AA.resolved_at, 
	AA.task_id, 
	AA.task_template_id, 
	AA.video_0, 
	AA.video_1, 
	AA.video_2, 
	AA.video_3, 
	AA.video_4, 
	AA.video_5, 
	AA.video_thumbnail_0, 
	AA.video_thumbnail_1, 
	AA.video_thumbnail_2,
	AA.video_thumbnail_3,
	AA.video_thumbnail_4,
	AA.video_thumbnail_5
	FROM actions_action AA INNER JOIN profiles_user PU ON PU.id = AA.created_by_id 
	WHERE AA.company_id = _companyid AND AA.is_active = true AND AA.created_at::date = _timestamp::date
	ORDER BY AA.due_date DESC, AA.modified_at DESC, AA.created_at DESC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for raw_audits
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."raw_audits"("_companyid" int4, "_timestamp" timestamptz);
CREATE OR REPLACE FUNCTION "public"."raw_audits"("_companyid" int4, "_timestamp" timestamptz)
  RETURNS TABLE("area_id" int4, "company_id" int4, "created_at" timestamptz, "description" text, "double_signature_required" bool, "id" int4, "is_complete" bool, "modified_at" timestamptz, "name" varchar, "picture" varchar, "score_type" varchar, "signature_1" varchar, "signature_2" varchar, "signature_required" bool, "signed_at_1" timestamptz, "signed_at_2" timestamptz, "signed_by_1_id" int4, "signed_by_2_id" int4, "template_id" int4, "total_score" int2, "min_task_score" int4, "max_task_score" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
AAT.area_id, 
AA.company_id, 
AA.created_at, 
AAT.description, 
AAT.double_signature_required, 
AA.id, 
AA.is_complete, 
AA.modified_at, 
AAT.name, 
AAT.picture, 
AAT.score_type, 
AA.signature_1, 
AA.signature_2, 
AAT.signature_required, 
AA.signed_at_1, 
AA.signed_at_2, 
AA.signed_by_1_id,
0::int4 AS signed_by_2_id,
AA.template_id, 
AA.total_score,
AAT.min_task_score,
AAT.max_task_score
FROM audits_audit AA 
INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id AND AA.company_id = AAT.company_id AND AAT.is_active = true 
WHERE AA.company_id = _companyid AND AA.is_active = true AND AA.created_at::date = _timestamp::date
ORDER BY AA.signed_at_1 DESC, AAT.name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for raw_checklists
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."raw_checklists"("_companyid" int4, "_timestamp" timestamptz);
CREATE OR REPLACE FUNCTION "public"."raw_checklists"("_companyid" int4, "_timestamp" timestamptz)
  RETURNS TABLE("area_id" int4, "company_id" int4, "created_at" timestamptz, "description" text, "double_signature_required" bool, "signature_required" bool, "id" int4, "is_complete" bool, "modified_at" timestamptz, "name" varchar, "picture" varchar, "signature_1" varchar, "signature_2" varchar, "signed_at_1" timestamptz, "signed_at_2" timestamptz, "signed_by_1_id" int4, "signed_by_2_id" int4, "template_id" int4) AS $BODY$BEGIN
	RETURN QUERY
SELECT 
CCT.area_id, 
CC.company_id, 
CC.created_at, 
CCT.description, 
CCT.double_signature_required, 
CCT.signature_required,
CC.id, 
CC.is_complete, 
CC.modified_at, 
CCT.name, 
CCT.picture, 
CC.signature_1, 
CC.signature_2, 
CC.signed_at_1, 
CC.signed_at_2, 
CC.signed_by_1_id, 
0::int4 AS signed_by_2_id,
CC.template_id
FROM checklists_checklist CC 
INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id AND CC.company_id = CCT.company_id AND CCT.is_active = true 
WHERE CC.is_active = true AND CC.company_id = _companyid AND CC.signed_at_1::date = _timestamp::date
ORDER BY CC.signed_at_1 DESC, CCT.name ASC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for raw_tasks
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."raw_tasks"("_companyid" int4, "_timestamp" timestamptz);
CREATE OR REPLACE FUNCTION "public"."raw_tasks"("_companyid" int4, "_timestamp" timestamptz)
  RETURNS TABLE("area_id" int4, "comment" text, "company_id" int4, "created_at" timestamptz, "deeplink_id" int4, "deeplink_to" varchar, "description" text, "description_file" varchar, "deviance" int4, "due_at" timestamptz, "end_date" date, "id" int4, "machine_status" varchar, "max_score" int4, "modified_at" timestamptz, "name" varchar, "picture" varchar, "planned_time" int4, "recurrency_id" int4, "score" int4, "shift_id" int4, "signed_at" timestamptz, "signed_by_id" int4, "start_at" timestamptz, "start_date" date, "status" varchar, "template_id" int4, "total_score" int4, "type" varchar, "recurrency_type" varchar, "time_realized_by_id" int4, "time_taken" int4, "video" varchar, "video_thumbnail" varchar) AS $BODY$BEGIN
	RETURN QUERY
	-- RAW data set for use for management tooling. DO NOT USE IN CLIENT APPS
	-- Usages; Get a basic overview of tasks that occure on the timestamp. 
	-- Will return all tasks that start or end on timestamp day or where timestamp falls between the start and end of a task. 
	SELECT 
	CASE WHEN TTT.area_id IS NULL THEN
		TTR.area_id
	ELSE 
		TTT.area_id
	END::int AS area_id,
TT.comment, 
TT.company_id, 
TT.created_at, 
TTT.deeplink_id,
TTT.deeplink_to,
TTT.description, 
TTT.description_file,
TT.deviance, 
TT.due_at, 
TT.end_date, 
TT.id, 
TTT.machine_status,
TT.max_score, 
TT.modified_at, 
TTT.name, 
TTT.picture, 
TTT.planned_time,
TT.recurrency_id, 
TT.score, 
TT.shift_id, 
TT.signed_at, 
TT.signed_by_id, 
TT.start_at, 
TT.start_date, 
TT.status, 
TT.template_id, 
TT.total_score, 
TTT.type,
TTR.type AS recurrency_type,
TT.time_realized_by_id,
TT.time_taken,
TTT.video,
TTT.video_thumbnail
FROM tasks_task TT 
INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.type = 'task' AND ((_timestamp BETWEEN TT.start_date AND TT.end_date) OR TT.start_date =_timestamp::date OR TT.end_date = _timestamp::date)
ORDER BY TT.start_at, TT.start_date, TTT.area_id, TTT.shift_id, TTT.name;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for remove_action_assigned_area
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."remove_action_assigned_area"("_companyid" int4, "_actionid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."remove_action_assigned_area"("_companyid" int4, "_actionid" int4, "_areaid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	DELETE FROM actions_action_assigned_areas AAA WHERE AAA.action_id = _actionid AND AAA.area_id = _areaid AND EXISTS (SELECT AA.id FROM actions_action AA WHERE AA.id = AAA.action_id AND AA.company_id = _companyid);
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for remove_action_assigned_user
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."remove_action_assigned_user"("_companyid" int4, "_actionid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."remove_action_assigned_user"("_companyid" int4, "_actionid" int4, "_userid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	DELETE FROM actions_action_assigned_users AAA WHERE AAA.action_id = _actionid AND AAA.user_id = _userid AND EXISTS (SELECT AA.id FROM actions_action AA WHERE AA.id = AAA.action_id AND AA.company_id = _companyid);
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for remove_audittemplate_property
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."remove_audittemplate_property"("_companyid" int4, "_audittemplatepropertyid" int4);
CREATE OR REPLACE FUNCTION "public"."remove_audittemplate_property"("_companyid" int4, "_audittemplatepropertyid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
		IF (SELECT COUNT(*)::int4 FROM audits_properties WHERE template_property_id = _audittemplatepropertyid) > 0 THEN
			UPDATE audits_audittemplate_properties SET is_active = false, modified_at = NOW() WHERE company_id = _companyid AND id = _audittemplatepropertyid; 
			GET DIAGNOSTICS _rowcount = ROW_COUNT;
		ELSE
			DELETE FROM audits_audittemplate_properties WHERE company_id = _companyid AND id = _audittemplatepropertyid;
			GET DIAGNOSTICS _rowcount = ROW_COUNT;
		END IF;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for remove_checklisttemplate_property
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."remove_checklisttemplate_property"("_companyid" int4, "_checklisttemplatepropertyid" int4);
CREATE OR REPLACE FUNCTION "public"."remove_checklisttemplate_property"("_companyid" int4, "_checklisttemplatepropertyid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
		IF (SELECT COUNT(*)::int4 FROM checklists_properties WHERE template_property_id = _checklisttemplatepropertyid) > 0 THEN
			UPDATE checklists_checklisttemplate_properties SET is_active = false, modified_at = NOW() WHERE company_id = _companyid AND id = _checklisttemplatepropertyid; 
			GET DIAGNOSTICS _rowcount = ROW_COUNT;
		ELSE
			DELETE FROM checklists_checklisttemplate_properties WHERE company_id = _companyid AND id = _checklisttemplatepropertyid;
			GET DIAGNOSTICS _rowcount = ROW_COUNT;
		END IF;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for remove_profile_user_areas
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."remove_profile_user_areas"("_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."remove_profile_user_areas"("_userid" int4, "_areaid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	DELETE FROM profiles_user_areas WHERE area_id = _areaid AND user_id = _userid;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for remove_taskrecurrency_shift
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."remove_taskrecurrency_shift"("_companyid" int4, "_recurrencyid" int4, "_shiftid" int4);
CREATE OR REPLACE FUNCTION "public"."remove_taskrecurrency_shift"("_companyid" int4, "_recurrencyid" int4, "_shiftid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount_onetimeonly int4;
		_rowcount_shifts int4;
	BEGIN
	DELETE FROM tasks_taskrecurrency_one_time_shifts TTO WHERE TTO.taskrecurrency_id = _recurrencyid AND TTO.shift_id = _shiftid AND EXISTS (SELECT TTR.id FROM tasks_taskrecurrency TTR WHERE TTR.id = TTO.taskrecurrency_id AND TTR.company_id = _companyid);
	GET DIAGNOSTICS _rowcount_onetimeonly = ROW_COUNT;
	DELETE FROM tasks_taskrecurrency_shifts TTO WHERE TTO.taskrecurrency_id = _recurrencyid AND TTO.shift_id = _shiftid AND EXISTS (SELECT TTR.id FROM tasks_taskrecurrency TTR WHERE TTR.id = TTO.taskrecurrency_id AND TTR.company_id = _companyid);
	GET DIAGNOSTICS _rowcount_onetimeonly = ROW_COUNT;
	RETURN _rowcount_onetimeonly + _rowcount_shifts;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for remove_taskrecurrency_shifts
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."remove_taskrecurrency_shifts"("_companyid" int4, "_recurrencyid" int4);
CREATE OR REPLACE FUNCTION "public"."remove_taskrecurrency_shifts"("_companyid" int4, "_recurrencyid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount_onetimeonly int4;
		_rowcount_shifts int4;
	BEGIN
	DELETE FROM tasks_taskrecurrency_one_time_shifts TTO WHERE TTO.taskrecurrency_id = _recurrencyid AND EXISTS (SELECT TTR.id FROM tasks_taskrecurrency TTR WHERE TTR.id = TTO.taskrecurrency_id AND TTR.company_id = _companyid);
	GET DIAGNOSTICS _rowcount_onetimeonly = ROW_COUNT;
	DELETE FROM tasks_taskrecurrency_shifts TTO WHERE TTO.taskrecurrency_id = _recurrencyid AND EXISTS (SELECT TTR.id FROM tasks_taskrecurrency TTR WHERE TTR.id = TTO.taskrecurrency_id AND TTR.company_id = _companyid);
	GET DIAGNOSTICS _rowcount_shifts = ROW_COUNT;
	RETURN _rowcount_onetimeonly + _rowcount_shifts;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for remove_tasktemplate_property
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."remove_tasktemplate_property"("_companyid" int4, "_tasktemplatepropertyid" int4);
CREATE OR REPLACE FUNCTION "public"."remove_tasktemplate_property"("_companyid" int4, "_tasktemplatepropertyid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
		IF (SELECT COUNT(*)::int4 FROM tasks_properties WHERE template_property_id = _tasktemplatepropertyid) > 0 THEN
			UPDATE tasks_tasktemplate_properties SET is_active = false, modified_at = NOW() WHERE company_id = _companyid AND id = _tasktemplatepropertyid; 
			GET DIAGNOSTICS _rowcount = ROW_COUNT;
		ELSE
			DELETE FROM tasks_tasktemplate_properties WHERE company_id = _companyid AND id = _tasktemplatepropertyid;
			GET DIAGNOSTICS _rowcount = ROW_COUNT;
		END IF;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for report_audits_deviance_scores
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_audits_deviance_scores"("_companyid" int4, "_areaid" int4, "_timespanindays" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_audits_deviance_scores"("_companyid" int4, "_areaid" int4=0, "_timespanindays" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("nr_of_questions" int4, "impact_total" int4, "max_score" int4, "weight" numeric, "audit_template_id" int4, "audit_template_name" varchar, "task_template_id" int4, "task_template_name" varchar, "calculated_score" numeric, "action_count" int4, "action_count_done" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	S.nr_of_questions::int4, 
	S.impact_total::int4, 
	S.max_score::int4, 
	S.weight, 
	S.audit_template_id, 
	S.audit_template_name,
	S.task_template_id, 
	S.task_template_name,
	(S.max_score - ((S.impact_total / S.weight) / S.nr_of_questions))::numeric AS calculated_score,
	(SELECT Count(A.id)::int4 FROM actions_action A WHERE (A.task_template_id = S.task_template_id) AND A.is_active = true) AS action_count,
	(SELECT Count(A.id)::int4 FROM actions_action A WHERE (A.task_template_id = S.task_template_id) AND A.is_resolved = true AND A.is_active = true) AS action_count_done
	FROM  
	(
		SELECT COUNT(*) AS nr_of_questions, SUM(T.impact) AS impact_total, T.max_score, T.weight, T.audit_template_id, T.audit_template_name, T.task_template_id, T.task_template_name FROM (
			WITH RECURSIVE areas AS (
				SELECT
					a.id,a.name,a.parent_id, a.company_id
				FROM
					companies_area a
				WHERE
					a.id = _areaid
				UNION
				SELECT
					 e.id,e.name,e.parent_id, e.company_id
				FROM
					 companies_area e
				INNER JOIN areas s ON e.parent_id = s.id 
				WHERE e.is_active = true
			)	
			SELECT 
				TT.id, 
				TT.status, 
				TT.max_score, 
				TT.score, 
				TT.total_score, 
				TT.deviance,
				AA.max_task_score, 
				TTT.weight,
				(TT.deviance * TTT.weight)::int4 AS impact,
				AA.id	AS audit_template_id,
				AA.name AS audit_template_name,
				TTT.id AS task_template_id,
				TTT.name AS task_template_name
			FROM tasks_task TT
			INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id 
			INNER JOIN audits_audittemplate_tasks AAT ON AAT.tasktemplate_id = TTT.id
			INNER JOIN audits_audittemplate AA ON AA.id = AAT.audittemplate_id
			WHERE TT.company_id = _companyid 
			AND TT.is_active = true AND TTT.is_active = true AND AA.is_active = true AND TT.recurrency_id IS NULL
			AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.area_id) OR _areaid = 0) 
			AND (TT.created_at > (NOW()::date - CONCAT(_timespanindays,' days')::interval) OR _timespanindays = 0)
			AND (AA.id = _audittemplateid OR _audittemplateid = 0)
			ORDER BY AA.id DESC
		) AS T
		GROUP BY T.weight, T.audit_template_id, T.audit_template_name, T.task_template_id, T.task_template_name, T.max_score
		ORDER BY audit_template_name, impact_total
	) AS S
	WHERE S.weight IS NOT NULL AND S.nr_of_questions IS NOT NULL AND S.impact_total IS NOT NULL AND S.max_score IS NOT NULL
	ORDER BY calculated_score ASC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_audits_deviance_scores_new_calculation
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_audits_deviance_scores_new_calculation"("_companyid" int4, "_areaid" int4, "_timespanindays" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_audits_deviance_scores_new_calculation"("_companyid" int4, "_areaid" int4=0, "_timespanindays" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("nr_of_questions" int4, "audit_template_id" int4, "audit_template_name" varchar, "task_template_id" int4, "task_template_name" varchar, "score_high" int4, "score_low" int4, "score_range" int4, "deviance_nr_total" numeric, "deviance_percentage_avg" numeric, "action_count" int4, "action_count_done" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT COUNT(*)::int AS nr_of_questions,
				T.audit_template_id, 
				T.audit_template_name, 
				T.task_template_id, 
				T.task_template_name,
				T.score_high,
				T.score_low,
				T.score_range,
				SUM(T.deviance_task_score_nr) AS deviance_nr_total,
				AVG(T.deviance_task_score_percentage) AS deviance_percentage_avg,
				(SELECT Count(A.id)::int4 FROM actions_action A WHERE (A.task_template_id = T.task_template_id) AND A.is_active = true) AS action_count,
				(SELECT Count(A.id)::int4 FROM actions_action A WHERE (A.task_template_id = T.task_template_id) AND A.is_resolved = true AND A.is_active = true) AS action_count_done
	FROM (
				SELECT 
					*, 
					(R.score - R.score_low)::int AS rel_score,
					((R.score_high - R.score)::numeric / R.score_range::decimal)::numeric AS deviance_task_score_nr , 
					((R.score_high - R.score)::numeric / R.score_range::decimal)::numeric * 100 AS deviance_task_score_percentage  
					FROM (
						WITH RECURSIVE areas AS (
							SELECT
								a.id,a.name,a.parent_id, a.company_id
							FROM
								companies_area a
							WHERE
								a.id = _areaid
							UNION
							SELECT
								 e.id,e.name,e.parent_id, e.company_id
							FROM
								 companies_area e
							INNER JOIN areas s ON e.parent_id = s.id 
							WHERE e.is_active = true
						)	
						SELECT 
							TT.id, 
							AA.id	AS audit_template_id,
							AA.name AS audit_template_name,
							TTT.id AS task_template_id,
							TTT.name AS task_template_name,
							A.total_score,
							CASE WHEN TT.score IS NULL THEN
								TT.total_score
							ELSE 
								TT.score
							END AS score, 
							AA.max_task_score AS score_high, 
							AA.min_task_score AS score_low,
							(AA.max_task_score - AA.min_task_score)::int AS score_range
						FROM tasks_task TT
						INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id 
						INNER JOIN audits_audittemplate_tasks AATT ON AATT.tasktemplate_id = TTT.id
						INNER JOIN audits_audit_tasks AAT ON AAT.task_id = TT.id
						INNER JOIN audits_audittemplate AA ON AA.id = AATT.audittemplate_id
						INNER JOIN audits_audit A ON A.id = AAT.audit_id
						WHERE TT.company_id = _companyid 
						AND TT.is_active = true 
						AND TTT.is_active = true 
						AND AA.is_active = true 
						AND TT.recurrency_id IS NULL
						AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.area_id) OR _areaid = 0) 
						AND (TT.created_at > (NOW()::date - CONCAT(_timespanindays,' days')::interval) OR _timespanindays = 0)
						AND (AA.id = _audittemplateid OR _audittemplateid = 0)
						ORDER BY AA.id DESC
			) AS R WHERE (R.score_high - R.score) >= 0 AND R.score_range > 0
	) AS T
	GROUP BY T.audit_template_id, T.audit_template_name, T.task_template_id, T.task_template_name, T.score_high, T.score_low, T.score_range
	ORDER BY "deviance_percentage_avg" DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_audits_deviance_scores_other
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_audits_deviance_scores_other"("_companyid" int4, "_areaid" int4, "_timespanindays" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_audits_deviance_scores_other"("_companyid" int4, "_areaid" int4=0, "_timespanindays" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("count_nr" int4, "count_ok" int4, "count_notok" int4, "count_skipped" int4, "percentage_ok" numeric, "percentage_notok" numeric, "percentage_skipped" numeric, "parent_template_id" int4, "parent_template_name" varchar, "task_template_id" int4, "task_template_name" varchar, "action_count" int4, "action_count_done" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT
			T.count_nr, 
			T.count_ok,
			T.count_notok, 
			T.count_skipped, 
			(T.count_ok::numeric / T.count_nr::numeric * 100)::numeric AS percentage_ok, 
			(T.count_notok::numeric / T.count_nr::numeric * 100)::numeric AS percentage_notok, 
			(T.count_skipped::numeric / T.count_nr::numeric * 100)::numeric AS percentage_skipped,
			T.parent_template_id,
			T.parent_template_name,
			T.task_template_id,
			T.task_template_name,
			(SELECT Count(A.id)::int4 FROM actions_action A WHERE (A.task_template_id = T.task_template_id) AND A.is_active = true) AS action_count,
			(SELECT Count(A.id)::int4 FROM actions_action A WHERE (A.task_template_id = T.task_template_id) AND A.is_resolved = true AND A.is_active = true) AS action_count_done
	FROM (
		WITH RECURSIVE areas AS (
				SELECT
					a.id,a.name,a.parent_id, a.company_id
				FROM
					companies_area a
				WHERE
					a.id = _areaid
				UNION
				SELECT
					 e.id,e.name,e.parent_id, e.company_id
				FROM
					 companies_area e
				INNER JOIN areas s ON e.parent_id = s.id 
				WHERE e.is_active = true
		)	
		SELECT 
			COUNT(*)::int4 AS count_nr,
			SUM(CASE WHEN status = 'ok' THEN 1 ELSE 0 END)::int4 AS count_ok,
			SUM(CASE WHEN status = 'not ok' THEN 1 ELSE 0 END)::int4 AS count_notok,
			SUM(CASE WHEN status = 'skipped' THEN 1 ELSE 0 END)::int4 AS count_skipped,
			AA.id	AS parent_template_id,
			AA.name AS parent_template_name,
			TTT.id AS task_template_id,
			TTT.name AS task_template_name
		FROM tasks_task TT
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id 
		INNER JOIN audits_audittemplate_tasks AAT ON AAT.tasktemplate_id = TTT.id
		INNER JOIN audits_audittemplate AA ON AA.id = AAT.audittemplate_id
		WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.is_active = true AND AA.is_active = true AND TT.recurrency_id IS NULL
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.area_id) OR _areaid = 0) 
		AND (TT.created_at > (NOW()::date - CONCAT(_timespanindays,' days')::interval) OR _timespanindays = 0)
		AND (AA.id = _audittemplateid OR _audittemplateid = 0)
		GROUP BY AA.id, AA.name, TTT.id, TTT.name
		ORDER BY AA.id DESC
	) AS T
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_checklists_deviance_scores
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_checklists_deviance_scores"("_companyid" int4, "_areaid" int4, "_timespanindays" int4);
CREATE OR REPLACE FUNCTION "public"."report_checklists_deviance_scores"("_companyid" int4, "_areaid" int4=0, "_timespanindays" int4=0)
  RETURNS TABLE("count_nr" int4, "count_ok" int4, "count_notok" int4, "count_skipped" int4, "percentage_ok" numeric, "percentage_notok" numeric, "percentage_skipped" numeric, "parent_template_id" int4, "parent_template_name" varchar, "task_template_id" int4, "task_template_name" varchar, "action_count" int4, "action_count_done" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT
			T.count_nr, 
			T.count_ok,
			T.count_notok, 
			T.count_skipped, 
			(T.count_ok::numeric / T.count_nr::numeric * 100)::numeric AS percentage_ok, 
			(T.count_notok::numeric / T.count_nr::numeric * 100)::numeric AS percentage_notok, 
			(T.count_skipped::numeric / T.count_nr::numeric * 100)::numeric AS percentage_skipped,
			T.parent_template_id,
			T.parent_template_name,
			T.task_template_id,
			T.task_template_name,
			(SELECT Count(A.id)::int4 FROM actions_action A WHERE (A.task_template_id = T.task_template_id) AND A.is_active = true) AS action_count,
			(SELECT Count(A.id)::int4 FROM actions_action A WHERE (A.task_template_id = T.task_template_id) AND A.is_resolved = true AND A.is_active = true) AS action_count_done
	FROM (
		WITH RECURSIVE areas AS (
				SELECT
					a.id,a.name,a.parent_id, a.company_id
				FROM
					companies_area a
				WHERE
					a.id = _areaid
				UNION
				SELECT
					 e.id,e.name,e.parent_id, e.company_id
				FROM
					 companies_area e
				INNER JOIN areas s ON e.parent_id = s.id 
				WHERE e.is_active = true
		)	
		SELECT 
			COUNT(*)::int4 AS count_nr,
			SUM(CASE WHEN status = 'ok' THEN 1 ELSE 0 END)::int4 AS count_ok,
			SUM(CASE WHEN status = 'not ok' THEN 1 ELSE 0 END)::int4 AS count_notok,
			SUM(CASE WHEN status = 'skipped' THEN 1 ELSE 0 END)::int4 AS count_skipped,
			CC.id	AS parent_template_id,
			CC.name AS parent_template_name,
			TTT.id AS task_template_id,
			TTT.name AS task_template_name
		FROM tasks_task TT
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id 
		INNER JOIN checklists_checklisttemplate_tasks CCT ON CCT.tasktemplate_id = TTT.id
		INNER JOIN checklists_checklisttemplate CC ON CC.id = CCT.checklisttemplate_id
		WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.is_active = true AND CC.is_active = true AND TT.recurrency_id IS NULL
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CC.area_id) OR _areaid = 0) 
		AND (TT.created_at > (NOW()::date - CONCAT(_timespanindays,' days')::interval) OR _timespanindays = 0)
		GROUP BY CC.id, CC.name, TTT.id, TTT.name
		ORDER BY CC.id DESC
	) AS T
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_areas
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_areas"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_areas"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("nr" int4, "status" varchar) AS $BODY$BEGIN
   RETURN QUERY
   WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		), allowedtemplates AS (
				-- get all allowed templates for user for later joins if needed
				SELECT id FROM get_user_allowed_tasktemplateids(_companyid, _userid)
		), tasksshifttoday AS (
				-- get all shift and today tasks
				SELECT TT.template_id, TT.status, TTR.type FROM tasks_task TT
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
				INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
				WHERE TT.company_id = _companyid 
				AND ((_timestamp BETWEEN TT.start_date AND TT.end_date) OR TT.start_date =_timestamp::date OR TT.end_date = _timestamp::date)
				AND TTT.is_active = true AND TT.is_active = true
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
				AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
		), tasksweekmonth AS (
				-- get all week and month tasks
				SELECT DISTINCT ON (TT.template_id) TT.template_id ,TT.status, TTR.type FROM tasks_task TT
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
				INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
				WHERE TT.company_id = _companyid 
				AND (TT.due_at > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) AND TT.due_at < ((_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) + interval '7 day'))
				AND TTT.is_active = true AND TT.is_active = true
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
				AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
				ORDER BY TT.template_id, TT.start_at
		)
		SELECT SUM(T.nr_of_tasks)::int4 AS nr, T.status  FROM (
			SELECT count(*) AS nr_of_tasks, A.status, A.type FROM (
				SELECT * FROM tasksshifttoday TD WHERE (TD.type = 'shifts' OR TD.type='no recurrency')
			) AS A
			GROUP BY A.status, A.type
			UNION
			SELECT count(*) AS nr_of_tasks, B.status, B.type FROM (
				SELECT * FROM tasksweekmonth TW WHERE (TW.type = 'week' OR TW.type = 'month')
			) AS B
			GROUP BY B.status, B.type
		) AS T
		GROUP BY T.status;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_overdue_tasks
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_overdue_tasks"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_overdue_tasks"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int4, "status" varchar) AS $BODY$BEGIN
   RETURN QUERY
			WITH RECURSIVE areas AS (
				-- get all active areas with company for later joins if needed
				SELECT
					a.id,a.name,a.parent_id, a.company_id
				FROM
					companies_area a
				WHERE
					a.id = _areaid
				UNION
				SELECT
					 e.id,e.name,e.parent_id, e.company_id
				FROM
					 companies_area e
				INNER JOIN areas s ON e.parent_id = s.id 
				WHERE e.is_active = true
			), allowedtemplates AS (
				-- get all allowed templates for user for later joins if needed
				SELECT id FROM get_user_allowed_tasktemplateids(_companyid, _userid)
			), currentshifttimes AS (
				SELECT T."start_date", T."end_date", T."weekday" FROM get_shifts_datetimes_on_day_by_timestamp(_companyid, _timestamp) AS T
			)
			, excludedtemplates_for_today AS ( 
			  -- exclude all items that have a active task now
				SELECT DISTINCT TT.template_id FROM tasks_task TT 
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND  TTR.type <> 'shifts'
				WHERE _timestamp::timestamp BETWEEN TT.start_at AND TT.due_at AND TT.company_id = _companyid
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
			)
			, excludedtemplates_that_are_done AS (
				-- exclude all the items that the last task before the current date that have a filled in (skipped, ok, not ok) status. 
				SELECT T.template_id FROM (
					SELECT DISTINCT ON (TT.template_id) TT.template_id, TT.id, TT.status, TT.signed_at, TT.start_at, TT.due_at FROM tasks_task TT 
					INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
					INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND  TTR.type <> 'shifts'
					WHERE TT.company_id = _companyid AND TT.due_at < _timestamp::timestamp 
					AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
					ORDER BY TT.template_id, TT.start_at DESC, TT.start_date DESC, TT.end_date DESC
				) AS T
				WHERE T.signed_at IS NOT NULL 
			)
			, excludedtemplates_this_week AS (
					-- exclude all items that are month or week and have a still to fill in task this week where the due_at is not passed the timestamp
					-- week and month items that have a earlier item in the week but not this day are excluded from this list
					SELECT TT.template_id FROM tasks_task TT 
					INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
					INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
					WHERE TTT.company_id = _companyid AND (TTR.type = 'week' OR TTR.type = 'month')
					AND TT.start_date > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval)
					AND TT.end_date < ((_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) + interval '7 day')
					AND TT.due_at > _timestamp::timestamp
					AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
					AND NOT EXISTS ( 
							SELECT T.template_id FROM (
										SELECT DISTINCT ON (TT.template_id) TT.template_id, TT.id, TT.signed_at FROM tasks_task TT 
										INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
										INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id 
										WHERE TT.company_id = _companyid AND TT.due_at < _timestamp::timestamp AND TT.start_date > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval)
										AND (TTR.type = 'week' OR TTR.type = 'month')
										ORDER BY TT.template_id, TT.start_at DESC, TT.start_date DESC, TT.end_date DESC
							) AS T WHERE T.signed_at IS NULL
							  AND NOT EXISTS  ( 
								   SELECT excludedtemplates_for_today.template_id FROM excludedtemplates_for_today WHERE excludedtemplates_for_today.template_id = T.template_id
							) AND T.template_id = TT.template_id 
					)
			)
			SELECT COUNT(*)::int4 AS amount, C.status FROM (
				SELECT * FROM (
						SELECT DISTINCT ON (TT.template_id) TT.template_id, TT.id, TT.status --,  TT.start_at , TT.due_at, TT.start_date , TT.end_date, TTR.type, status, TTT.name 
						FROM tasks_task TT 
						INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
						INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true
						INNER JOIN companies_area CA ON CA.id = TTR.area_id AND CA.is_active = true
						WHERE TT.company_id = _companyid AND TTT.is_active = true AND TT.is_active = true AND TT.signed_at IS NULL AND (TTR.type <> 'shifts')
						AND (TTR.end_date > _timestamp::timestamp OR TTR.end_date IS NULL) -- exclude non accassable tasks
						AND TT.due_at < _timestamp::timestamp 
						AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
						AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
						AND NOT (EXISTS (SELECT excludedtemplates_that_are_done.template_id FROM excludedtemplates_that_are_done WHERE excludedtemplates_that_are_done.template_id = TT.template_id )) 
						AND NOT (EXISTS (SELECT excludedtemplates_this_week.template_id FROM excludedtemplates_this_week WHERE excludedtemplates_this_week.template_id = TT.template_id )) 
						AND NOT (EXISTS (SELECT excludedtemplates_for_today.template_id FROM excludedtemplates_for_today WHERE excludedtemplates_for_today.template_id = TT.template_id )) 
						AND TT.status = 'todo'
						ORDER BY TT.template_id, TT.start_at DESC, TT.start_date DESC, TT.end_date, TTT.name DESC
					) AS T
					UNION
					SELECT TT.template_id, TT.id, TT.status --, TT.start_at, TT.due_at, TT.start_date , TT.end_date, TTR.type, status, TTT.name 
					FROM tasks_task TT
					INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
					INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true
					INNER JOIN currentshifttimes ST ON ST.weekday = ST.weekday -- just join, contains 1 record. 
					WHERE TT.signed_at::timestamp BETWEEN get_timestamp_without_companytimezone(_companyid , ST.start_date::timestamp) AND get_timestamp_without_companytimezone(_companyid , ST.end_date::timestamp) 
					AND TT.signed_at::timestamp > get_timestamp_without_companytimezone(_companyid , TT.due_at::timestamp)
					AND TT.company_id = _companyid
					AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
			) AS C
			GROUP BY C.status
			;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_tasks
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_tasks"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_tasks"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int8, "status" varchar, "type" varchar) AS $BODY$BEGIN
   RETURN QUERY
   WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		), allowedtemplates AS (
				-- get all allowed templates for user for later joins if needed
				SELECT id FROM get_user_allowed_tasktemplateids(_companyid, _userid)
		), tasksshifttoday AS (
				-- get all shift and today tasks
				SELECT TT.template_id, TT.status, TTR.type FROM tasks_task TT
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
				INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
				WHERE TT.company_id = _companyid 
				AND ((_timestamp BETWEEN TT.start_date AND TT.end_date) OR TT.start_date =_timestamp::date OR TT.end_date = _timestamp::date)
				AND TTT.is_active = true AND TT.is_active = true
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
				AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
		), tasksweekmonth AS (
				-- get all week and month tasks
				SELECT DISTINCT ON (TT.template_id) TT.template_id ,TT.status, TTR.type FROM tasks_task TT
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
				INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
				WHERE TT.company_id = _companyid 
				AND (TT.due_at > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) AND TT.due_at < ((_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) + interval '7 day'))
				AND TTT.is_active = true AND TT.is_active = true
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
				AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
				ORDER BY TT.template_id, 	CASE WHEN TT.due_at::date = _timestamp::date AND TT.start_at::date > _timestamp::date AND TT.shift_id IS NULL THEN 0 
						 WHEN TT.due_at::date = _timestamp::date + '1 day'::interval AND TT.start_at::date = _timestamp::date AND TT.shift_id IS NULL THEN 1 
						 ELSE 2 END, TT.start_at
		)
		SELECT * FROM (
			SELECT count(*) AS nr_of_tasks, A.status, A.type FROM (
				SELECT * FROM tasksshifttoday TD WHERE (TD.type = 'shifts' OR TD.type='no recurrency')
			) AS A
			GROUP BY A.status, A.type
			UNION
			SELECT count(*) AS nr_of_tasks, B.status, B.type FROM (
				SELECT * FROM tasksweekmonth TW WHERE (TW.type = 'week' OR TW.type = 'month')
			) AS B
			GROUP BY B.status, B.type
		) AS T;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_tasks_last_week
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_tasks_last_week"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_tasks_last_week"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int8, "status" varchar) AS $BODY$BEGIN
   RETURN QUERY
   WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	, firstshift AS (
						SELECT *,
							 _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER-7 + '1 day'::interval + S.start AS start_date
						FROM (
						SELECT * FROM (
							SELECT 1::int AS type, CSA.id, CSA.start, CSA.end, CSA.weekday FROM companies_shift CSA
							WHERE CSA.company_id = _companyid AND CSA.is_active = true
							AND ((CSA.end < _timestamp::time AND CSA.start < _timestamp::time AND CSA.weekday = (EXTRACT(ISODOW from (_timestamp::date - '1 day'::interval))::int - 1)::int) 
										OR CSA.weekday = (EXTRACT(ISODOW from _timestamp::date)::int - 2)::int)  -- extract previous shift same day or last shift the day before.
							ORDER BY CSA.weekday DESC, CSA.start ASC LIMIT 1
						) AS A
					) AS S 
					ORDER BY S.type, S.weekday DESC, S.start ASC LIMIT 1
			), lastshift AS (
					SELECT *, 
						CASE WHEN S.end > S.start THEN
							 _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER + S.end 
						ELSE
							 _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER + '1 day'::interval + S.end
						END AS end_date
						FROM (
						SELECT * FROM (
							SELECT 1::int AS type, CSA.id, CSA.start, CSA.end, CSA.weekday FROM companies_shift CSA
							WHERE CSA.company_id = _companyid AND CSA.is_active = true
							AND ((CSA.end < _timestamp::time AND CSA.start < _timestamp::time AND CSA.weekday = (EXTRACT(ISODOW from (_timestamp::date - '1 day'::interval))::int - 1)::int) 
										OR CSA.weekday = (EXTRACT(ISODOW from _timestamp::date)::int - 2)::int)  -- extract previous shift same day or last shift the day before.
							ORDER BY CSA.weekday DESC, CSA.start DESC LIMIT 1
						) AS A
					) AS S 
					LIMIT 1
			),allowedtemplates AS (
				-- get all allowed templates for user for later joins if needed
				SELECT id FROM get_user_allowed_tasktemplateids(_companyid, _userid)
			)		
		SELECT count(*) AS nr_of_tasks, TT.status FROM tasks_task TT
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
		INNER JOIN firstshift F ON F.id = F.id -- join on it self, for getting data
		INNER JOIN lastshift L ON L.id = L.id -- join on it self, for getting data
		WHERE TT.company_id = _companyid  
				AND TTT.is_active = true AND TT.is_active = true
				AND ((TT.start_at >= F.start_date AND TT.due_at <= L.end_date) 
					OR (TT.signed_at::timestamp BETWEEN get_timestamp_without_companytimezone(_companyid , F.start_date::timestamp) AND get_timestamp_without_companytimezone(_companyid , L.end_date::timestamp))
					OR (TT.due_at BETWEEN F.start_date AND L.end_date)
				)
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
				AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
		GROUP BY TT.status; 
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_tasks_month
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_tasks_month"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_tasks_month"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int8, "status" varchar) AS $BODY$BEGIN
   RETURN QUERY
   WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	, allowedtemplates AS (
				-- get all allowed templates for user for later joins if needed
				SELECT id FROM get_user_allowed_tasktemplateids(_companyid, _userid)
			)		
		SELECT count(*) AS nr_of_tasks, TT.status FROM tasks_task TT
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
		WHERE TT.company_id = _companyid  
				AND TTT.is_active = true AND TT.is_active = true
				AND (TTR.type = 'month')
				AND TT.due_at > _timestamp::timestamp
				AND TT.due_at > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval)
				AND TT.due_at < ((_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) + interval '7 day')
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
				AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
		GROUP BY TT.status; 
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_tasks_overdue
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_tasks_overdue"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_tasks_overdue"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int4) AS $BODY$BEGIN
   RETURN QUERY
			WITH RECURSIVE areas AS (
				-- get all active areas with company for later joins if needed
				SELECT
					a.id,a.name,a.parent_id, a.company_id
				FROM
					companies_area a
				WHERE
					a.id = _areaid
				UNION
				SELECT
					 e.id,e.name,e.parent_id, e.company_id
				FROM
					 companies_area e
				INNER JOIN areas s ON e.parent_id = s.id 
				WHERE e.is_active = true
			), allowedtemplates AS (
				-- get all allowed templates for user for later joins if needed
				SELECT id FROM get_user_allowed_tasktemplateids(_companyid, _userid)
			), currentshifttimes AS (
				SELECT T."start_date", T."end_date", T."weekday" FROM get_shifts_datetimes_on_day_by_timestamp(_companyid, _timestamp) AS T
			)
			, excludedtemplates_for_today AS ( 
			  -- exclude all items that have a active task now
				SELECT DISTINCT TT.template_id FROM tasks_task TT 
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND  TTR.type <> 'shifts'
				WHERE _timestamp::timestamp BETWEEN TT.start_at AND TT.due_at AND TT.company_id = _companyid
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
			)
			, excludedtemplates_that_are_done AS (
				-- exclude all the items that the last task before the current date that have a filled in (skipped, ok, not ok) status. 
				SELECT T.template_id FROM (
					SELECT DISTINCT ON (TT.template_id) TT.template_id, TT.id, TT.status, TT.signed_at, TT.start_at, TT.due_at FROM tasks_task TT 
					INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
					INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND  TTR.type <> 'shifts'
					WHERE TT.company_id = _companyid AND TT.due_at < _timestamp::timestamp 
					AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
					ORDER BY TT.template_id, TT.start_at DESC, TT.start_date DESC, TT.end_date DESC
				) AS T
				WHERE T.signed_at IS NOT NULL 
			)
			, excludedtemplates_this_week AS (
					-- exclude all items that are month or week and have a still to fill in task this week where the due_at is not passed the timestamp
					-- week and month items that have a earlier item in the week but not this day are excluded from this list
					SELECT TT.template_id FROM tasks_task TT 
					INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
					INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
					WHERE TTT.company_id = _companyid AND (TTR.type = 'week' OR TTR.type = 'month')
					AND TT.start_date > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval)
					AND TT.end_date < ((_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) + interval '7 day')
					AND TT.due_at > _timestamp::timestamp
					AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
					AND NOT EXISTS ( 
							SELECT T.template_id FROM (
										SELECT DISTINCT ON (TT.template_id) TT.template_id, TT.id, TT.signed_at FROM tasks_task TT 
										INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
										INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id 
										WHERE TT.company_id = _companyid AND TT.due_at < _timestamp::timestamp AND TT.start_date > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval)
										AND (TTR.type = 'week' OR TTR.type = 'month')
										ORDER BY TT.template_id, TT.start_at DESC, TT.start_date DESC, TT.end_date DESC
							) AS T WHERE T.signed_at IS NULL
							  AND NOT EXISTS  ( 
								   SELECT excludedtemplates_for_today.template_id FROM excludedtemplates_for_today WHERE excludedtemplates_for_today.template_id = T.template_id
							) AND T.template_id = TT.template_id 
					)
			)
			SELECT COUNT(*)::int4 AS amount FROM (
				SELECT * FROM (
						SELECT DISTINCT ON (TT.template_id) TT.template_id, TT.id --,  TT.start_at , TT.due_at, TT.start_date , TT.end_date, TTR.type, status, TTT.name 
						FROM tasks_task TT 
						INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
						INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true
						INNER JOIN companies_area CA ON CA.id = TTR.area_id AND CA.is_active = true
						WHERE TT.company_id = _companyid AND TTT.is_active = true AND TT.is_active = true AND TT.signed_at IS NULL AND (TTR.type <> 'shifts')
						AND (TTR.end_date > _timestamp::timestamp OR TTR.end_date IS NULL) -- exclude non accassable tasks
						AND TT.due_at < _timestamp::timestamp 
						AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
						AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
						AND NOT (EXISTS (SELECT excludedtemplates_that_are_done.template_id FROM excludedtemplates_that_are_done WHERE excludedtemplates_that_are_done.template_id = TT.template_id )) 
						AND NOT (EXISTS (SELECT excludedtemplates_this_week.template_id FROM excludedtemplates_this_week WHERE excludedtemplates_this_week.template_id = TT.template_id )) 
						AND NOT (EXISTS (SELECT excludedtemplates_for_today.template_id FROM excludedtemplates_for_today WHERE excludedtemplates_for_today.template_id = TT.template_id )) 
						AND TT.status = 'todo'
						ORDER BY TT.template_id, TT.start_at DESC, TT.start_date DESC, TT.end_date, TTT.name DESC
					) AS T
					UNION
					SELECT TT.template_id, TT.id --, TT.start_at, TT.due_at, TT.start_date , TT.end_date, TTR.type, status, TTT.name 
					FROM tasks_task TT
					INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true 
					INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true
					INNER JOIN currentshifttimes ST ON ST.weekday = ST.weekday -- just join, contains 1 record. 
					WHERE TT.signed_at::timestamp BETWEEN get_timestamp_without_companytimezone(_companyid , ST.start_date::timestamp) AND get_timestamp_without_companytimezone(_companyid , ST.end_date::timestamp) 
					AND TT.signed_at::timestamp > get_timestamp_without_companytimezone(_companyid , TT.due_at::timestamp)
					AND TT.company_id = _companyid
					AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
			) AS C
			;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_tasks_overview_current
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_tasks_overview_current"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_tasks_overview_current"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int8, "status" varchar, "type" varchar, "sourcetype" varchar) AS $BODY$BEGIN
   RETURN QUERY
     	SELECT * FROM (
			SELECT count(*) AS nr_of_tasks, TT.status, TTR.type, 'task_overview_today'::varchar AS source  FROM tasks_task TT
			INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
			INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
			WHERE TT.company_id = _companyid AND ((_timestamp::timestamp BETWEEN TT.start_at AND TT.due_at AND TT.shift_id IS NOT NULL) 
			OR (TTR.type <> 'shifts'
				 AND  TT.start_at >= CASE WHEN (SELECT (_timestamp::timestamp::time <= first_start)::bool FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp::timestamp)) THEN
													((_timestamp::timestamp::date - '1 day'::interval) + (SELECT last_start FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp::timestamp)))::timestamp
											 ELSE 
													(_timestamp::timestamp::date + (SELECT first_start FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp::timestamp)))::timestamp
											 END
				 AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp::timestamp)) THEN
													((_timestamp::timestamp::date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp::timestamp)))::timestamp
											 ELSE 
													(_timestamp::timestamp::date + (SELECT last_end FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp::timestamp)))::timestamp
											 END								 
			))
			AND TT.company_id = _companyid 
			AND TTT.is_active = true AND TT.is_active = true
			AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id)  OR _areaid= 0) 
			AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
			GROUP BY TT.status, TTR.type
		) AS A1
		UNION
		SELECT * FROM (
			SELECT count(*) AS nr_of_tasks, TT.status, TTR.type, 'task_overview_this_shift'::varchar AS source FROM tasks_task TT
			INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
			INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id AND TTR.type = 'shifts'
			WHERE _timestamp::timestamp BETWEEN TT.start_at AND TT.due_at AND TT.company_id = _companyid AND TT.shift_id IS NOT NULL
			AND TTT.is_active = true AND TT.is_active = true AND TTT.is_active = true
			AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id) OR _areaid= 0) 
			AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
			GROUP BY TT.status, TTR.type
		) AS A2
		;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_tasks_overview_past
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_tasks_overview_past"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_tasks_overview_past"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int8, "status" varchar, "pasttype" varchar) AS $BODY$
	DECLARE 
	_as_start_date timestamp;
	_as_start_date_wt timestamp;
	_as_end_date timestamp;
	_as_end_date_wt timestamp;
	_ys_start_date timestamp;
	_ys_start_date_wt timestamp;
	_ys_end_date timestamp;
	_ys_end_date_wt timestamp;
	_fs_start_date timestamp;
	_fs_start_date_wt timestamp;
	_fs_end_date timestamp;
	_fs_end_date_wt timestamp;
	_ls_start_date timestamp;
	_ls_start_date_wt timestamp;
	_ls_end_date timestamp;
	_ls_end_date_wt timestamp;
	BEGIN
		SELECT S.start_date, S.end_date, 
					 get_timestamp_without_companytimezone(_companyid ,S.start_date::timestamp) AS start_date_wt, 
					 get_timestamp_without_companytimezone(_companyid ,S.end_date::timestamp) AS end_date_wt 
					 INTO _as_start_date, _as_end_date, _as_start_date_wt, _as_end_date_wt
		FROM get_shift_previous_by_timestamp(_companyid, _timestamp::timestamp) S;
	
		SELECT SY.start_date, SY.end_date, 
					 get_timestamp_without_companytimezone(_companyid ,SY.start_date::timestamp) AS start_date_wt, 
					 get_timestamp_without_companytimezone(_companyid ,SY.end_date::timestamp) AS end_date_wt 
					 INTO _ys_start_date, _ys_end_date, _ys_start_date_wt, _ys_end_date_wt FROM (
		SELECT MIN(S.start_date) AS start_date, MAX(S.end_date) AS end_date, S.day_date, S.weekday FROM get_shifts_past_day_by_timestamp(_companyid::int, _timestamp::timestamp) AS S
					GROUP BY S.weekday,S.day_date
					ORDER BY S.day_date DESC
					LIMIT 1
		) AS SY;
		-- first of week
		SELECT SF.start_date, 
					 get_timestamp_without_companytimezone(_companyid ,SF.start_date::timestamp) AS start_date_wt
					 INTO _fs_start_date, _fs_start_date_wt
		FROM (
				SELECT *,
					 _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER-7 + '1 day'::interval + S.start AS start_date
				FROM (
					SELECT first_shift_id AS id, first_start AS start FROM get_shift_first_last_on_day_by_timestamp(_companyid,  _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER-7 + '1 day'::interval) 
				) AS S 
		) SF;
		-- last of week
		SELECT SL.end_date, 
					 get_timestamp_without_companytimezone(_companyid ,SL.end_date::timestamp) AS end_date_wt
					 INTO _ls_end_date, _ls_end_date_wt
		FROM (
			SELECT *, 
				CASE WHEN S.end > S.start THEN
					 _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER + S.end 
				ELSE
					 _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER + '1 day'::interval + S.end
				END AS end_date
				FROM (
					SELECT last_shift_id AS id, last_end AS end, first_start AS start FROM get_shift_first_last_on_day_by_timestamp(_companyid,  _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER-7 + '7 day'::interval) 
			) AS S 
		) SL;
		
		IF _fs_start_date IS NULL AND _ls_end_date IS NULL THEN
				_fs_start_date = _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER-7 + '1 day'::interval;
				_ls_end_date = _timestamp::DATE-EXTRACT(ISODOW FROM _timestamp::DATE)::INTEGER-7 + '8 day'::interval;
				_fs_start_date_wt = get_timestamp_without_companytimezone(_companyid , _fs_start_date::timestamp);  
				_ls_end_date_wt = get_timestamp_without_companytimezone(_companyid , _ls_end_date::timestamp);  
		END IF;
		IF _fs_start_date IS NOT NULL AND _ls_end_date IS NULL THEN
				_ls_end_date = _fs_start_date + '7 day'::interval;
				_ls_end_date_wt = get_timestamp_without_companytimezone(_companyid , _ls_end_date::timestamp); 
		END IF; 
		IF _fs_start_date IS NULL AND _ls_end_date IS NOT NULL THEN
				_fs_start_date = _ls_end_date - '7 day'::interval;
				_fs_start_date_wt = get_timestamp_without_companytimezone(_companyid , _fs_start_date::timestamp); 
		END IF;
		
		IF _ys_start_date IS NULL AND _ys_end_date IS NULL THEN
				_ys_start_date = (_timestamp - '1 day'::interval)::date::timestamp; 
				_ys_end_date = (_timestamp)::date::timestamp; 
				_ys_start_date_wt = get_timestamp_without_companytimezone(_companyid , _ys_start_date::timestamp);  
				_ys_end_date_wt = get_timestamp_without_companytimezone(_companyid , _ys_end_date::timestamp);  
		END IF;
		IF _ys_start_date IS NOT NULL AND _ys_end_date IS NULL THEN
				_ys_end_date = (_timestamp)::date::timestamp; 
				_ys_end_date_wt = get_timestamp_without_companytimezone(_companyid , _ys_end_date::timestamp);  
		END IF; 
		IF _ys_start_date IS NULL AND _ys_end_date IS NOT NULL THEN
				_ys_start_date = (_timestamp - '1 day'::interval)::date::timestamp; 
				_ys_start_date_wt = get_timestamp_without_companytimezone(_companyid , _ys_start_date::timestamp);  
		END IF;

   RETURN QUERY
		-- previous shift
		SELECT * FROM (
			SELECT count(*) AS nr_of_tasks, T.status, 'task_overview_previous_shift'::varchar AS source FROM (
				SELECT TT.id, TT.status, TTR.type, TTR.area_id, TT.template_id FROM tasks_task TT
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.is_active = true
				INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id AND TTR.type = 'shifts' AND TTR.is_active = true
				WHERE TT.company_id = _companyid AND TT.is_active = true 
					AND (TT.start_at = _as_start_date AND TT.due_at = _as_end_date) 
					AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id) OR _areaid= 0) 
					AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
				UNION
				SELECT TT.id, TT.status, TTR.type, TTR.area_id, TT.template_id FROM tasks_task TT
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
				INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id AND TTR.type <> 'shifts' AND TTR.is_active = true
				WHERE TT.company_id = _companyid 
					AND TTT.is_active = true AND TT.is_active = true AND TTT.is_active = true
					AND ((TT.signed_at::timestamp BETWEEN _as_start_date_wt AND _as_end_date_wt)
					 OR (TT.due_at > _as_start_date AND TT.due_at <= _as_end_date))
					AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id)  OR _areaid= 0) 
					AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
			) AS T 
			GROUP BY T.status
		) AS A1
		UNION
		-- yesterday
		SELECT * FROM (
			SELECT count(*) AS nr_of_tasks, TT.status, 'task_overview_yesterday'::varchar AS source FROM tasks_task TT
			INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
			INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id AND TTR.is_active = true
			WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.is_active = true
					AND ((TT.start_at >= _ys_start_date AND TT.due_at <= _ys_end_date) 
						OR (TT.signed_at::timestamp BETWEEN _ys_start_date_wt AND _ys_end_date_wt)
						OR (TT.due_at > _ys_start_date AND TT.due_at <= _ys_end_date)
					)
					AND TTT.is_active = true AND TT.is_active = true
					AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id)  OR _areaid= 0) 
					AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
			GROUP BY TT.status
		) AS A2
		UNION 
		-- last week
		SELECT * FROM (
			SELECT count(*) AS nr_of_tasks, TT.status, 'task_overview_lastweek'::varchar AS source 
			FROM tasks_task TT
			INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
			INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id
			WHERE TT.company_id = _companyid 
			AND TTT.is_active = true AND TT.is_active = true AND TTT.is_active = true
			AND ((TT.start_at >= _fs_start_date AND TT.due_at <= _ls_end_date) 
							OR (TT.signed_at::timestamp BETWEEN _fs_start_date_wt AND _ls_end_date_wt)
							OR (TT.due_at > _fs_start_date::timestamp AND TT.due_at <= _ls_end_date::timestamp)
						)
					AND (EXISTS (SELECT areas.id FROM get_area_nodes_from_root_to_leaf(_companyid, _areaid) areas WHERE areas.id = TTR.area_id)  OR _areaid= 0) 
					AND (EXISTS (SELECT allowedtemplates.id FROM get_user_allowed_tasktemplateids(_companyid, _userid) allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
				GROUP BY TT.status
		) AS A3;
		
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_tasks_previous_shift
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_tasks_previous_shift"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_tasks_previous_shift"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int8, "status" varchar) AS $BODY$BEGIN
   RETURN QUERY
   WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		), availableshift AS (
					SELECT *, 
						CASE WHEN S.end > S.start THEN -- starts on the current day
							_timestamp::date + S.start 
						ELSE
							(_timestamp::date - '1 day'::interval) + S.start -- starts on the previous day
						END AS start_date, 
						_timestamp::date + S.end AS end_date 
						FROM (
						SELECT * FROM (
							SELECT 1::int AS type, CSA.id, CSA.start, CSA.end, CSA.weekday FROM companies_shift CSA
							WHERE CSA.company_id = _companyid AND CSA.is_active = true
							AND ((CSA.end < _timestamp::time AND CSA.start < _timestamp::time AND CSA.weekday = (EXTRACT(ISODOW from _timestamp::date)::int - 1)::int) 
										OR CSA.weekday = (EXTRACT(ISODOW from _timestamp::date)::int - 2)::int)  -- extract previous shift same day or last shift the day before.
							ORDER BY CSA.weekday DESC, CSA.start DESC LIMIT 1
						) AS A
						UNION 
						SELECT * FROM (
							SELECT 2::int AS type, CSA.id, CSA.start, CSA.end, CSA.weekday FROM companies_shift CSA
							WHERE CSA.company_id = _companyid AND CSA.is_active = true  -- extract last shift from 
							ORDER BY CSA.weekday DESC, CSA.start DESC LIMIT 1
						) AS B
					) AS S 
					ORDER BY S.type, S.weekday DESC, S.start LIMIT 1
			), allowedtemplates AS (
			-- get all allowed templates for user for later joins if needed
			SELECT id FROM get_user_allowed_tasktemplateids(_companyid, _userid)
		)		
		
		SELECT count(*) AS nr_of_tasks, T.status FROM (
			SELECT TT.id, TT.status, TTR.type, TTR.area_id, TT.template_id FROM tasks_task TT
			INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
			INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id AND TTR.type = 'shifts'
			INNER JOIN availableshift A ON A.id = TT.shift_id -- join on TT.shift id for getting shift only. 
			WHERE TT.company_id = _companyid AND TT.is_active = true 
				AND ((_timestamp BETWEEN TT.start_date AND TT.end_date) OR TT.start_date = _timestamp::date OR TT.end_date = _timestamp::date) 
			UNION
			SELECT TT.id, TT.status, TTR.type, TTR.area_id, TT.template_id FROM tasks_task TT
			INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
			INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id AND TTR.type <> 'shifts'
			INNER JOIN availableshift A ON A.id = A.id -- join on self, just need the table data should contain 1 record. 
			WHERE TT.company_id = _companyid 
				AND TTT.is_active = true AND TT.is_active = true AND TTT.is_active = true
				AND (TT.signed_at::timestamp BETWEEN get_timestamp_without_companytimezone(_companyid , A.start_date::timestamp) AND get_timestamp_without_companytimezone(_companyid, A.end_date::timestamp) OR TT.due_at BETWEEN A.start_date AND A.end_date)
		) AS T 
		WHERE (EXISTS (SELECT areas.id FROM areas WHERE areas.id = T.area_id) OR _areaid = 0) 
		AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = T.template_id) OR _userid = 0) 
		GROUP BY T.status; 
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_tasks_test
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_tasks_test"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_tasks_test"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int8, "status" varchar, "type" varchar) AS $BODY$BEGIN
   RETURN QUERY
   WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		), allowedtemplates AS (
				-- get all allowed templates for user for later joins if needed
				SELECT id FROM get_user_allowed_tasktemplateids(_companyid, _userid)
			)	
			SELECT * FROM (
				SELECT count(*) AS nr_of_tasks, A.status, A.type FROM (
					SELECT TT.template_id, TT.status, TTR.type FROM tasks_task TT
					INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
					INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
					WHERE TT.company_id = _companyid 
					AND ((_timestamp BETWEEN TT.start_date AND TT.end_date) OR TT.start_date =_timestamp::date OR TT.end_date = _timestamp::date)
					AND TTT.is_active = true AND TT.is_active = true
					AND (TTR.type = 'shifts' OR TTR.type = 'no recurrency')
					AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
					AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
				) AS A
				GROUP BY A.status, A.type
				UNION
				SELECT count(*) AS nr_of_tasks, B.status, B.type FROM (
					SELECT DISTINCT ON (TT.template_id) TT.template_id ,TT.status, TTR.type FROM tasks_task TT
					INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
					INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
					WHERE TT.company_id = _companyid 
					AND ((TTR.type = 'week' OR TTR.type = 'month') AND TT.due_at > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) AND TT.due_at < ((_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) + interval '7 day'))
					AND TTT.is_active = true AND TT.is_active = true
					AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
					AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
					ORDER BY TT.template_id, TT.start_at
				) AS B
				GROUP BY B.status, B.type
			) AS T;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_tasks_test_performance
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_tasks_test_performance"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_tasks_test_performance"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int8, "status" varchar, "type" varchar) AS $BODY$BEGIN
   RETURN QUERY
   WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		), allowedtemplates AS (
				-- get all allowed templates for user for later joins if needed
				SELECT id FROM get_user_allowed_tasktemplateids(_companyid, _userid)
		), tasksshifttoday AS (
				SELECT TT.template_id, TT.status, TTR.type FROM tasks_task TT
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
				INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
				WHERE TT.company_id = _companyid 
				AND ((_timestamp BETWEEN TT.start_date AND TT.end_date) OR TT.start_date =_timestamp::date OR TT.end_date = _timestamp::date)
				AND TTT.is_active = true AND TT.is_active = true
				--AND TTR.type = 'shifts'
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
				AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
		), tasksweekmonth AS (
					SELECT DISTINCT ON (TT.template_id) TT.template_id ,TT.status, TTR.type FROM tasks_task TT
					INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
					INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
					WHERE TT.company_id = _companyid 
					AND (TT.due_at > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) AND TT.due_at < ((_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) + interval '7 day'))
					AND TTT.is_active = true AND TT.is_active = true
					AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
					AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
					ORDER BY TT.template_id, TT.start_at
		)
		SELECT * FROM (
			SELECT count(*) AS nr_of_tasks, A.status, A.type FROM (
				SELECT * FROM tasksshifttoday TD WHERE (TD.type = 'shifts' OR TD.type='no recurrency')
			) AS A
			GROUP BY A.status, A.type
			UNION
			SELECT count(*) AS nr_of_tasks, B.status, B.type FROM (
				SELECT * FROM tasksweekmonth TW WHERE TW.type = 'week' OR TW.type = 'month'
			) AS B
			GROUP BY B.status, B.type
		) AS T;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_tasks_this_shift
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_tasks_this_shift"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_tasks_this_shift"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int8, "status" varchar, "type" varchar) AS $BODY$BEGIN
   RETURN QUERY
   WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		), allowedtemplates AS (
			-- get all allowed templates for user for later joins if needed
			SELECT id FROM get_user_allowed_tasktemplateids(_companyid, _userid)
		)			
		SELECT count(*) AS nr_of_tasks, TT.status, TTR.type FROM tasks_task TT
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id AND TTR.type = 'shifts'
		WHERE _timestamp BETWEEN TT.start_at AND TT.due_at AND TT.company_id = _companyid AND TT.shift_id IS NOT NULL
		AND TTT.is_active = true AND TT.is_active = true AND TTT.is_active = true
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
		AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
		GROUP BY TT.status, TTR.type; 
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_tasks_today
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_tasks_today"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_tasks_today"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int8, "status" varchar, "type" varchar) AS $BODY$BEGIN
   RETURN QUERY
   WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		), allowedtemplates AS (
				-- get all allowed templates for user for later joins if needed
				SELECT id FROM get_user_allowed_tasktemplateids(_companyid, _userid)
			)			
		SELECT count(*) AS nr_of_tasks, TT.status, TTR.type FROM tasks_task TT
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
		WHERE TT.company_id = _companyid AND ((_timestamp BETWEEN TT.start_at AND TT.due_at AND TT.shift_id IS NOT NULL) 
		OR (TTR.type <> 'shifts'
			 AND  TT.start_at >= CASE WHEN (SELECT (_timestamp::time <= first_start)::bool FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)) THEN
												((_timestamp::date - '1 day'::interval) + (SELECT last_start FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)))::timestamp
										 ELSE 
												(_timestamp::date + (SELECT first_start FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)))::timestamp
										 END
			 AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)) THEN
												((_timestamp::date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)))::timestamp
										 ELSE 
												(_timestamp::date + (SELECT last_end FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)))::timestamp
										 END								 
		))
		AND TT.company_id = _companyid 
		AND TTT.is_active = true AND TT.is_active = true
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
		AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
		GROUP BY TT.status, TTR.type; 
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_tasks_week
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_tasks_week"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_tasks_week"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int8, "status" varchar, "type" varchar) AS $BODY$BEGIN
   RETURN QUERY
   WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	, allowedtemplates AS (
				-- get all allowed templates for user for later joins if needed
				SELECT id FROM get_user_allowed_tasktemplateids(_companyid, _userid)
			)		
		SELECT count(*) AS nr_of_tasks, TT.status, TTR.type FROM tasks_task TT
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
		WHERE TT.company_id = _companyid  
				AND TTT.is_active = true AND TT.is_active = true
				AND (TTR.type = 'week')
				AND TT.due_at > _timestamp::timestamp
				AND TT.due_at > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval)
				AND TT.due_at < ((_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) + interval '7 day')
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
				AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
		GROUP BY TT.status, TTR.type; 
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_tasks_weekmonth
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_tasks_weekmonth"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_tasks_weekmonth"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int8, "status" varchar, "type" varchar) AS $BODY$BEGIN
   RETURN QUERY
   WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	, allowedtemplates AS (
				-- get all allowed templates for user for later joins if needed
			SELECT id FROM get_user_allowed_tasktemplateids(_companyid, _userid)
		)		
		SELECT COUNT(*), T.status, T.type FROM (
			SELECT DISTINCT ON (TT.template_id) TT.template_id, TT.status, TTR.type FROM tasks_task TT
			INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
			INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
			WHERE TT.company_id = _companyid  
					AND TTT.is_active = true AND TT.is_active = true
					AND (TTR.type = 'week' OR TTR.type = 'month')
					AND TT.due_at > _timestamp::timestamp
					AND TT.due_at > (_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval)
					AND TT.due_at < ((_timestamp::date - CONCAT((EXTRACT(ISODOW FROM _timestamp::timestamp) -1),' day')::interval) + interval '7 day')
					AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
					AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
			ORDER BY TT.template_id, TT.start_at
		) AS T
		GROUP BY T.status, T.type; 
		
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_get_tasks_yesterday
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_get_tasks_yesterday"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."report_get_tasks_yesterday"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0, "_userid" int4=0)
  RETURNS TABLE("amount" int8, "status" varchar) AS $BODY$BEGIN
   RETURN QUERY
   WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		), firstshift AS (
						SELECT *, 
						CASE WHEN S.start <= _timestamp::time THEN
							 _timestamp::date - '1 day'::interval + S.start -- current time belongs to shift of this day so get date 1 days before current for yesterday 
						ELSE
							 _timestamp::date - '2 day'::interval + S.start -- current time belongs to previous shift of previous day so get date 2 days before current for yesterday 
						END AS start_date
						FROM (
						SELECT * FROM (
							SELECT 1::int AS type, CSA.id, CSA.start, CSA.end, CSA.weekday FROM companies_shift CSA
							WHERE CSA.company_id = _companyid AND CSA.is_active = true
							AND ((CSA.end < _timestamp::time AND CSA.start < _timestamp::time AND CSA.weekday = (EXTRACT(ISODOW from (_timestamp::date - '1 day'::interval))::int - 1)::int) 
										OR CSA.weekday = (EXTRACT(ISODOW from _timestamp::date)::int - 2)::int)  -- extract previous shift same day or last shift the day before.
							ORDER BY CSA.weekday DESC, CSA.start ASC LIMIT 1
						) AS A
					) AS S 
					ORDER BY S.type, S.weekday DESC, S.start ASC LIMIT 1
			), lastshift AS (
					SELECT *, 
						CASE WHEN S.end <= _timestamp::time THEN
							 _timestamp::date + S.end 
						ELSE
							 _timestamp::date - '1 day'::interval + S.end 
						END AS end_date
						FROM (
						SELECT * FROM (
							SELECT 1::int AS type, CSA.id, CSA.start, CSA.end, CSA.weekday FROM companies_shift CSA
							WHERE CSA.company_id = _companyid AND CSA.is_active = true
							AND ((CSA.end < _timestamp::time AND CSA.start < _timestamp::time AND CSA.weekday = (EXTRACT(ISODOW from (_timestamp::date - '1 day'::interval))::int - 1)::int) 
										OR CSA.weekday = (EXTRACT(ISODOW from _timestamp::date)::int - 2)::int)  -- extract previous shift same day or last shift the day before.
							ORDER BY CSA.weekday DESC, CSA.start DESC LIMIT 1
						) AS A
					) AS S 
					LIMIT 1
			), allowedtemplates AS (
			-- get all allowed templates for user for later joins if needed
			SELECT id FROM get_user_allowed_tasktemplateids(_companyid, _userid)
		)			
		SELECT count(*) AS nr_of_tasks, TT.status FROM tasks_task TT
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
		INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id --AND TTR.type = 'no recurrency'
		INNER JOIN firstshift F ON F.id = F.id -- join on it self, for getting data
		INNER JOIN lastshift L ON L.id = L.id -- join on it self, for getting data
		WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.is_active = true
				AND ((TT.start_at >= F.start_date AND TT.due_at <= L.end_date) 
					OR (TT.signed_at::timestamp BETWEEN get_timestamp_without_companytimezone(_companyid, F.start_date::timestamp) AND get_timestamp_without_companytimezone(_companyid, L.end_date::timestamp))
					OR (TT.due_at BETWEEN F.start_date AND L.end_date)
				)
			  AND TTT.is_active = true AND TT.is_active = true
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
				AND (EXISTS (SELECT allowedtemplates.id FROM allowedtemplates WHERE allowedtemplates.id = TTT.id) OR _userid = 0) 
		GROUP BY TT.status; 
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount"("_companyid" int4, "_areaid" int4, "_timespanindays" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount"("_companyid" int4, "_areaid" int4=0, "_timespanindays" int4=0)
  RETURNS TABLE("actions_count" int4, "unresolved_actions_count" int4, "overdue_actions_count" int4, "resolved_actions_count" int4) AS $BODY$BEGIN
	RETURN QUERY
		WITH RECURSIVE areas AS (
				SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
		)	
		SELECT COUNT(*)::int4 AS actions_count, 
		SUM(CASE WHEN AA.is_resolved = false THEN 1 ELSE 0 END)::int4 AS unresolved_actions_count,
		SUM(CASE WHEN AA.due_date < AA.resolved_at::date AND AA.resolved_at IS NOT NULL THEN 1 ELSE 0 END)::int4 AS overdue_actions_count,
		SUM(CASE WHEN AA.is_resolved = true THEN 1 ELSE 0 END)::int4 AS resolved_actions_count
		FROM actions_action AA
		WHERE AA.company_id = _companyid AND AA.is_active = true
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
		AND (AA.created_at > (NOW()::date - CONCAT(_timespanindays,' days')::interval) OR _timespanindays = 0)
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_pastdue_per_assignedarea
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_pastdue_per_assignedarea"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_pastdue_per_assignedarea"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT COUNT(AA.id)::int4, AAA.area_id AS id FROM actions_action AA 
	LEFT JOIN actions_action_assigned_areas AAA ON AAA.action_id = AA.id
	WHERE AA.due_date::date < NOW()::date AND AA.is_resolved = false AND AA.company_id = _companyid GROUP BY AAA.area_id ORDER BY AAA.area_id 
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_pastdue_per_assigneduser
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_pastdue_per_assigneduser"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_pastdue_per_assigneduser"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "id" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH areas AS (
		SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
	)	
	SELECT COUNT(AA.id)::int4 AS count_nr, AAU.user_id AS id FROM actions_action AA 
	LEFT JOIN actions_action_assigned_users AAU ON AAU.action_id = AA.id
	WHERE AA.due_date::date < NOW()::date AND AA.is_resolved = false AND AA.is_active = true AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	GROUP BY AAU.user_id 
	ORDER BY AAU.user_id
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_per_action_state
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_per_action_state"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_per_action_state"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	WITH areas AS (
		SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
	)	
	--- STATS: nr of unresolved actions per company
	SELECT count(*)::int4 AS count_nr, 'unresolved actions'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.is_resolved = false AND AA.is_active = true AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	UNION
	--- STATS: nr of resolved actions per company
	SELECT count(*)::int4 AS count_nr, 'resolved actions'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.is_resolved = true AND AA.is_active = true AND AA.company_id = _companyid 
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	UNION
	--- STATS: nr of actions
	SELECT count(*)::int4 AS count_nr, 'total actions'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	UNION
	--- STATS: nr of actions pastdue 
	SELECT count(*)::int4 AS count_nr, 'past due actions'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.due_date::date < NOW()::date AND AA.is_active = true AND AA.is_resolved = false AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	UNION
	--- STATS: nr of actions resolved last 7 days
	SELECT count(*)::int4 AS count_nr, 'resolved actions last 7 days'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.resolved_at > (NOW() - interval '7 days') AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	UNION
	--- STATS: nr of actions resolved last 30 days
	SELECT count(*)::int4 AS count_nr, 'resolved actions last 30 days'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.resolved_at > (NOW() - interval '30 days') AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	UNION
		--- STATS: nr of actions new last 7 days
	SELECT count(*)::int4 AS count_nr, 'new actions last 7 days'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.created_at > (NOW() - interval '7 days') AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	UNION
	--- STATS: nr of actions new last 30 days
	SELECT count(*)::int4 AS count_nr, 'new actions last 30 days'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.created_at > (NOW() - interval '30 days') AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	UNION
	--- STATS: nr of actions due today
	SELECT count(*)::int4 AS count_nr, 'due actions today'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.due_date::date = NOW()::date AND AA.is_active = true AND AA.is_resolved = false AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
  UNION
	--- STATS: nr of actions created today
	SELECT count(*)::int4 AS count_nr, 'new actions today'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.created_at::date = NOW()::date AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	UNION
	--- STATS: nr of actions resolved today
	SELECT count(*)::int4 AS count_nr, 'resolved actions today'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.resolved_at::date = NOW()::date AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_per_area
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_per_area"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_per_area"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT COUNT(AA.id)::int4, AAA.area_id AS id FROM actions_action AA 
	LEFT JOIN actions_action_assigned_areas AAA ON AAA.action_id = AA.id
	WHERE AA.is_resolved = false AND AA.company_id = _companyid GROUP BY AAA.area_id ORDER BY AAA.area_id 
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_per_assigned_user
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_per_assigned_user"("_companyid" int4, "_areaid" int4, "_timespanindays" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_per_assigned_user"("_companyid" int4, "_areaid" int4=0, "_timespanindays" int4=0)
  RETURNS TABLE("count_nr" int4, "id" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
		SELECT T.count_nr, PU.id, CONCAT(PU.first_name, ' ', PU.last_name)::varchar AS name FROM (
				WITH areas AS (
					SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
				)	
				SELECT COUNT(*)::int4 AS count_nr, AAU.user_id
				FROM actions_action AA
				INNER JOIN actions_action_assigned_users AAU ON AAU.action_id = AA.id
				WHERE AA.is_active = true AND AA.company_id = _companyid
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
				AND (AA.created_at > (NOW()::date - CONCAT(_timespanindays,' days')::interval) OR _timespanindays = 0)
				GROUP BY AAU.user_id
		)	AS T
		INNER JOIN profiles_user PU ON PU.id = T.user_id
		ORDER BY T.count_nr DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_per_audittemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_per_audittemplate"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_per_audittemplate"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "id" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	WITH areas AS (
		SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
	)	
	SELECT COUNT(*)::int4 AS count_nr, AAT.audittemplate_id, AT.name FROM actions_action AA 
	LEFT JOIN tasks_task TT ON TT.id = AA.task_id
	INNER JOIN tasks_tasktemplate TTT ON (TTT.id = TT.template_id OR TTT.id = AA.task_template_id)
	INNER JOIN audits_audittemplate_tasks AAT ON AAT.tasktemplate_id = TTT.id
	INNER JOIN audits_audittemplate AT ON AT.id = AAT.audittemplate_id AND AT.is_active = true
	WHERE AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	GROUP BY AAT.audittemplate_id,AT.name 
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_per_checklisttemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_per_checklisttemplate"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_per_checklisttemplate"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "id" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	WITH areas AS (
		SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
	)	
	SELECT COUNT(*)::int4 AS count_nr, CCT.checklisttemplate_id AS id, CT.name FROM actions_action AA 
	LEFT JOIN tasks_task TT ON TT.id = AA.task_id
	INNER JOIN tasks_tasktemplate TTT ON (TTT.id = TT.template_id OR TTT.id = AA.task_template_id)
	INNER JOIN checklists_checklisttemplate_tasks CCT ON CCT.tasktemplate_id = TTT.id
	INNER JOIN checklists_checklisttemplate CT ON CT.id = CCT.checklisttemplate_id AND CT.is_active = true
	WHERE AA.company_id = _companyid 
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	GROUP BY CCT.checklisttemplate_id, CT.name
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_per_date
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_per_date"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_per_date"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	T.count_nr, 
	T.created_at::varchar AS name, 
	to_char(T.created_at,'yyyy')::int AS "year", 
	to_char(T.created_at,'MM')::int AS "month", 
	to_char(T.created_at,'dd')::int AS "day",
  to_char(T.created_at,'IW')::int AS "week"
	FROM (
		WITH areas AS (
			SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
		)
		SELECT COUNT(*)::int4 AS count_nr, 
		AA.created_at::date AS created_at
		FROM actions_action AA WHERE AA.is_active = true AND AA.company_id = _companyid
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
		GROUP BY AA.created_at::date 
		ORDER BY AA.created_at::date DESC
	) AS T
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_per_day
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_per_day"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_per_day"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "day" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH areas AS (
		SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
	)
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per day of year ',to_char(AA.created_at,'yyyy-DDD'))::varchar AS name, 
	to_char(AA.created_at,'yyyy')::int AS "year", 
	to_char(AA.created_at,'DDD')::int AS "day" 
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.company_id = _companyid 
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	GROUP BY to_char(AA.created_at,'yyyy-DDD'),to_char(AA.created_at,'yyyy'),to_char(AA.created_at,'DDD')
	ORDER BY to_char(AA.created_at,'yyyy-DDD') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_per_month
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_per_month"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_per_month"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "month" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH areas AS (
		SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
	)
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per month of year ',to_char(AA.created_at,'yyyy-MM'))::varchar AS name, 
	to_char(AA.created_at,'yyyy')::int AS "year", 
	to_char(AA.created_at,'MM')::int AS "month" 
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.company_id = _companyid 
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	GROUP BY to_char(AA.created_at,'yyyy-MM'),to_char(AA.created_at,'yyyy'),to_char(AA.created_at,'MM')
	ORDER BY to_char(AA.created_at,'yyyy-MM') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_per_tasktemplate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_per_tasktemplate"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_per_tasktemplate"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "id" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	WITH areas AS (
		SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
	)
	SELECT COUNT(*)::int4 AS count_nr, TTT.id AS task_template_id, TTT.name FROM actions_action AA 
	LEFT JOIN tasks_task TT ON TT.id = AA.task_id
	INNER JOIN tasks_tasktemplate TTT ON (TTT.id = TT.template_id OR TTT.id = AA.task_template_id) AND TTT.is_active = true AND TTT.type = 'task'
	WHERE AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	GROUP BY TTT.id, TTT.name
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_per_user
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_per_user"("_companyid" int4, "_areaid" int4, "_timespanindays" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_per_user"("_companyid" int4, "_areaid" int4=0, "_timespanindays" int4=0)
  RETURNS TABLE("count_nr" int4, "id" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
		SELECT T.count_nr, PU.id, CONCAT(PU.first_name, ' ', PU.last_name)::varchar AS name FROM (
				WITH areas AS (
					SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
				)	
				SELECT COUNT(*)::int4 AS count_nr, AA.created_by_id
				FROM actions_action AA 
				WHERE AA.is_active = true AND AA.company_id = _companyid
				AND (AA.created_at > (NOW()::date - CONCAT(_timespanindays,' days')::interval) OR _timespanindays = 0)
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
				GROUP BY AA.created_by_id
		)	AS T
		INNER JOIN profiles_user PU ON PU.id = T.created_by_id
		ORDER BY T.count_nr DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_per_week
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_per_week"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_per_week"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH areas AS (
		SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
	)
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per week of year ',to_char(AA.created_at,'yyyy-IW'))::varchar AS name, 
	to_char(AA.created_at,'yyyy')::int AS "year", 
	to_char(AA.created_at,'IW')::int AS "week" 
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.company_id = _companyid 
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	GROUP BY to_char(AA.created_at,'yyyy-IW'),to_char(AA.created_at,'yyyy'),to_char(AA.created_at,'IW')
	ORDER BY to_char(AA.created_at,'yyyy-IW') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_per_year
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_per_year"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_per_year"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH areas AS (
		SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
	)	
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per year ',to_char(AA.created_at,'yyyy'))::varchar AS name, 
	to_char(AA.created_at,'yyyy')::int AS "year" 
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.company_id = _companyid 
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	GROUP BY to_char(AA.created_at,'yyyy')
	ORDER BY to_char(AA.created_at,'yyyy') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_actionscount_started_resolved_per_date
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_actionscount_started_resolved_per_date"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_actionscount_started_resolved_per_date"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "status" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	T.count_nr, 
	T.dateitem::varchar AS name, 
	T.status::varchar AS status,
	to_char(T.dateitem,'yyyy')::int AS "year", 
	to_char(T.dateitem,'MM')::int AS "month", 
	to_char(T.dateitem,'dd')::int AS "day",
  to_char(T.dateitem,'IW')::int AS "week"
	FROM (
		WITH areas AS (
			SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
		)	
		SELECT COUNT(*)::int4 AS count_nr, 
		AA.created_at::date AS dateitem,
		'started' AS status
		FROM actions_action AA 
		WHERE AA.is_active = true AND AA.company_id = _companyid AND AA.is_resolved = false
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
		GROUP BY AA.created_at::date 
		UNION
		SELECT COUNT(*)::int4 AS count_nr, 
		AA.created_at::date AS dateitem,
		'resolved' AS status
		FROM actions_action AA 
		WHERE AA.is_active = true AND AA.company_id = _companyid AND AA.is_resolved = true
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
		GROUP BY AA.created_at::date 
	) AS T
	ORDER BY T.dateitem DESC, T.status ASC
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_audititemscount_per_state
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_audititemscount_per_state"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_audititemscount_per_state"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(TT.status, ' total')::varchar AS name 
	FROM tasks_task TT	
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'audit'
	INNER JOIN audits_audit_tasks AAT ON AAT.task_id = TT.id
	INNER JOIN audits_audit AA ON AA.id = AAT.audit_id
	INNER JOIN audits_audittemplate AATT ON AATT.id = AA.template_id
	WHERE TT.Company_ID = _companyid AND TT.recurrency_id IS NULL
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AATT.area_id) OR _areaid = 0) 
	AND (AATT.id = _audittemplateid OR _audittemplateid = 0)
	GROUP BY TT.status
	UNION
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(TT.status,' last 7 days')::varchar AS name 
	FROM tasks_task TT	
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'audit'	
	INNER JOIN audits_audit_tasks AAT ON AAT.task_id = TT.id
	INNER JOIN audits_audit AA ON AA.id = AAT.audit_id
	INNER JOIN audits_audittemplate AATT ON AATT.id = AA.template_id
	WHERE TT.created_at > (NOW()::date - interval '7 days') AND TT.Company_ID = _companyid AND TT.recurrency_id IS NULL
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AATT.area_id) OR _areaid = 0) 
	AND (AATT.id = _audittemplateid OR _audittemplateid = 0)
	GROUP BY TT.status
	UNION
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(TT.status,' last 30 days')::varchar AS name 
	FROM tasks_task TT	
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'audit'
	INNER JOIN audits_audit_tasks AAT ON AAT.task_id = TT.id
	INNER JOIN audits_audit AA ON AA.id = AAT.audit_id
	INNER JOIN audits_audittemplate AATT ON AATT.id = AA.template_id	
	WHERE TT.created_at > (NOW()::date - interval '30 days') AND TT.Company_ID = _companyid AND TT.recurrency_id IS NULL
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AATT.area_id) OR _areaid = 0) 
	AND (AATT.id = _audittemplateid OR _audittemplateid = 0)
	GROUP BY TT.status
	UNION
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(TT.status,' today')::varchar AS name 
	FROM tasks_task TT	
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'audit'	
	INNER JOIN audits_audit_tasks AAT ON AAT.task_id = TT.id
	INNER JOIN audits_audit AA ON AA.id = AAT.audit_id
	INNER JOIN audits_audittemplate AATT ON AATT.id = AA.template_id
	WHERE TT.created_at::date = NOW()::date AND TT.Company_ID = _companyid AND TT.recurrency_id IS NULL
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AATT.area_id) OR _areaid = 0)
  AND (AATT.id = _audittemplateid OR _audittemplateid = 0)	
	GROUP BY TT.status
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_audititemscount_per_state_per_date
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_audititemscount_per_state_per_date"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_audititemscount_per_state_per_date"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("count_nr" int4, "status" varchar, "name" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
		T.count_nr,
		T.status,
		CONCAT('count ', T.status,' per ', T.signed_at::date)::varchar AS name,
		to_char(T.signed_at,'yyyy')::int AS "year", 
		to_char(T.signed_at,'MM')::int AS "month", 
		to_char(T.signed_at,'dd')::int AS "day",
		to_char(T.signed_at,'IW')::int AS "week"
	FROM 
	(
		WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)
		SELECT 
			COUNT(*)::int AS "count_nr", 
			AA.signed_at_1::date AS signed_at,
			TT.status AS status
		FROM tasks_task TT	
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'audit'	
		INNER JOIN audits_audit_tasks AAT ON AAT.task_id = TT.id
		INNER JOIN audits_audit AA ON AA.id = AAT.audit_id AND AA.is_active = true AND AA.is_complete = true
		INNER JOIN audits_audittemplate AATT ON AATT.id = AA.template_id
		WHERE TT.Company_ID = _companyid AND TT.recurrency_id IS NULL
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AATT.area_id) OR _areaid = 0)
	  AND (AATT.id = _audittemplateid OR _audittemplateid = 0)	
		GROUP BY TT.status, AA.signed_at_1::date 
		ORDER BY AA.signed_at_1::date DESC, TT.status DESC
	) AS T
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_auditsaverage_per_date
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_auditsaverage_per_date"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_auditsaverage_per_date"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("average_nr" numeric, "name" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
		SELECT 
	T.average_nr, 
	T.signed_at::varchar AS name, 
	to_char(T.signed_at,'yyyy')::int AS "year", 
	to_char(T.signed_at,'MM')::int AS "month", 
	to_char(T.signed_at,'dd')::int AS "day",
  to_char(T.signed_at,'IW')::int AS "week"
	FROM (
		WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	
		SELECT AVG(AA.total_score)::numeric AS average_nr, 
		AA.signed_at_1::date AS signed_at
		FROM audits_audit AA 
		INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
		WHERE AA.is_active = true AND AA.is_complete = true AND AA.company_id = _companyid 
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
		AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
		GROUP BY AA.signed_at_1::date 
		ORDER BY AA.signed_at_1::date DESC
	) AS T;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_auditsaverage_per_day
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_auditsaverage_per_day"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_auditsaverage_per_day"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("average_nr" numeric, "name" varchar, "year" int4, "day" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	
		SELECT 
		AVG(AA.total_score)::decimal AS average_nr, 
		CONCAT('average audit score per day of year ',to_char(AA.signed_at_1,'yyyy-DDD'))::varchar AS name, 
		to_char(AA.signed_at_1,'yyyy')::int AS "year", 
		to_char(AA.signed_at_1,'DDD')::int AS "day" 
		FROM audits_audit AA 
		INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
		WHERE AA.is_active = true AND AA.is_complete = true AND AA.company_id = _companyid 
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
		AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
		GROUP BY to_char(AA.signed_at_1,'yyyy-DDD'),to_char(AA.signed_at_1,'yyyy'),to_char(AA.signed_at_1,'DDD')
		ORDER BY to_char(AA.signed_at_1,'yyyy-DDD'), to_char(AA.signed_at_1,'yyyy'),to_char(AA.signed_at_1,'DDD') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_auditsaverage_per_month
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_auditsaverage_per_month"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_auditsaverage_per_month"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("average_nr" numeric, "name" varchar, "year" int4, "month" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	
		SELECT 
		AVG(AA.total_score)::decimal AS average_nr, 
		CONCAT('average audit score per month of year ' , to_char(AA.signed_at_1,'yyyy-MM'))::varchar AS name, 
		to_char(AA.signed_at_1,'yyyy')::int AS "year",
		to_char(AA.signed_at_1,'MM')::int AS "month"
		FROM audits_audit AA 
		INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
		WHERE AA.is_active = true AND AA.is_complete = true AND AA.company_id = _companyid
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
	  AND (AAT.id = _audittemplateid OR _audittemplateid = 0)	
		GROUP BY to_char(AA.signed_at_1,'yyyy-MM'),to_char(AA.signed_at_1,'yyyy'),to_char(AA.signed_at_1,'MM')
		ORDER BY to_char(AA.signed_at_1,'yyyy-MM') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_auditsaverage_per_state
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_auditsaverage_per_state"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_auditsaverage_per_state"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("average_nr" numeric, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	
  SELECT AVG(AA.total_score)::decimal AS average_nr, 'average audit score last 7 days'::varchar AS name 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.signed_at_1 > (NOW() - interval '7 days') AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)
  AND (AAT.id = _audittemplateid OR _audittemplateid = 0)	
	UNION
	SELECT AVG(AA.total_score)::decimal AS average_nr, 'average audit score last 30 days'::varchar AS name 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.signed_at_1 > (NOW() - interval '30 days') AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT AVG(AA.total_score)::decimal AS average_nr, 'average audit score today'::varchar AS name 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.signed_at_1::date = NOW()::date AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT AVG(AA.total_score)::decimal AS average_nr, 'average audit score all time'::varchar AS name 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.company_id = _companyid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_auditsaverage_per_week
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_auditsaverage_per_week"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_auditsaverage_per_week"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("average_nr" numeric, "name" varchar, "year" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	
		SELECT AVG(AA.total_score)::decimal AS average_nr, CONCAT('average audit score per week of year ' , 
		to_char(AA.signed_at_1,'yyyy-IW'))::varchar AS name,
		to_char(AA.signed_at_1,'yyyy')::int AS "year",
		to_char(AA.signed_at_1,'IW')::int AS "week"
		FROM audits_audit AA 
		INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
		WHERE AA.is_active = true AND AA.is_complete = true AND AA.company_id = _companyid 
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
		AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
		GROUP BY to_char(AA.signed_at_1,'yyyy-IW'),to_char(AA.signed_at_1,'yyyy'),to_char(AA.signed_at_1,'IW')
		ORDER BY to_char(AA.signed_at_1,'yyyy-IW') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_auditsaverage_per_year
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_auditsaverage_per_year"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_auditsaverage_per_year"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("average_nr" numeric, "name" varchar, "year" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	
		SELECT 
		AVG(AA.total_score)::decimal AS average_nr, 
		CONCAT('average audit score per year ',to_char(AA.signed_at_1,'yyyy'))::varchar AS name, 
		to_char(AA.signed_at_1,'yyyy')::int AS "year" 
		FROM audits_audit AA 
		INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
		WHERE AA.is_active = true AND AA.is_complete = true AND AA.company_id = _companyid 
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
		AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
		GROUP BY to_char(AA.signed_at_1,'yyyy')
		ORDER BY to_char(AA.signed_at_1,'yyyy') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_auditscount_per_audit_state
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_auditscount_per_audit_state"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_auditscount_per_audit_state"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)	
	SELECT count(*)::int4 AS count_nr, 'total audits'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'new audits last 7 days'::varchar 
	FROM audits_audit AA
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id	
	WHERE AA.is_active = true AND AA.created_at > (NOW()::date - interval '7 days') AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'new audits last 30 days'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.created_at > (NOW()::date - interval '30 days') AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'new audits today'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.created_at::date = NOW()::date AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'completed audits last 7 days'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.signed_at_1 > (NOW()::date - interval '7 days') AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'completed audits last 30 days'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.signed_at_1 > (NOW()::date - interval '30 days') AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'completed audits today'::varchar 
	FROM audits_audit AA
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id	
	WHERE AA.is_active = true AND AA.signed_at_1::date = NOW()::date AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'audits with score 100'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.total_score = 100 AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'audits with score 0'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.total_score = 0 AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'audits with score between 0 and 10'::varchar 
	FROM audits_audit AA
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.total_score > 0 AND AA.total_score <= 10 AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'audits with score between 10 and 20'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.total_score > 10 AND AA.total_score <= 20 AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'audits with score between 20 and 30'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.total_score > 20 AND AA.total_score <= 30 AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'audits with score between 30 and 40'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.total_score > 30 AND AA.total_score <= 40 AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'audits with score between 40 and 50'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.total_score > 40 AND AA.total_score <= 50 AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'audits with score between 50 and 60'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.total_score > 50 AND AA.total_score <= 60 AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'audits with score between 60 and 70'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.total_score > 60 AND AA.total_score <= 70 AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'audits with score between 70 and 80'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.total_score > 70 AND AA.total_score <= 80 AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'audits with score between 80 and 90'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.total_score > 80 AND AA.total_score <= 90 AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	UNION
	SELECT count(*)::int4 AS count_nr, 'audits with score between 90 and 100'::varchar 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.total_score > 90 AND AA.total_score <= 100 AND AA.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_auditscount_per_date
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_auditscount_per_date"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_auditscount_per_date"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	T.count_nr, 
	T.signed_at::varchar AS name, 
	to_char(T.signed_at,'yyyy')::int AS "year", 
	to_char(T.signed_at,'MM')::int AS "month", 
	to_char(T.signed_at,'dd')::int AS "day",
  to_char(T.signed_at,'IW')::int AS "week"
	FROM (
		WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	
		SELECT COUNT(*)::int4 AS count_nr, 
		AA.signed_at_1::date AS signed_at
		FROM audits_audit AA 
		INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
		WHERE AA.is_active = true AND AA.is_complete = true AND AA.company_id = _companyid 
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)
		AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
		GROUP BY AA.signed_at_1::date 
		ORDER BY AA.signed_at_1::date DESC
	) AS T
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_auditscount_per_day
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_auditscount_per_day"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_auditscount_per_day"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "day" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	
		SELECT COUNT(*)::int4 AS count_nr, 
		CONCAT('count per day of year ',to_char(AA.signed_at_1,'yyyy-DDD'))::varchar AS name, 
		to_char(AA.signed_at_1,'yyyy')::int AS "year", 
		to_char(AA.signed_at_1,'DDD')::int AS "day" 
		FROM audits_audit AA 
		INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
		WHERE AA.is_active = true AND AA.company_id = _companyid 
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)
		AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
		GROUP BY to_char(AA.signed_at_1,'yyyy-DDD'),to_char(AA.signed_at_1,'yyyy'),to_char(AA.signed_at_1,'DDD')
		ORDER BY to_char(AA.signed_at_1,'yyyy-DDD') DESC
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_auditscount_per_month
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_auditscount_per_month"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_auditscount_per_month"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "month" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)	
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per month of year ',to_char(AA.signed_at_1,'yyyy-MM'))::varchar AS name, 
	to_char(AA.signed_at_1,'yyyy')::int AS "year", 
	to_char(AA.signed_at_1,'MM')::int AS "month" 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.company_id = _companyid 
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)
	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	GROUP BY to_char(AA.signed_at_1,'yyyy-MM'),to_char(AA.signed_at_1,'yyyy'),to_char(AA.signed_at_1,'MM')
	ORDER BY to_char(AA.signed_at_1,'yyyy-MM') DESC
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_auditscount_per_user
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_auditscount_per_user"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_auditscount_per_user"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("count_nr" int4, "id" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT T.count_nr, PU.id, CONCAT(PU.first_name, ' ', PU.last_name)::varchar AS name FROM (
			WITH RECURSIVE areas AS (
				SELECT
					a.id,a.name,a.parent_id, a.company_id
				FROM
					companies_area a
				WHERE
					a.id = _areaid
				UNION
				SELECT
					 e.id,e.name,e.parent_id, e.company_id
				FROM
					 companies_area e
				INNER JOIN areas s ON e.parent_id = s.id 
				WHERE e.is_active = true
			)	
			SELECT COUNT(*)::int4 AS count_nr, AA.signed_by_1_id AS signed_by_id
			FROM audits_audit AA 
			INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
			WHERE AA.is_active = true AND AA.company_id = _companyid
			AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)
			AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
			GROUP BY AA.signed_by_1_id
	)	AS T
	INNER JOIN profiles_user PU ON PU.id = T.signed_by_id
	ORDER BY T.count_nr DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_auditscount_per_week
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_auditscount_per_week"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_auditscount_per_week"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)	
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per week of year ',to_char(AA.signed_at_1,'yyyy-IW'))::varchar AS name, 
	to_char(AA.signed_at_1,'yyyy')::int AS "year", 
	to_char(AA.signed_at_1,'IW')::int AS "week" 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.company_id = _companyid 
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)
	AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	GROUP BY to_char(AA.signed_at_1,'yyyy-IW'),to_char(AA.signed_at_1,'yyyy'),to_char(AA.signed_at_1,'IW')
	ORDER BY to_char(AA.signed_at_1,'yyyy-IW') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_auditscount_per_year
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_auditscount_per_year"("_companyid" int4, "_areaid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_auditscount_per_year"("_companyid" int4, "_areaid" int4=0, "_audittemplateid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)	
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per year ',to_char(AA.signed_at_1,'yyyy'))::varchar AS name, 
	to_char(AA.signed_at_1,'yyyy')::int AS "year"
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.company_id = _companyid 
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0)
  AND (AAT.id = _audittemplateid OR _audittemplateid = 0)
	GROUP BY to_char(AA.signed_at_1,'yyyy')
	ORDER BY to_char(AA.signed_at_1,'yyyy') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_checklistitemscount_per_state
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_checklistitemscount_per_state"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_checklistitemscount_per_state"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(TT.status, ' total')::varchar AS name 
	FROM tasks_task TT	
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'checklist'	
	INNER JOIN checklists_checklist_tasks CCT ON CCT.task_id = TT.id
	INNER JOIN checklists_checklist CC ON CC.id = CCT.checklist_id
	INNER JOIN checklists_checklisttemplate CCTT ON CCTT.id = CC.template_id
	WHERE TT.Company_ID = _companyid AND TT.recurrency_id IS NULL
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCTT.area_id) OR _areaid = 0) 
	GROUP BY TT.status
	UNION
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(TT.status,' last 7 days')::varchar AS name FROM tasks_task TT	
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'checklist'	
	INNER JOIN checklists_checklist_tasks CCT ON CCT.task_id = TT.id
	INNER JOIN checklists_checklist CC ON CC.id = CCT.checklist_id
	INNER JOIN checklists_checklisttemplate CCTT ON CCTT.id = CC.template_id
	WHERE TT.created_at > (NOW()::date - interval '7 days') AND TT.Company_ID = _companyid AND TT.recurrency_id IS NULL
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCTT.area_id) OR _areaid = 0) 
	GROUP BY TT.status
	UNION
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(TT.status,' last 30 days')::varchar AS name 
	FROM tasks_task TT	
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'checklist'	
	INNER JOIN checklists_checklist_tasks CCT ON CCT.task_id = TT.id
	INNER JOIN checklists_checklist CC ON CC.id = CCT.checklist_id
	INNER JOIN checklists_checklisttemplate CCTT ON CCTT.id = CC.template_id
	WHERE TT.created_at > (NOW()::date - interval '30 days') AND TT.Company_ID = _companyid AND TT.recurrency_id IS NULL
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCTT.area_id) OR _areaid = 0) 
	GROUP BY TT.status
	UNION
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(TT.status,' today')::varchar AS name 
	FROM tasks_task TT	
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'checklist'	
	INNER JOIN checklists_checklist_tasks CCT ON CCT.task_id = TT.id
	INNER JOIN checklists_checklist CC ON CC.id = CCT.checklist_id
	INNER JOIN checklists_checklisttemplate CCTT ON CCTT.id = CC.template_id
	WHERE TT.created_at::date = NOW()::date AND TT.Company_ID = _companyid AND TT.recurrency_id IS NULL
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCTT.area_id) OR _areaid = 0) 
	GROUP BY TT.status
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_checklistitemscount_per_state_per_date
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_checklistitemscount_per_state_per_date"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_checklistitemscount_per_state_per_date"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "status" varchar, "name" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
		T.count_nr,
		T.status,
		CONCAT('count ', T.status,' per ', T.signed_at::date)::varchar AS name,
		to_char(T.signed_at,'yyyy')::int AS "year", 
		to_char(T.signed_at,'MM')::int AS "month", 
		to_char(T.signed_at,'dd')::int AS "day",
		to_char(T.signed_at,'IW')::int AS "week"
	FROM 
	(
		WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)
		SELECT 
			COUNT(*)::int AS "count_nr", 
			CC.signed_at_1::date AS signed_at,
			TT.status AS status
		FROM tasks_task TT	
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'checklist'	
		INNER JOIN checklists_checklist_tasks CCT ON CCT.task_id = TT.id
		INNER JOIN checklists_checklist CC ON CC.id = CCT.checklist_id AND CC.is_active = true AND CC.is_complete = true
		INNER JOIN checklists_checklisttemplate CCTT ON CCTT.id = CC.template_id
		WHERE TT.Company_ID = _companyid AND TT.recurrency_id IS NULL
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCTT.area_id) OR _areaid = 0) 
		GROUP BY TT.status, CC.signed_at_1::date ORDER BY CC.signed_at_1::date DESC, TT.status DESC
	) AS T
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_checklistscount_per_checklist_state
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_checklistscount_per_checklist_state"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_checklistscount_per_checklist_state"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)	
	SELECT count(*)::int4 AS count_nr, 'total checklists'::varchar 
	FROM checklists_checklist CC 
	INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
	WHERE CC.is_active = true AND CC.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0) 
	UNION
	SELECT count(*)::int4 AS count_nr, 'new checklists last 7 days'::varchar 
	FROM checklists_checklist CC 
	INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
	WHERE CC.is_active = true AND CC.created_at > (NOW()::date - interval '7 days') AND CC.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0) 
	UNION
	SELECT count(*)::int4 AS count_nr, 'new checklists last 30 days'::varchar 
	FROM checklists_checklist CC 
	INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
	WHERE CC.is_active = true AND CC.created_at > (NOW()::date - interval '30 days') AND CC.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0) 
	UNION
	SELECT count(*)::int4 AS count_nr, 'new checklists today'::varchar 
	FROM checklists_checklist CC 
	INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
	WHERE CC.is_active = true AND CC.created_at::date = NOW()::date AND CC.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0) 
	UNION
	SELECT count(*)::int4 AS count_nr, 'completed checklists last 7 days'::varchar 
	FROM checklists_checklist CC 
	INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
	WHERE CC.is_active = true AND CC.signed_at_1 > (NOW()::date - interval '7 days') AND CC.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0) 
	UNION
	SELECT count(*)::int4 AS count_nr, 'completed checklists last 30 days'::varchar 
	FROM checklists_checklist CC 
	INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
	WHERE CC.is_active = true AND CC.signed_at_1 > (NOW()::date - interval '30 days') AND CC.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0) 
	UNION
	SELECT count(*)::int4 AS count_nr, 'completed checklists today'::varchar 
	FROM checklists_checklist CC 
	INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
	WHERE CC.is_active = true AND CC.signed_at_1::date = NOW()::date AND CC.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0) 
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_checklistscount_per_date
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_checklistscount_per_date"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_checklistscount_per_date"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	T.count_nr, 
	T.signed_at::varchar AS name, 
	to_char(T.signed_at,'yyyy')::int AS "year", 
	to_char(T.signed_at,'MM')::int AS "month", 
	to_char(T.signed_at,'dd')::int AS "day",
  to_char(T.signed_at,'IW')::int AS "week"
	FROM (
		WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	
		SELECT 
		COUNT(*)::int4 AS count_nr,  
		CC.signed_at_1::date AS signed_at 
		FROM checklists_checklist CC 
		INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
		WHERE CC.is_active = true AND CC.is_complete = true AND CC.company_id = _companyid 
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0)
		GROUP BY CC.signed_at_1::date 
		ORDER BY CC.signed_at_1::date DESC
	 ) AS T
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_checklistscount_per_day
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_checklistscount_per_day"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_checklistscount_per_day"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "day" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)	
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per day of year ',to_char(CC.signed_at_1,'yyyy-DDD'))::varchar AS name, 
	to_char(CC.signed_at_1,'yyyy')::int AS "year", 
	to_char(CC.signed_at_1,'DDD')::int AS "day" 
	FROM checklists_checklist CC 
	INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
	WHERE CC.is_active = true AND CC.company_id = _companyid 
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0)
	GROUP BY to_char(CC.signed_at_1,'yyyy-DDD'),to_char(CC.signed_at_1,'yyyy'),to_char(CC.signed_at_1,'DDD')
	ORDER BY to_char(CC.signed_at_1,'yyyy-DDD') DESC
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_checklistscount_per_month
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_checklistscount_per_month"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_checklistscount_per_month"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "month" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per month of year ',to_char(CC.signed_at_1,'yyyy-MM'))::varchar AS name, 
	to_char(CC.signed_at_1,'yyyy')::int AS "year", 
	to_char(CC.signed_at_1,'MM')::int AS "month" 
	FROM checklists_checklist CC 
	INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
	WHERE CC.is_active = true AND CC.company_id = _companyid 
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0)
	GROUP BY to_char(CC.signed_at_1,'yyyy-MM'),to_char(CC.signed_at_1,'yyyy'),to_char(CC.signed_at_1,'MM')
	ORDER BY to_char(CC.signed_at_1,'yyyy-MM') DESC
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_checklistscount_per_user
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_checklistscount_per_user"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_checklistscount_per_user"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "id" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
		SELECT T.count_nr, PU.id, CONCAT(PU.first_name, ' ', PU.last_name)::varchar AS name FROM (
				WITH RECURSIVE areas AS (
					SELECT
						a.id,a.name,a.parent_id, a.company_id
					FROM
						companies_area a
					WHERE
						a.id = _areaid
					UNION
					SELECT
						 e.id,e.name,e.parent_id, e.company_id
					FROM
						 companies_area e
					INNER JOIN areas s ON e.parent_id = s.id 
					WHERE e.is_active = true
				)
				SELECT COUNT(*)::int4 AS count_nr, CC.signed_by_1_id AS signed_by_id
				FROM checklists_checklist CC 
				INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
				WHERE CC.is_active = true AND CC.company_id = _companyid
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0)
				GROUP BY CC.signed_by_1_id
		)	AS T
		INNER JOIN profiles_user PU ON PU.id = T.signed_by_id
		ORDER BY T.count_nr DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_checklistscount_per_week
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_checklistscount_per_week"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_checklistscount_per_week"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per week of year ',to_char(CC.signed_at_1,'yyyy-IW'))::varchar AS name, 
	to_char(CC.signed_at_1,'yyyy')::int AS "year", 
	to_char(CC.signed_at_1,'IW')::int AS "week" 
	FROM checklists_checklist CC 
	INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
	WHERE CC.is_active = true AND CC.company_id = _companyid 
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0)
	GROUP BY to_char(CC.signed_at_1,'yyyy-IW'),to_char(CC.signed_at_1,'yyyy'),to_char(CC.signed_at_1,'IW')
	ORDER BY to_char(CC.signed_at_1,'yyyy-IW') DESC
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_checklistscount_per_year
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_checklistscount_per_year"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_checklistscount_per_year"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per year ',to_char(CC.signed_at_1,'yyyy'))::varchar AS name, 
	to_char(CC.signed_at_1,'yyyy')::int AS "year"
	FROM checklists_checklist CC 
	INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
	WHERE CC.is_active = true AND CC.company_id = _companyid 
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0)
	GROUP BY to_char(CC.signed_at_1,'yyyy')
	ORDER BY to_char(CC.signed_at_1,'yyyy') DESC
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_commentcount_per_action
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_commentcount_per_action"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_commentcount_per_action"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "id" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT T.id, T.count_nr FROM (
	SELECT count(AAC.*)::int4 AS count_nr, AA.id AS id FROM actions_actioncomment AAC
	INNER JOIN actions_action AA ON AA.id = AAC.action_ID AND AA.is_active = true
	WHERE AAC.is_active = true AND AA.company_id = _companyid
	GROUP BY AA.id
) AS T
ORDER BY T.count_nr DESC, T.id 
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_logging_requestresponse
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_logging_requestresponse"();
CREATE OR REPLACE FUNCTION "public"."report_statistics_logging_requestresponse"()
  RETURNS TABLE("count_nr" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT * FROM (
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(LR.path, ' (', LR.status , ')')::varchar AS name FROM logging_requestresponse LR
	GROUP BY LR.status, LR.path) AS T 
	ORDER BY T.count_nr DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	), actionareas AS (
		SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
	)
	SELECT COUNT(*)::int4 AS count_nr, 'my audits total'::varchar AS name 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.signed_by_1_id = _userid AND AA.company_id = _companyid
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my checklists total'::varchar AS name 
	FROM checklists_checklist CC 
	INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
	WHERE CC.signed_by_1_id = _userid AND CC.company_id = _companyid
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0) 
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my tasks total'::varchar AS name 
	FROM tasks_task TT 
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'task' 
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	WHERE TT.signed_by_id = _userid AND TT.company_id = _companyid
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my actions created by me total'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.created_by_id = _userid AND AA.company_id = _companyid
		AND (EXISTS (SELECT actionareas.id FROM actionareas WHERE actionareas.id = AA.id) OR _areaid = 0)
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my actions assigned to me total'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.id IN (SELECT AAAU.action_id FROM actions_action_assigned_users AAAU WHERE AAAU.user_id = _userid) AND AA.company_id = _companyid
		AND (EXISTS (SELECT actionareas.id FROM actionareas WHERE actionareas.id = AA.id) OR _areaid = 0)
	UNION 
	SELECT COUNT(*)::int4 AS count_nr, 'my actions where I commented total'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.id IN (SELECT AAC.action_id FROM actions_actioncomment AAC WHERE AAC.user_id = _userid) AND AA.company_id = _companyid
		AND (EXISTS (SELECT actionareas.id FROM actionareas WHERE actionareas.id = AA.id) OR _areaid = 0)
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my pastdue actions created by me'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.created_by_id = _userid AND AA.company_id = _companyid AND AA.due_date < NOW()::date AND AA.is_resolved = false
		AND (EXISTS (SELECT actionareas.id FROM actionareas WHERE actionareas.id = AA.id) OR _areaid = 0)
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my due actions today created by me'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.created_by_id = _userid AND AA.company_id = _companyid AND AA.due_date = NOW()::date AND AA.is_resolved = false
		AND (EXISTS (SELECT actionareas.id FROM actionareas WHERE actionareas.id = AA.id) OR _areaid = 0)
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my resolved actions created by me'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.created_by_id = _userid AND AA.company_id = _companyid AND AA.is_resolved = true
		AND (EXISTS (SELECT actionareas.id FROM actionareas WHERE actionareas.id = AA.id) OR _areaid = 0)
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my resolved actions today created by me'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.created_by_id = _userid AND AA.company_id = _companyid AND AA.is_resolved = true AND AA.resolved_at = NOW()::date
		AND (EXISTS (SELECT actionareas.id FROM actionareas WHERE actionareas.id = AA.id) OR _areaid = 0)
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my unresolved actions created by me'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.created_by_id = _userid AND AA.company_id = _companyid AND AA.is_resolved = false
		AND (EXISTS (SELECT actionareas.id FROM actionareas WHERE actionareas.id = AA.id) OR _areaid = 0)
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my resolved actions assigned to me'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.id IN (SELECT AAAU.action_id FROM actions_action_assigned_users AAAU WHERE AAAU.user_id = _userid) AND AA.company_id = _companyid AND AA.is_resolved = true
		AND (EXISTS (SELECT actionareas.id FROM actionareas WHERE actionareas.id = AA.id) OR _areaid = 0)
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my unresolved actions assigned to me'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.id IN (SELECT AAAU.action_id FROM actions_action_assigned_users AAAU WHERE AAAU.user_id = _userid) AND AA.company_id = _companyid AND AA.is_resolved = false
		AND (EXISTS (SELECT actionareas.id FROM actionareas WHERE actionareas.id = AA.id) OR _areaid = 0)
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my audits today'::varchar AS name 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.signed_by_1_id = _userid AND AA.company_id = _companyid AND AA.signed_at_1::date = NOW()::date
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my checklists today'::varchar AS name 
	FROM checklists_checklist CC 
	INNER JOIN checklists_checklisttemplate CCT ON CCT.id = CC.template_id
	WHERE CC.signed_by_1_id = _userid AND CC.company_id = _companyid AND CC.signed_at_1::date = NOW()::date
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = CCT.area_id) OR _areaid = 0) 
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my tasks today'::varchar AS name 
	FROM tasks_task TT 
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'task' 
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	WHERE TT.signed_by_id = _userid AND TT.company_id = _companyid AND TT.signed_at::date = NOW()::date
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my ok tasks today'::varchar AS name 
	FROM tasks_task TT 
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'task' 
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	WHERE TT.signed_by_id = _userid AND TT.company_id = _companyid AND TT.signed_at::date = NOW()::date AND TT.status = 'ok'
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my skipped tasks today'::varchar AS name 
	FROM tasks_task TT 
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'task' 
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	WHERE TT.signed_by_id = _userid AND TT.company_id = _companyid AND TT.signed_at::date = NOW()::date AND TT.status = 'skipped'
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my not ok tasks today'::varchar AS name 
	FROM tasks_task TT 
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'task' 
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	WHERE TT.signed_by_id = _userid AND TT.company_id = _companyid AND TT.signed_at::date = NOW()::date AND TT.status = 'not ok'
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
	UNION
	SELECT COUNT(*)::int4 AS count_nr, 'my unresolved actions assigned to me not viewed by me'::varchar AS name 
	FROM actions_action AA 
	WHERE AA.id IN (SELECT AAAU.action_id FROM actions_action_assigned_users AAAU WHERE AAAU.user_id = _userid) AND AA.company_id = _companyid AND AA.is_resolved = false
		AND (EXISTS (SELECT actionareas.id FROM actionareas WHERE actionareas.id = AA.id) OR _areaid = 0)
		AND AA.id NOT IN (SELECT action_id FROM actions_actionviewed WHERE user_id = _userid)
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_actionscount_per_date
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_actionscount_per_date"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_actionscount_per_date"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	T.count_nr, 
	T.created_at::varchar AS name, 
	to_char(T.created_at,'yyyy')::int AS "year", 
	to_char(T.created_at,'MM')::int AS "month", 
	to_char(T.created_at,'dd')::int AS "day",
  to_char(T.created_at,'IW')::int AS "week"
	FROM (
		WITH areas AS (
			SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
		)	
		SELECT COUNT(*)::int4 AS count_nr, 
		AA.created_at::date AS created_at
		FROM actions_action AA 
		WHERE AA.is_active = true AND AA.company_id = _companyid AND AA.created_by_id = _userid
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
		GROUP BY AA.created_at::date 
		ORDER BY AA.created_at::date DESC
	) AS T
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_actionscount_per_day
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_actionscount_per_day"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_actionscount_per_day"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "day" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH areas AS (
		SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
	)
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per day of year ',to_char(AA.created_at,'yyyy-DDD'))::varchar AS name, 
	to_char(AA.created_at,'yyyy')::int AS "year", 
	to_char(AA.created_at,'DDD')::int AS "day" 
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.company_id = _companyid AND AA.created_by_id = _userid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	GROUP BY to_char(AA.created_at,'yyyy-DDD'),to_char(AA.created_at,'yyyy'),to_char(AA.created_at,'DDD')
	ORDER BY to_char(AA.created_at,'yyyy-DDD') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_actionscount_per_month
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_actionscount_per_month"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_actionscount_per_month"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "month" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH areas AS (
		SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
	)	
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per day of year ',to_char(AA.created_at,'yyyy-MM'))::varchar AS name, 
	to_char(AA.created_at,'yyyy')::int AS "year", 
	to_char(AA.created_at,'MM')::int AS "month" 
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.company_id = _companyid AND AA.created_by_id = _userid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	GROUP BY to_char(AA.created_at,'yyyy-MM'),to_char(AA.created_at,'yyyy'),to_char(AA.created_at,'MM')
	ORDER BY to_char(AA.created_at,'yyyy-MM') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_actionscount_per_week
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_actionscount_per_week"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_actionscount_per_week"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH areas AS (
		SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
	)
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per day of year ',to_char(AA.created_at,'yyyy-IW'))::varchar AS name, 
	to_char(AA.created_at,'yyyy')::int AS "year", 
	to_char(AA.created_at,'IW')::int AS "week" 
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.company_id = _companyid AND AA.created_by_id = _userid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	GROUP BY to_char(AA.created_at,'yyyy-IW'),to_char(AA.created_at,'yyyy'),to_char(AA.created_at,'IW')
	ORDER BY to_char(AA.created_at,'yyyy-IW') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_actionscount_per_year
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_actionscount_per_year"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_actionscount_per_year"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH areas AS (
		SELECT area_id, action_id AS id FROM get_actionids_by_area(_companyid, _areaid)
	)
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per day of year ',to_char(AA.created_at,'yyyy'))::varchar AS name, 
	to_char(AA.created_at,'yyyy')::int AS "year"
	FROM actions_action AA 
	WHERE AA.is_active = true AND AA.company_id = _companyid AND AA.created_by_id = _userid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AA.id) OR _areaid = 0)
	GROUP BY to_char(AA.created_at,'yyyy')
	ORDER BY to_char(AA.created_at,'yyyy') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_auditsaverage_per_date
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_auditsaverage_per_date"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_auditsaverage_per_date"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("average_nr" numeric, "name" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	T.average_nr, 
	T.signed_at::varchar AS name, 
	to_char(T.signed_at,'yyyy')::int AS "year", 
	to_char(T.signed_at,'MM')::int AS "month", 
	to_char(T.signed_at,'dd')::int AS "day",
  to_char(T.signed_at,'IW')::int AS "week"
	FROM (
		WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	
		SELECT AVG(AA.total_score)::numeric AS average_nr, 
		AA.signed_at_1::date AS signed_at
		FROM audits_audit AA 
		INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
		WHERE AA.is_active = true AND AA.is_complete = true AND AA.company_id = _companyid AND AA.signed_by_1_id = _userid
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
		GROUP BY AA.signed_at_1::date 
		ORDER BY AA.signed_at_1::date DESC
	) AS T;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_auditsaverage_per_day
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_auditsaverage_per_day"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_auditsaverage_per_day"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("average_nr" numeric, "name" varchar, "year" int4, "day" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)	
	SELECT 
	AVG(AA.total_score)::decimal AS average_nr, 
	CONCAT('average audit score per day of year ',to_char(AA.signed_at_1,'yyyy-DDD'))::varchar AS name, 
	to_char(AA.signed_at_1,'yyyy')::int AS "year", 
	to_char(AA.signed_at_1,'DDD')::int AS "day" 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.company_id = _companyid AND AA.signed_by_1_id = _userid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
	GROUP BY to_char(AA.signed_at_1,'yyyy-DDD'),to_char(AA.signed_at_1,'yyyy'),to_char(AA.signed_at_1,'DDD')
	ORDER BY to_char(AA.signed_at_1,'yyyy-DDD'), to_char(AA.signed_at_1,'yyyy'),to_char(AA.signed_at_1,'DDD') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_auditsaverage_per_month
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_auditsaverage_per_month"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_auditsaverage_per_month"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("average_nr" numeric, "name" varchar, "year" int4, "month" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)	
	SELECT 
	AVG(AA.total_score)::decimal AS average_nr, 
	CONCAT('average audit score per month of year ' , to_char(AA.signed_at_1,'yyyy-MM'))::varchar AS name, 
	to_char(AA.signed_at_1,'yyyy')::int AS "year",
	to_char(AA.signed_at_1,'MM')::int AS "month"
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.company_id = _companyid AND AA.signed_by_1_id = _userid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
	GROUP BY to_char(AA.signed_at_1,'yyyy-MM'),to_char(AA.signed_at_1,'yyyy'),to_char(AA.signed_at_1,'MM')
	ORDER BY to_char(AA.signed_at_1,'yyyy-MM') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_auditsaverage_per_week
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_auditsaverage_per_week"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_auditsaverage_per_week"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("average_nr" numeric, "name" varchar, "year" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)	
	SELECT AVG(AA.total_score)::decimal AS average_nr, CONCAT('average audit score per week of year ' , 
	to_char(AA.signed_at_1,'yyyy-IW'))::varchar AS name,
	to_char(AA.signed_at_1,'yyyy')::int AS "year",
	to_char(AA.signed_at_1,'IW')::int AS "week"
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.company_id = _companyid AND AA.signed_by_1_id = _userid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
	GROUP BY to_char(AA.signed_at_1,'yyyy-IW'),to_char(AA.signed_at_1,'yyyy'), to_char(AA.signed_at_1,'IW')
	ORDER BY to_char(AA.signed_at_1,'yyyy-IW') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_auditsaverage_per_year
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_auditsaverage_per_year"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_auditsaverage_per_year"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("average_nr" numeric, "name" varchar, "year" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
					SELECT
						a.id,a.name,a.parent_id, a.company_id
					FROM
						companies_area a
					WHERE
						a.id = _areaid
					UNION
					SELECT
						 e.id,e.name,e.parent_id, e.company_id
					FROM
						 companies_area e
					INNER JOIN areas s ON e.parent_id = s.id 
					WHERE e.is_active = true
				)	
	SELECT 
	AVG(AA.total_score)::decimal AS average_nr, 
	CONCAT('average audit score per year ',to_char(AA.signed_at_1,'yyyy'))::varchar AS name, 
	to_char(AA.signed_at_1,'yyyy')::int AS "year" 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.is_complete = true AND AA.company_id = _companyid AND AA.signed_by_1_id = _userid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
	GROUP BY to_char(AA.signed_at_1,'yyyy')
	ORDER BY to_char(AA.signed_at_1,'yyyy') DESC
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_auditscount_per_date
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_auditscount_per_date"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_auditscount_per_date"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	T.count_nr, 
	T.signed_at::varchar AS name, 
	to_char(T.signed_at,'yyyy')::int AS "year", 
	to_char(T.signed_at,'MM')::int AS "month", 
	to_char(T.signed_at,'dd')::int AS "day",
  to_char(T.signed_at,'IW')::int AS "week"
	FROM (
		WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	
		SELECT COUNT(*)::int4 AS count_nr, 
		AA.signed_at_1::date AS signed_at
		FROM audits_audit AA 
		INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
		WHERE AA.is_active = true AND AA.is_complete = true AND AA.company_id = _companyid  AND AA.signed_by_1_id = _userid
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
		GROUP BY AA.signed_at_1::date 
		ORDER BY AA.signed_at_1::date DESC
	) AS T
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_auditscount_per_day
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_auditscount_per_day"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_auditscount_per_day"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "day" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per day of year ',to_char(AA.signed_at_1,'yyyy-DDD'))::varchar AS name, 
	to_char(AA.signed_at_1,'yyyy')::int AS "year", 
	to_char(AA.signed_at_1,'DDD')::int AS "day" 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.company_id = _companyid AND AA.signed_by_1_id = _userid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
	GROUP BY to_char(AA.signed_at_1,'yyyy-DDD'),to_char(AA.signed_at_1,'yyyy'),to_char(AA.signed_at_1,'DDD')
	ORDER BY to_char(AA.signed_at_1,'yyyy-DDD') DESC
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_auditscount_per_month
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_auditscount_per_month"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_auditscount_per_month"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "month" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)	
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per month of year ',to_char(AA.signed_at_1,'yyyy-MM'))::varchar AS name, 
	to_char(AA.signed_at_1,'yyyy')::int AS "year", 
	to_char(AA.signed_at_1,'MM')::int AS "month" 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.company_id = _companyid AND AA.signed_by_1_id = _userid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
	GROUP BY to_char(AA.signed_at_1,'yyyy-MM'),to_char(AA.signed_at_1,'yyyy'),to_char(AA.signed_at_1,'MM')
	ORDER BY to_char(AA.signed_at_1,'yyyy-MM') DESC
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_auditscount_per_week
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_auditscount_per_week"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_auditscount_per_week"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per week of year ',to_char(AA.signed_at_1,'yyyy-IW'))::varchar AS name, 
	to_char(AA.signed_at_1,'yyyy')::int AS "year", 
	to_char(AA.signed_at_1,'IW')::int AS "week" 
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.company_id = _companyid AND signed_by_1_id = _userid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
	GROUP BY to_char(AA.signed_at_1,'yyyy-IW'),to_char(AA.signed_at_1,'yyyy'),to_char(AA.signed_at_1,'IW')
	ORDER BY to_char(AA.signed_at_1,'yyyy-IW') DESC
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_my_auditscount_per_year
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_my_auditscount_per_year"("_companyid" int4, "_userid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_my_auditscount_per_year"("_companyid" int4, "_userid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar, "year" int4) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
			SELECT
				a.id,a.name,a.parent_id, a.company_id
			FROM
				companies_area a
			WHERE
				a.id = _areaid
			UNION
			SELECT
				 e.id,e.name,e.parent_id, e.company_id
			FROM
				 companies_area e
			INNER JOIN areas s ON e.parent_id = s.id 
			WHERE e.is_active = true
		)	
	SELECT COUNT(*)::int4 AS count_nr, 
	CONCAT('count per year ',to_char(AA.signed_at_1,'yyyy'))::varchar AS name, 
	to_char(AA.signed_at_1,'yyyy')::int AS "year"
	FROM audits_audit AA 
	INNER JOIN audits_audittemplate AAT ON AAT.id = AA.template_id
	WHERE AA.is_active = true AND AA.company_id = _companyid AND AA.signed_by_1_id = _userid
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = AAT.area_id) OR _areaid = 0) 
	GROUP BY to_char(AA.signed_at_1,'yyyy')
	ORDER BY to_char(AA.signed_at_1,'yyyy') DESC
	
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_overview_totals
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_overview_totals"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_overview_totals"("_companyid" int4)
  RETURNS TABLE("count_nr" int4, "type" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT T.count_nr::int4, T.type::varchar AS type FROM (
SELECT COUNT(*) AS count_nr, 'checklisttemplates' AS type FROM checklists_checklisttemplate CC WHERE CC.is_active = true AND CC.company_id = _companyid
UNION 
SELECT COUNT(*) AS count_nr, 'audittemplates' AS type FROM audits_audittemplate AA WHERE AA.is_active = true AND AA.company_id = _companyid
UNION 
SELECT COUNT(*) AS count_nr, 'tasktemplates_week' AS type FROM tasks_tasktemplate TT
INNER JOIN tasks_taskrecurrency TR ON TR.template_id = TT.id AND TR.type = 'week' 
WHERE TT.is_active = true AND TT.type = 'task' AND TT.company_id = _companyid
UNION
SELECT COUNT(*) AS count_nr, 'tasktemplates_month' AS type FROM tasks_tasktemplate TT
INNER JOIN tasks_taskrecurrency TR ON TR.template_id = TT.id  AND TR.type = 'month' 
WHERE TT.is_active = true AND TT.type = 'task' AND TT.company_id = _companyid
UNION
SELECT COUNT(*) AS count_nr, 'tasktemplates_norecurrency' AS type FROM tasks_tasktemplate TT
INNER JOIN tasks_taskrecurrency TR ON TR.template_id = TT.id  AND TR.type = 'no recurrency' 
WHERE TT.is_active = true AND TT.type = 'task' AND TT.company_id = _companyid
UNION
SELECT COUNT(*) AS count_nr, 'tasktemplates_shifts' AS type FROM tasks_tasktemplate TT
INNER JOIN tasks_taskrecurrency TR ON TR.template_id = TT.id AND TR.type = 'shifts' 
WHERE TT.is_active = true AND TT.type = 'task' AND TT.company_id = _companyid
UNION 
SELECT COUNT(*) AS count_nr, 'actions_unresolved' AS type FROM actions_action AA 
WHERE AA.is_active = true AND AA.is_resolved = false AND AA.company_id = _companyid
UNION 
SELECT COUNT(*) AS count_nr, 'actions_resolved' AS type FROM actions_action AA 
WHERE AA.is_active = true AND AA.is_resolved = true AND AA.company_id = _companyid
UNION 
SELECT COUNT(*) AS count_nr, 'users' AS type FROM profiles_user PU
WHERE PU.is_active = true AND PU.is_deleted = false AND PU.company_id = _companyid
UNION 
SELECT COUNT(*) AS count_nr, 'checklists_completed' AS type FROM checklists_checklist CC
WHERE CC.is_active = true AND CC.is_complete = true AND CC.company_id = _companyid
UNION 
SELECT COUNT(*) AS count_nr, 'audits_completed' AS type FROM audits_audit AA
WHERE AA.is_active = true AND AA.is_complete = true AND AA.company_id = _companyid
UNION 
SELECT COUNT(*) AS count_nr, 'areas' AS type FROM companies_area CA
WHERE CA.is_active = true AND CA.company_id = _companyid
UNION 
SELECT COUNT(*) AS count_nr, 'shifts' AS type FROM companies_shift CS
WHERE CS.is_active = true AND CS.company_id = _companyid
) AS T ORDER BY T.type;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_taskscount_per_state
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_taskscount_per_state"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_taskscount_per_state"("_companyid" int4, "_timestamp" timestamp, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar) AS $BODY$
	DECLARE 
		_timestamp_seven_day timestamp;
		_timestamp_thirty_day timestamp;
	BEGIN
	_timestamp_seven_day = (_timestamp::date - interval '7 days') + (SELECT first_start FROM get_shift_first_last_for_company(_companyid) WHERE weekday = ((EXTRACT(ISODOW from (_timestamp::date - interval '7 days')::date)::int - 1)::int) LIMIT 1);
	_timestamp_thirty_day =  (_timestamp::date - interval '30 days') + (SELECT first_start FROM get_shift_first_last_for_company(_companyid) WHERE weekday = ((EXTRACT(ISODOW from (_timestamp::date - interval '30 days')::date)::int - 1)::int) LIMIT 1);
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(TT.status, ' total')::varchar AS name FROM tasks_task TT 
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.type = 'task' 
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	WHERE TT.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) AND TT.is_active = true AND TTT.is_active = true
	GROUP BY TT.status
	UNION
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(TT.status, ' last 7 days')::varchar AS name FROM tasks_task TT 
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.type = 'task' 
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	WHERE TT.start_at >= _timestamp_seven_day AND TT.start_at <= _timestamp::date AND TT.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0)  AND TT.is_active = true AND TTT.is_active = true
	GROUP BY TT.status
	UNION
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(TT.status, ' last 30 days')::varchar AS name FROM tasks_task TT 
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.type = 'task' 
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	WHERE TT.start_at >= _timestamp_thirty_day AND TT.start_at <= _timestamp::date AND TT.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0)  AND TT.is_active = true AND TTT.is_active = true
	GROUP BY TT.status
	UNION
	SELECT count(*)::int4 AS count_nr, CONCAT(TT.status, ' today')::varchar FROM tasks_task TT
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
	INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
	WHERE TT.company_id = _companyid AND ((_timestamp BETWEEN TT.start_at AND TT.due_at AND TT.shift_id IS NOT NULL) 
	OR (TTR.type <> 'shifts'
		 AND  TT.start_at >= CASE WHEN (SELECT (_timestamp::time <= first_start)::bool FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)) THEN
											((_timestamp::date - '1 day'::interval) + (SELECT last_start FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)))::timestamp
									 ELSE 
											(_timestamp::date + (SELECT first_start FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)))::timestamp
									 END
		 AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)) THEN
											((_timestamp::date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)))::timestamp
									 ELSE 
											(_timestamp::date + (SELECT last_end FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)))::timestamp
									 END								 
	))
	AND TT.company_id = _companyid 
	AND TTT.is_active = true AND TT.is_active = true
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
	GROUP BY TT.status;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_taskscount_per_state
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_taskscount_per_state"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_taskscount_per_state"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	WITH RECURSIVE areas AS (
		SELECT
			a.id,a.name,a.parent_id, a.company_id
		FROM
			companies_area a
		WHERE
			a.id = _areaid
		UNION
		SELECT
			 e.id,e.name,e.parent_id, e.company_id
		FROM
			 companies_area e
		INNER JOIN areas s ON e.parent_id = s.id 
		WHERE e.is_active = true
	)	
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(TT.status, ' total')::varchar AS name FROM tasks_task TT 
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.type = 'task' 
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	WHERE TT.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) AND TT.is_active = true AND TTT.is_active = true
	GROUP BY TT.status
	UNION
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(TT.status, ' last 7 days')::varchar AS name FROM tasks_task TT 
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.type = 'task' 
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	WHERE TT.start_at >= (NOW()::date - interval '7 days') AND TT.start_at <= NOW()::date AND TT.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0)  AND TT.is_active = true AND TTT.is_active = true
	GROUP BY TT.status
	UNION
	SELECT COUNT(*)::int4 AS count_nr, CONCAT(TT.status, ' last 30 days')::varchar AS name FROM tasks_task TT 
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND TTT.type = 'task' 
	INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
	WHERE TT.start_at >= (NOW()::date - interval '30 days') AND TT.start_at <= NOW()::date AND TT.company_id = _companyid AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0)  AND TT.is_active = true AND TTT.is_active = true
	GROUP BY TT.status
	UNION
	SELECT count(*) AS count_nr, CONCAT(TT.status, ' today')::varchar FROM tasks_task TT
	INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id
	INNER JOIN tasks_taskrecurrency TTR ON TTR.id = TT.recurrency_id 
	WHERE TT.company_id = _companyid AND ((_timestamp BETWEEN TT.start_at AND TT.due_at AND TT.shift_id IS NOT NULL) OR (TT.due_at::date = _timestamp::date AND TTR.type <> 'shifts')) AND TT.company_id = _companyid 
	AND TTT.is_active = true AND TT.is_active = true
	AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
	GROUP BY TT.status; 
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_taskscount_per_state_per_date
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_taskscount_per_state_per_date"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_taskscount_per_state_per_date"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "status" varchar, "name" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
			T.count_nr,
			T.status,
			CONCAT('count ', T.status,' per ', T.dateitem)::varchar AS name,
			to_char(T.dateitem,'yyyy')::int AS "year", 
			to_char(T.dateitem,'MM')::int AS "month", 
			to_char(T.dateitem,'dd')::int AS "day",
			to_char(T.dateitem,'IW')::int AS "week"
		FROM (
				WITH RECURSIVE areas AS (
					SELECT
						a.id,a.name,a.parent_id, a.company_id
					FROM
						companies_area a
					WHERE
						a.id = _areaid
					UNION
					SELECT
						 e.id,e.name,e.parent_id, e.company_id
					FROM
						 companies_area e
					INNER JOIN areas s ON e.parent_id = s.id 
					WHERE e.is_active = true
				)	
				SELECT 
				COUNT(*)::int4 AS count_nr, TT.status, TT.start_date AS dateitem
				FROM tasks_task TT	
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'task' AND TTT.is_active = true	
				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true
				WHERE TT.company_id = _companyid  AND TT.is_active = true AND TT.start_date <= NOW()::date 
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
				AND (
					-- Calculate start time and end time based on specific weekday (can differ per weekday)
					-- For end date (+time) either the start_date + 1 day or the start_date is used. The start_date is the only date that is technically correct based on
					-- normal datetime rules. The task will always start on the start_date. The end, depending on the last end time of the day can be the next day. 
					((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 0 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 1 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 2 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 3 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 4 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 5 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 6 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)))::timestamp
															 END 
					)
				)
				GROUP BY TT.status, TT.start_date
		) T 
		ORDER BY dateitem DESC, status
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_taskscount_per_state_per_date_last_12_months
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_taskscount_per_state_per_date_last_12_months"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_taskscount_per_state_per_date_last_12_months"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "status" varchar, "name" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
			T.count_nr,
			T.status,
			CONCAT('count ', T.status,' per ', T.dateitem)::varchar AS name,
			to_char(T.dateitem,'yyyy')::int AS "year", 
			to_char(T.dateitem,'MM')::int AS "month", 
			to_char(T.dateitem,'dd')::int AS "day",
			to_char(T.dateitem,'IW')::int AS "week"
		FROM (
				WITH RECURSIVE areas AS (
					SELECT
						a.id,a.name,a.parent_id, a.company_id
					FROM
						companies_area a
					WHERE
						a.id = _areaid
					UNION
					SELECT
						 e.id,e.name,e.parent_id, e.company_id
					FROM
						 companies_area e
					INNER JOIN areas s ON e.parent_id = s.id 
					WHERE e.is_active = true
				)	
				SELECT 
				COUNT(*)::int4 AS count_nr, TT.status, TT.start_date::date AS dateitem
				FROM tasks_task TT	
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'task' AND TTT.is_active = true	
				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true 
				WHERE TT.company_id = _companyid AND TT.start_date > (NOW()::date - interval '12 months')::date 
				AND TT.is_active = true  AND TT.start_date <= NOW()::date 
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
				AND (
					-- Calculate start time and end time based on specific weekday (can differ per weekday)
					-- For end date (+time) either the start_date + 1 day or the start_date is used. The start_date is the only date that is technically correct based on
					-- normal datetime rules. The task will always start on the start_date. The end, depending on the last end time of the day can be the next day. 
					((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 0 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 1 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 2 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 3 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 4 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 5 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 6 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)))::timestamp
															 END 
					)
				)
				GROUP BY TT.status, TT.start_date
		) T 
		ORDER BY dateitem DESC, status
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_taskscount_per_state_per_date_last_6_months
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_taskscount_per_state_per_date_last_6_months"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_taskscount_per_state_per_date_last_6_months"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "status" varchar, "name" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
			T.count_nr,
			T.status,
			CONCAT('count ', T.status,' per ', T.dateitem)::varchar AS name,
			to_char(T.dateitem,'yyyy')::int AS "year", 
			to_char(T.dateitem,'MM')::int AS "month", 
			to_char(T.dateitem,'dd')::int AS "day",
			to_char(T.dateitem,'IW')::int AS "week"
		FROM (
				WITH RECURSIVE areas AS (
					SELECT
						a.id,a.name,a.parent_id, a.company_id
					FROM
						companies_area a
					WHERE
						a.id = _areaid
					UNION
					SELECT
						 e.id,e.name,e.parent_id, e.company_id
					FROM
						 companies_area e
					INNER JOIN areas s ON e.parent_id = s.id 
					WHERE e.is_active = true
				)	
				SELECT 
				COUNT(*)::int4 AS count_nr, TT.status, TT.start_date AS dateitem
				FROM tasks_task TT	
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'task' AND TTT.is_active = true	
				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true 
				WHERE TT.company_id = _companyid AND TT.start_date > (NOW()::date - interval '6 months')::date 
				AND TT.is_active = true AND TT.start_date <= NOW()::date 
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
				AND (
					-- Calculate start time and end time based on specific weekday (can differ per weekday)
					-- For end date (+time) either the start_date + 1 day or the start_date is used. The start_date is the only date that is technically correct based on
					-- normal datetime rules. The task will always start on the start_date. The end, depending on the last end time of the day can be the next day. 
					((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 0 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 1 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 2 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 3 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 4 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 5 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 6 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)))::timestamp
															 END 
					)
				)
				GROUP BY TT.status, TT.start_date
		) T 
		ORDER BY dateitem DESC, status
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_taskscount_per_state_per_date_last_month
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_taskscount_per_state_per_date_last_month"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_taskscount_per_state_per_date_last_month"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "status" varchar, "name" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
			T.count_nr,
			T.status,
			CONCAT('count ', T.status,' per ', T.dateitem)::varchar AS name,
			to_char(T.dateitem,'yyyy')::int AS "year", 
			to_char(T.dateitem,'MM')::int AS "month", 
			to_char(T.dateitem,'dd')::int AS "day",
			to_char(T.dateitem,'IW')::int AS "week"
		FROM (
				WITH RECURSIVE areas AS (
					SELECT
						a.id,a.name,a.parent_id, a.company_id
					FROM
						companies_area a
					WHERE
						a.id = _areaid
					UNION
					SELECT
						 e.id,e.name,e.parent_id, e.company_id
					FROM
						 companies_area e
					INNER JOIN areas s ON e.parent_id = s.id 
					WHERE e.is_active = true
				)	
				SELECT 
				COUNT(*)::int AS count_nr, TT.status, TT.start_date AS dateitem
				FROM tasks_task TT	
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'task' AND TTT.is_active = true	
				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true
				WHERE TT.Company_ID = _companyid AND TT.start_date > (NOW()::date - interval '1 months')::date AND TT.is_active = true AND TT.start_date <= NOW()::date
				 AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
				 AND (
					-- Calculate start time and end time based on specific weekday (can differ per weekday)
					-- For end date (+time) either the start_date + 1 day or the start_date is used. The start_date is the only date that is technically correct based on
					-- normal datetime rules. The task will always start on the start_date. The end, depending on the last end time of the day can be the next day. 
					((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 0 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 0)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 1 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 1)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 2 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 2)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 3 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 3)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 4 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 4)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 5 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 5)))::timestamp
															 END 
					)
					OR ((EXTRACT(ISODOW from (TT.start_date::date)::date)::int - 1) = 6 
							AND TT.start_at >= (TT.start_date + (SELECT first_start FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)))::timestamp
							AND TT.due_at <= CASE WHEN (SELECT (last_end <= first_start)::bool FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)) THEN
																	((TT.start_date + '1 day'::interval) + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)))::timestamp
															 ELSE 
																	(TT.start_date + (SELECT last_end FROM get_shift_first_last_for_company_by_weekday(_companyid, 6)))::timestamp
															 END 
					)
				)
				GROUP BY TT.status, TT.start_date 
		) T 
		ORDER BY dateitem DESC, status
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_taskscount_per_state_per_date_test
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_taskscount_per_state_per_date_test"("_companyid" int4, "_areaid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_taskscount_per_state_per_date_test"("_companyid" int4, "_areaid" int4=0)
  RETURNS TABLE("count_nr" int4, "status" varchar, "name" varchar, "year" int4, "month" int4, "day" int4, "week" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
			T.count_nr,
			T.status,
			CONCAT('count ', T.status,' per ', T.dateitem)::varchar AS name,
			to_char(T.dateitem,'yyyy')::int AS "year", 
			to_char(T.dateitem,'MM')::int AS "month", 
			to_char(T.dateitem,'dd')::int AS "day",
			to_char(T.dateitem,'IW')::int AS "week"
		FROM (
				WITH RECURSIVE areas AS (
					SELECT
						a.id,a.name,a.parent_id, a.company_id
					FROM
						companies_area a
					WHERE
						a.id = _areaid
					UNION
					SELECT
						 e.id,e.name,e.parent_id, e.company_id
					FROM
						 companies_area e
					INNER JOIN areas s ON e.parent_id = s.id 
					WHERE e.is_active = true
				)	 
				SELECT 
						COUNT(*)::int4 AS count_nr, TT.status, TT.start_date AS dateitem
				FROM tasks_task TT	
				INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_ID AND TTT.type = 'task' AND TTT.is_active = true	
				INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id AND TTR.is_active = true
				WHERE TT.company_id = _companyid AND TT.is_active = true 
				AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
			  AND TT.start_date <= NOW()::date	
				GROUP BY TT.status, TT.start_date 
				ORDER BY TT.start_date DESC
		) T 
		ORDER BY dateitem DESC, status
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_totals
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_totals"();
CREATE OR REPLACE FUNCTION "public"."report_statistics_totals"()
  RETURNS TABLE("company_nr" int4, "actions_nr" int4, "actioncomment_nr" int4, "audit_nr" int4, "audittemplate_nr" int4, "checklist_nr" int4, "checklisttemplate_nr" int4, "user_nr" int4, "tasks_nr" int4, "tasktemplate_nr" int4, "factoryfeed_nr" int4, "factoryfeedmessage_nr" int4, "comment_nr" int4, "announcement_nr" int4) AS $BODY$BEGIN
	RETURN QUERY
	SELECT 
	(SELECT COUNT(*)::int4 AS Nr FROM companies_company A WHERE A.is_active = true) AS company_nr,
	(SELECT COUNT(*)::int4 AS Nr FROM actions_action A WHERE A.is_active = true) AS actions_nr,
	(SELECT COUNT(*)::int4 AS Nr FROM actions_actioncomment A WHERE A.is_active = true) AS actioncomment_nr,
	(SELECT COUNT(*)::int4 AS Nr FROM audits_audit A WHERE A.is_active = true) AS audit_nr,
	(SELECT COUNT(*)::int4 AS Nr FROM audits_audittemplate A WHERE A.is_active = true) AS audittemplate_nr,
	(SELECT COUNT(*)::int4 AS Nr FROM checklists_checklist A WHERE A.is_active = true) AS checklist_nr,
	(SELECT COUNT(*)::int4 AS Nr FROM checklists_checklisttemplate A WHERE A.is_active = true) AS checklisttemplate_nr,
	(SELECT COUNT(*)::int4 AS Nr FROM profiles_user A WHERE A.is_active = true) AS user_nr,
	(SELECT COUNT(*)::int4 AS Nr FROM tasks_task A WHERE A.is_active = true) AS tasks_nr,
	(SELECT COUNT(*)::int4 AS Nr FROM tasks_tasktemplate A WHERE A.is_active = true AND type = 'task') AS tasktemplate_nr,
	(SELECT COUNT(*)::int4 AS Nr FROM factoryfeeds A WHERE A.is_active = true) AS factoryfeed_nr,
	(SELECT COUNT(*)::int4 AS Nr FROM factoryfeed_messages A WHERE A.is_active = true) AS factoryfeedmessage_nr,
	(SELECT COUNT(*)::int4 AS Nr FROM comments A WHERE A.is_active = true) AS comment_nr,
	(SELECT COUNT(*)::int4 AS Nr FROM announcement A) AS announcement_nr;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_statistics_user_activity_totals
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_statistics_user_activity_totals"("_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."report_statistics_user_activity_totals"("_companyid" int4)
  RETURNS TABLE("count_nr" int4, "user_id" int4, "name" varchar) AS $BODY$BEGIN
	RETURN QUERY
	SELECT R.count_nr::int4, R.user_id, CONCAT(PU.first_name, ' ',PU.last_name)::varchar AS name  FROM (
	SELECT SUM(T.count_nr) AS count_nr, T.user_id FROM (
		SELECT COUNT(*) AS count_nr, AA.created_by_id AS user_id FROM actions_action AA WHERE AA.company_id = _companyid
		GROUP BY AA.created_by_id
		UNION
		SELECT COUNT(*) AS count_nr, AAC.user_id FROM actions_actioncomment AAC 
		INNER JOIN actions_action AA ON AA.id = AAC.action_id AND AA.is_active = true
		WHERE AA.company_id = _companyid
		GROUP BY AAC.user_id
		UNION
		SELECT COUNT(*) AS count_nr, CC.signed_by_1_id AS user_id FROM checklists_checklist CC 
		WHERE CC.company_id = _companyid
		GROUP BY CC.signed_by_1_id
		UNION
		SELECT COUNT(*) AS count_nr, AA.signed_by_1_id AS user_id FROM audits_audit AA 
		WHERE AA.company_id = _companyid
		GROUP BY AA.signed_by_1_id
		UNION
		SELECT COUNT(*) AS count_nr, TT.signed_by_id AS user_id FROM tasks_task TT 
		WHERE TT.recurrency_id IS NOT NULL AND TT.signed_by_id IS NOT NULL AND TT.is_active = true AND company_id = _companyid
		GROUP BY TT.signed_by_id 
	) AS T 
	GROUP BY T.user_id
) AS R
INNER JOIN profiles_user PU ON PU.id = R.user_id AND PU.company_id = _companyid
ORDER BY R.count_nr DESC;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for report_tasks_deviance_scores
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."report_tasks_deviance_scores"("_companyid" int4, "_areaid" int4, "_timespanindays" int4);
CREATE OR REPLACE FUNCTION "public"."report_tasks_deviance_scores"("_companyid" int4, "_areaid" int4=0, "_timespanindays" int4=0)
  RETURNS TABLE("count_nr" int4, "count_ok" int4, "count_notok" int4, "count_skipped" int4, "count_todo" int4, "percentage_ok" numeric, "percentage_notok" numeric, "percentage_skipped" numeric, "percentage_todo" numeric, "task_template_id" int4, "task_template_name" varchar, "action_count" int4, "action_count_done" int4) AS $BODY$
	DECLARE
		_timestamp timestamp;
	BEGIN
	_timestamp = NOW();
	RETURN QUERY
	SELECT
			T.count_nr, 
			T.count_ok,
			T.count_notok, 
			T.count_skipped, 
			T.count_todo, 
			(T.count_ok::numeric / T.count_nr::numeric * 100)::numeric AS percentage_ok, 
			(T.count_notok::numeric / T.count_nr::numeric * 100)::numeric AS percentage_notok, 
			(T.count_skipped::numeric / T.count_nr::numeric * 100)::numeric AS percentage_skipped,
			(T.count_todo::numeric / T.count_nr::numeric * 100)::numeric AS percentage_todo,
			T.task_template_id,
			T.task_template_name,
			(SELECT Count(A.id)::int4 FROM actions_action A WHERE (A.task_template_id = T.task_template_id) AND A.is_active = true) AS action_count,
			(SELECT Count(A.id)::int4 FROM actions_action A WHERE (A.task_template_id = T.task_template_id) AND A.is_resolved = true AND A.is_active = true) AS action_count_done
	FROM (
		WITH RECURSIVE areas AS (
				SELECT
					a.id,a.name,a.parent_id, a.company_id
				FROM
					companies_area a
				WHERE
					a.id = _areaid
				UNION
				SELECT
					 e.id,e.name,e.parent_id, e.company_id
				FROM
					 companies_area e
				INNER JOIN areas s ON e.parent_id = s.id 
				WHERE e.is_active = true
		)	
		SELECT 
			COUNT(*)::int4 AS count_nr,
			SUM(CASE WHEN status = 'ok' THEN 1 ELSE 0 END)::int4 AS count_ok,
			SUM(CASE WHEN status = 'not ok' THEN 1 ELSE 0 END)::int4 AS count_notok,
			SUM(CASE WHEN status = 'skipped' THEN 1 ELSE 0 END)::int4 AS count_skipped,
			SUM(CASE WHEN status = 'todo' THEN 1 ELSE 0 END)::int4 AS count_todo,
			TTT.id AS task_template_id,
			TTT.name AS task_template_name
		FROM tasks_task TT
		INNER JOIN tasks_tasktemplate TTT ON TTT.id = TT.template_id AND type = 'task'
		INNER JOIN tasks_taskrecurrency TTR ON TTR.template_id = TTT.id
		WHERE TT.company_id = _companyid AND TT.is_active = true AND TTT.is_active = true
		AND (EXISTS (SELECT areas.id FROM areas WHERE areas.id = TTR.area_id) OR _areaid = 0) 
		AND (TT.start_at >= CASE WHEN (SELECT (_timestamp::time <= first_start)::bool FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)) THEN
											(((_timestamp::date - '1 day'::interval) + (SELECT last_start FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)))::timestamp - '1 day'::interval - CONCAT(_timespanindays,' days')::interval)
									 ELSE 
											((_timestamp::date + (SELECT first_start FROM get_shift_first_last_on_day_by_timestamp(_companyid, _timestamp)))::timestamp - CONCAT(_timespanindays,' days')::interval)
									 END 
									 OR _timespanindays = 0)
		AND TT.start_at < _timestamp
		GROUP BY TTT.id, TTT.name
		ORDER BY TTT.id DESC
	) AS T 
;
END$BODY$
  LANGUAGE plpgsql STABLE
  COST 100
  ROWS 1000;

-- ----------------------------
-- Function structure for set_action_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_action_active"("_companyid" int4, "_id" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_action_active"("_companyid" int4, "_id" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE actions_action SET is_active = _active, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_action_resolved
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_action_resolved"("_companyid" int4, "_id" int4, "_isresolved" bool);
CREATE OR REPLACE FUNCTION "public"."set_action_resolved"("_companyid" int4, "_id" int4, "_isresolved" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE actions_action SET is_resolved = _isresolved, modified_at = now()::timestamp, resolved_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_action_task
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_action_task"("_companyid" int4, "_id" int4, "_taskid" int4);
CREATE OR REPLACE FUNCTION "public"."set_action_task"("_companyid" int4, "_id" int4, "_taskid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE actions_action SET task_id = _taskid, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_action_viewed
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_action_viewed"("_companyid" int4, "_id" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."set_action_viewed"("_companyid" int4, "_id" int4, "_userid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   INSERT INTO actions_actionviewed (user_id, action_id) values(_userid, _id) ON CONFLICT (user_id,action_id) DO NOTHING;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_actioncomment_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_actioncomment_active"("_companyid" int4, "_id" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_actioncomment_active"("_companyid" int4, "_id" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE actions_actioncomment SET is_active = _active, modified_at = now()::timestamp FROM actions_action 
	 WHERE actions_action.id = actions_actioncomment.action_id AND actions_actioncomment.id = _id AND actions_action.company_id = _companyid; 
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_actioncomment_viewed
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_actioncomment_viewed"("_companyid" int4, "_id" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."set_actioncomment_viewed"("_companyid" int4, "_id" int4, "_userid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   INSERT INTO actions_actioncommentviewed (user_id, comment_id) values(_userid, _id) ON CONFLICT (user_id,comment_id) DO NOTHING;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_actioncomment_viewed_all
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_actioncomment_viewed_all"("_companyid" int4, "_actionid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."set_actioncomment_viewed_all"("_companyid" int4, "_actionid" int4, "_userid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   INSERT INTO actions_actioncommentviewed(comment_id, user_id) 
	SELECT AAC.id, _userid FROM actions_actioncomment AAC
	INNER JOIN actions_action AA ON AA.id = AAC.action_id
	WHERE AAC.id NOT IN (SELECT AACV.comment_id FROM actions_actioncommentviewed AACV WHERE user_id = _userid) 
	AND AAC.action_id = _actionid AND AA.company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_allowed_areas
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_allowed_areas"("_companyid" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."set_allowed_areas"("_companyid" int4, "_userid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  _rowcount_deletes integer;
  _rowcount_inserts integer;
BEGIN
  -- remove items that are not added anymore
	DELETE FROM profiles_user_allowed_areas PUAS WHERE PUAS.user_id = _userid AND area_ID NOT IN (
			SELECT id FROM (
				WITH RECURSIVE Areas AS (
					 SELECT
							A.id, A.name, A.parent_id, A.company_id
					 FROM
							companies_area A
							INNER JOIN profiles_user_areas PUA ON PUA.area_id = A.id AND PUA.user_id = _userid
					 WHERE
							A.company_id = _companyid
					 UNION
							SELECT
								 E.id, E.name, E.parent_id, E.company_id
							FROM
								 companies_area E
							INNER JOIN Areas s ON e.parent_id = s.id
				) SELECT
					 AE.id, AE.name, AE.parent_id
				FROM
					 Areas AE
					 WHERE AE.company_id = _companyid
		 ) AS T
	);
	GET DIAGNOSTICS _rowcount_deletes = ROW_COUNT;
	 -- add new items
	INSERT INTO profiles_user_allowed_areas (user_id, area_id)
			 SELECT _userid, id FROM (
				WITH RECURSIVE Areas AS (
					 SELECT
							A.id, A.name, A.parent_id, A.company_id
					 FROM
							companies_area A
							INNER JOIN profiles_user_areas PUA ON PUA.area_id = A.id AND PUA.user_id = _userid
					 WHERE
							A.company_id = _companyid
					 UNION
							SELECT
								 E.id, E.name, E.parent_id, E.company_id
							FROM
								 companies_area E
							INNER JOIN Areas s ON e.parent_id = s.id
				) SELECT
					 AE.id, AE.name, AE.parent_id
				FROM
					 Areas AE
					 WHERE AE.company_id = _companyid
					 AND AE.id NOT IN (SELECT area_id FROM profiles_user_allowed_areas WHERE user_id = _userid) -- add only items that are not already added
		 ) AS T;
		 GET DIAGNOSTICS _rowcount_inserts = ROW_COUNT;
		 RETURN _rowcount_deletes + _rowcount_inserts;
	END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_area_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_area_active"("_companyid" int4, "_id" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_area_active"("_companyid" int4, "_id" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE companies_area SET is_active = _active, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_audit_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_audit_active"("_companyid" int4, "_id" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_audit_active"("_companyid" int4, "_id" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE audits_audit SET is_active = _active, modified_at = now()::timestamp WHERE id = "_id" AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_audit_calculated_score
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_audit_calculated_score"("_companyid" int4, "_id" int4);
CREATE OR REPLACE FUNCTION "public"."set_audit_calculated_score"("_companyid" int4, "_id" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE audits_audit SET total_score = calculate_audit_total_score(_id), modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_audit_score
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_audit_score"("_companyid" int4, "_id" int4, "_score" int4);
CREATE OR REPLACE FUNCTION "public"."set_audit_score"("_companyid" int4, "_id" int4, "_score" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE audits_audit SET total_score = _score, modified_at = now()::timestamp WHERE id = "_id" AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_audittemplate_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_audittemplate_active"("_companyid" int4, "_id" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_audittemplate_active"("_companyid" int4, "_id" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE audits_audittemplate SET is_active = _active, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_checklist_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_checklist_active"("_companyid" int4, "_id" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_checklist_active"("_companyid" int4, "_id" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE checklists_checklist SET is_active = _active, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_checklisttemplate_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_checklisttemplate_active"("_companyid" int4, "_id" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_checklisttemplate_active"("_companyid" int4, "_id" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE checklists_checklisttemplate SET is_active = _active, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_comment_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_comment_active"("_id" int4, "_companyid" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_comment_active"("_id" int4, "_companyid" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE comments SET 
	is_active = _active,
	modified_at = NOW()
	WHERE id = _id AND company_id = _companyid;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_comment_viewed
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_comment_viewed"("_companyid" int4, "_id" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."set_comment_viewed"("_companyid" int4, "_id" int4, "_userid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   INSERT INTO comments_commentviewed (user_id, comment_id) values(_userid, _id) ON CONFLICT (user_id,comment_id) DO NOTHING;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_company_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_company_active"("_companyid" int4, "_id" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_company_active"("_companyid" int4, "_id" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE companies_company SET is_active = _active, modified_at = now()::timestamp WHERE id = _id AND id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_company_roles
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_company_roles"("_companyid" int4, "_basic_role_display_name" varchar, "_manager_role_display_name" varchar, "_shift_leader_role_display_name" varchar);
CREATE OR REPLACE FUNCTION "public"."set_company_roles"("_companyid" int4, "_basic_role_display_name" varchar, "_manager_role_display_name" varchar, "_shift_leader_role_display_name" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE companies_company 
	 SET modified_at = now()::timestamp,
	    basic_role_display_name = _basic_role_display_name,
			manager_role_display_name = _manager_role_display_name,
			shift_leader_role_display_name = _shift_leader_role_display_name
   WHERE id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_factoryfeed_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_factoryfeed_active"("_id" int4, "_companyid" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_factoryfeed_active"("_id" int4, "_companyid" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE factoryfeeds SET 
	is_active = _active
	WHERE id = _id AND company_id = _companyid;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_factoryfeedmessage_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_factoryfeedmessage_active"("_id" int4, "_companyid" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_factoryfeedmessage_active"("_id" int4, "_companyid" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE factoryfeed_messages SET 
	is_active = _active,
	modified_at = NOW()
	WHERE id = _id AND company_id = _companyid;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_factoryfeedmessage_liked
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_factoryfeedmessage_liked"("_companyid" int4, "_id" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."set_factoryfeedmessage_liked"("_companyid" int4, "_id" int4, "_userid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   INSERT INTO factoryfeed_messageliked (user_id, factoryfeedmessage_id) values(_userid, _id) ON CONFLICT (user_id, factoryfeedmessage_id) DO NOTHING;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_factoryfeedmessage_unliked
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_factoryfeedmessage_unliked"("_companyid" int4, "_id" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."set_factoryfeedmessage_unliked"("_companyid" int4, "_id" int4, "_userid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   DELETE FROM factoryfeed_messagesliked WHERE user_id = _userid AND factoryfeedmessage_id = _id AND factoryfeedmessage_id IN (SELECT FM.id FROM factoryfeed_messages FM WHERE FM.id = _id AND FM.company_id = _companyid);
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_factoryfeedmessage_viewed
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_factoryfeedmessage_viewed"("_companyid" int4, "_id" int4, "_userid" int4);
CREATE OR REPLACE FUNCTION "public"."set_factoryfeedmessage_viewed"("_companyid" int4, "_id" int4, "_userid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   INSERT INTO factoryfeed_messageviewed (user_id, factoryfeedmessage_id) values(_userid, _id) ON CONFLICT (user_id, factoryfeedmessage_id) DO NOTHING;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_profile_user_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_profile_user_active"("_companyid" int4, "_id" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_profile_user_active"("_companyid" int4, "_id" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE profiles_user SET is_active = _active, modified_at = now()::timestamp WHERE id = "_id" AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_random_authtoken
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_random_authtoken"("_username" varchar, "_password" varchar);
CREATE OR REPLACE FUNCTION "public"."set_random_authtoken"("_username" varchar, "_password" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
   _generated_authtoken varchar;
	 _userid int;
	 _tokenexists bool;
	 _tokenrecordexists bool;
	 _rowcount int4;
BEGIN
		SELECT id INTO _userid FROM profiles_user WHERE username = _username AND password = _password;
		RAISE NOTICE '_userid %', _userid;
		IF _userid IS NOT NULL AND _userid > 0 THEN
			LOOP
					-- generate a random guid
					SELECT generate_uid(cast(to_char((current_timestamp)::TIMESTAMP,'yyyymmddhhmiss') as int8), 40, MD5((_userid+1000000*random())::VARCHAR)) INTO _generated_authtoken;
					RAISE NOTICE '_generated_authtoken %', _generated_authtoken;
					-- check if guid does not already exists so no collision will be made.
					SELECT (COUNT(*) > 0)::bool INTO _tokenexists FROM authtoken_token WHERE key = _generated_authtoken;
					RAISE NOTICE '_tokenexists %', _tokenexists;
					IF NOT _tokenexists THEN
						-- check if there is an auth token currenlty available
						SELECT (COUNT(*) > 0)::bool INTO _tokenrecordexists FROM authtoken_token WHERE user_id = _userid;
						RAISE NOTICE '_tokenrecordexists %', _tokenrecordexists;
						IF NOT _tokenrecordexists THEN
							-- insert new record if there is no authtoken
							INSERT INTO authtoken_token (key, created, user_id) VALUES (_generated_authtoken, now()::timestamp, _userid);
							GET DIAGNOSTICS _rowcount = ROW_COUNT;
						ELSE 
							-- add token to token graveyard
							INSERT INTO profiles_expiredtoken (key, created_at, user_id) 
							SELECT AA.key, now()::timestamp, AA.user_id FROM authtoken_token AA
							INNER JOIN profiles_user PU ON PU.id = AA.user_id
							WHERE PU.username = _username AND PU.password = _password AND PU.id = _userid;
							-- recycle record with new authtoken
							UPDATE authtoken_token ATT
							SET key = _generated_authtoken, created = now()::timestamp
							FROM profiles_user PU
							WHERE PU.id = ATT.user_id AND PU.username = _username AND PU.password = _password AND PU.id = _userid;
							GET DIAGNOSTICS _rowcount = ROW_COUNT;
						END IF;
						RAISE NOTICE 'EXIT';
						EXIT;
					END IF;
			END LOOP;
		END IF;
    RETURN _rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_random_authtoken_if_expired
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_random_authtoken_if_expired"("_username" varchar, "_password" varchar);
CREATE OR REPLACE FUNCTION "public"."set_random_authtoken_if_expired"("_username" varchar, "_password" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
   _generated_authtoken varchar;
	 _userid int;
	 _tokenexists bool;
	 _tokenrecordexists bool;
	 _rowcount int4;
	 _existingtokenexpired bool;
BEGIN
		SELECT id INTO _userid FROM profiles_user WHERE username = _username AND password = _password;
		RAISE NOTICE '_userid %', _userid;
		-- check existing token older then 8 hours or non existant
		SELECT (COUNT(*) = 0)::bool INTO _existingtokenexpired FROM authtoken_token WHERE user_id = _userid AND created::timestamp > (NOW() - '8 hours'::interval)::timestamp;
		IF _existingtokenexpired THEN
			IF _userid IS NOT NULL AND _userid > 0 THEN
				LOOP
						-- generate a random guid
						SELECT generate_uid(cast(to_char((current_timestamp)::TIMESTAMP,'yyyymmddhhmiss') as int8), 40, MD5((_userid+1000000*random())::VARCHAR)) INTO _generated_authtoken;
						-- RAISE NOTICE '_generated_authtoken %', _generated_authtoken;
						-- check if guid does not already exists so no collision will be made.
						SELECT (COUNT(*) > 0)::bool INTO _tokenexists FROM authtoken_token WHERE key = _generated_authtoken;
						RAISE NOTICE '_tokenexists %', _tokenexists;
						IF NOT _tokenexists THEN
							-- check if there is an auth token currenlty available
							SELECT (COUNT(*) > 0)::bool INTO _tokenrecordexists FROM authtoken_token WHERE user_id = _userid;
							RAISE NOTICE '_tokenrecordexists %', _tokenrecordexists;
							IF NOT _tokenrecordexists THEN
								-- insert new record if there is no authtoken
								INSERT INTO authtoken_token (key, created, user_id) VALUES (_generated_authtoken, now()::timestamp, _userid);
								GET DIAGNOSTICS _rowcount = ROW_COUNT;
							ELSE 
								-- add token to token graveyard
								INSERT INTO profiles_expiredtoken (key, created_at, user_id) 
								SELECT AA.key, now()::timestamp, AA.user_id FROM authtoken_token AA
								INNER JOIN profiles_user PU ON PU.id = AA.user_id
								WHERE PU.username = _username AND PU.password = _password AND PU.id = _userid;
								-- recycle record with new authtoken
								UPDATE authtoken_token ATT
								SET key = _generated_authtoken, created = now()::timestamp
								FROM profiles_user PU
								WHERE PU.id = ATT.user_id AND PU.username = _username AND PU.password = _password AND PU.id = _userid;
								GET DIAGNOSTICS _rowcount = ROW_COUNT;
							END IF;
							RAISE NOTICE 'EXIT';
							EXIT;
						END IF;
				END LOOP;
			END IF;
		ELSE
			_rowcount = 1; -- not expired...so remain calm and continue;
		END IF;
    RETURN _rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_shift_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_shift_active"("_companyid" int4, "_id" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_shift_active"("_companyid" int4, "_id" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE companies_shift SET is_active = _active, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_task_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_task_active"("_companyid" int4, "_id" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_task_active"("_companyid" int4, "_id" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE tasks_task SET is_active = _active, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_task_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_task_active"("_companyid" int4, "_id" int8, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_task_active"("_companyid" int4, "_id" int8, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE tasks_task SET is_active = _active, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_task_audit_status
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_task_audit_status"("_companyid" int4, "_id" int8, "_status" varchar, "_score" int4);
CREATE OR REPLACE FUNCTION "public"."set_task_audit_status"("_companyid" int4, "_id" int8, "_status" varchar, "_score" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
	_weight numeric(9,1);
	_deviance integer;
	_maxtaskscore integer;
	_maxscore integer;
	_totalscore integer;
BEGIN
	 SELECT TT.weight, AA.max_task_score, (_score * TT.weight)::int, (AA.max_task_score * TT.weight)::int 
		INTO _weight, _maxtaskscore, _totalscore, _maxscore FROM tasks_task T 
	 INNER JOIN tasks_tasktemplate TT ON TT.id = T.template_ID AND type = 'audit'
	 INNER JOIN audits_audittemplate_tasks AAT ON AAT.tasktemplate_id = TT.id
	 INNER JOIN audits_audittemplate AA ON AA.id = AAT.audittemplate_id
	 WHERE T.id = _id;
   UPDATE tasks_task SET status = _status, modified_at = now()::timestamp, score = _score, total_score = _totalscore::int4, max_score = _maxscore::int4,  deviance = (_maxscore - _totalscore)::int4
	 WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_task_audit_status
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_task_audit_status"("_companyid" int4, "_id" int4, "_status" varchar, "_score" int4);
CREATE OR REPLACE FUNCTION "public"."set_task_audit_status"("_companyid" int4, "_id" int4, "_status" varchar, "_score" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
	_weight numeric(9,1);
	_deviance integer;
	_maxtaskscore integer;
	_maxscore integer;
	_totalscore integer;
BEGIN
	 SELECT TT.weight, AA.max_task_score, (_score * TT.weight)::int, (AA.max_task_score * TT.weight)::int 
		INTO _weight, _maxtaskscore, _totalscore, _maxscore FROM tasks_task T 
	 INNER JOIN tasks_tasktemplate TT ON TT.id = T.template_ID AND type = 'audit'
	 INNER JOIN audits_audittemplate_tasks AAT ON AAT.tasktemplate_id = TT.id
	 INNER JOIN audits_audittemplate AA ON AA.id = AAT.audittemplate_id
	 WHERE T.id = _id;
   UPDATE tasks_task SET status = _status, modified_at = now()::timestamp, score = _score, total_score = _totalscore::int4, max_score = _maxscore::int4,  deviance = (_maxscore - _totalscore)::int4
	 WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_task_modified
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_task_modified"("_id" int4, "_companyid" int4);
CREATE OR REPLACE FUNCTION "public"."set_task_modified"("_id" int4, "_companyid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE tasks_task SET 
	modified_at = now()::timestamp 
	WHERE id = _id AND company_id = _companyid;
	GET DIAGNOSTICS _rowcount = ROW_COUNT;
	RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_task_realizedtime
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_task_realizedtime"("_id" int8, "_companyid" int4, "_realizedbyid" int4, "_timerealized" int4);
CREATE OR REPLACE FUNCTION "public"."set_task_realizedtime"("_id" int8, "_companyid" int4, "_realizedbyid" int4, "_timerealized" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE tasks_task SET 
	time_realized_by_id = _realizedbyid,
	time_taken = _timerealized,
	modified_at = NOW()
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_task_realizedtime
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_task_realizedtime"("_id" int4, "_companyid" int4, "_realizedbyid" int4, "_timerealized" int4);
CREATE OR REPLACE FUNCTION "public"."set_task_realizedtime"("_id" int4, "_companyid" int4, "_realizedbyid" int4, "_timerealized" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	UPDATE tasks_task SET 
	time_realized_by_id = _realizedbyid,
	time_taken = _timerealized,
	modified_at = NOW()
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_task_status
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_task_status"("_companyid" int4, "_id" int8, "_status" varchar);
CREATE OR REPLACE FUNCTION "public"."set_task_status"("_companyid" int4, "_id" int8, "_status" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE tasks_task SET status = _status, signed_at = now()::timestamp, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_task_status
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_task_status"("_companyid" int4, "_id" int4, "_status" varchar);
CREATE OR REPLACE FUNCTION "public"."set_task_status"("_companyid" int4, "_id" int4, "_status" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE tasks_task SET status = _status, signed_at = now()::timestamp,modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_task_status
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_task_status"("_companyid" int4, "_id" int4, "_userid" int4, "_status" varchar, "_signedatutc" timestamp);
CREATE OR REPLACE FUNCTION "public"."set_task_status"("_companyid" int4, "_id" int4, "_userid" int4, "_status" varchar, "_signedatutc" timestamp)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE tasks_task SET status = _status, modified_at = now()::timestamp, signed_at = _signedatutc::timestamp, signed_by_id = _userid WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 IF rowcount > 0 THEN
			INSERT INTO tasks_taskstatusrecord (status, signed_at, signed_by_id, task_id) VALUES (_status, now()::timestamp, _userid, _id);
	 END IF;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_task_status
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_task_status"("_companyid" int4, "_id" int4, "_userid" int4, "_status" varchar);
CREATE OR REPLACE FUNCTION "public"."set_task_status"("_companyid" int4, "_id" int4, "_userid" int4, "_status" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE tasks_task SET status = _status, modified_at = now()::timestamp, signed_at = now()::timestamp, signed_by_id = _userid WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 IF rowcount > 0 THEN
			INSERT INTO tasks_taskstatusrecord (status, signed_at, signed_by_id, task_id) VALUES (_status, now()::timestamp, _userid, _id);
	 END IF;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_taskrecurrency_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_taskrecurrency_active"("_companyid" int4, "_id" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_taskrecurrency_active"("_companyid" int4, "_id" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE tasks_taskrecurrency SET is_active = _active, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_tasktemplate_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_tasktemplate_active"("_companyid" int4, "_id" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_tasktemplate_active"("_companyid" int4, "_id" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE tasks_tasktemplate SET is_active = _active, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_tasktemplate_auditrelation
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_tasktemplate_auditrelation"("_companyid" int4, "_tasktemplateid" int4, "_audittemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."set_tasktemplate_auditrelation"("_companyid" int4, "_tasktemplateid" int4, "_audittemplateid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  _rowcount integer;
BEGIN
	 --check if record exitst, if not it can be created. 
	 IF (SELECT COUNT(AAT.*)::int4 FROM audits_audittemplate_tasks AAT WHERE AAT.audittemplate_id = _audittemplateid AND AAT.tasktemplate_id = _tasktemplateid) = 0 THEN
			 INSERT INTO audits_audittemplate_tasks (audittemplate_id, tasktemplate_id) 
			 SELECT AAT.id AS audittemplate_id, TTT.id AS tasktemplate_id FROM audits_audittemplate AAT, tasks_tasktemplate TTT 
			 WHERE AAT.id = _audittemplateid AND AAT.company_id = _companyid AND TTT.id = _tasktemplateid AND TTT.company_id = _companyid;
			 GET DIAGNOSTICS _rowcount = ROW_COUNT;
			 RETURN _rowcount;
	 ELSE 
			 _rowcount = 0;
	 END IF;
	 RETURN _rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_tasktemplate_checklistrelation
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_tasktemplate_checklistrelation"("_companyid" int4, "_tasktemplateid" int4, "_checklisttemplateid" int4);
CREATE OR REPLACE FUNCTION "public"."set_tasktemplate_checklistrelation"("_companyid" int4, "_tasktemplateid" int4, "_checklisttemplateid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  _rowcount integer;
BEGIN
	 --id, checklisttemplate_id, tasktemplate_id
	 IF (SELECT COUNT(CCT.*)::int4 FROM checklists_checklisttemplate_tasks CCT WHERE CCT.checklisttemplate_id = _checklisttemplateid AND CCT.tasktemplate_id = _tasktemplateid) = 0 THEN
			 INSERT INTO checklists_checklisttemplate_tasks (checklisttemplate_id, tasktemplate_id) 
			 SELECT CCT.id AS checklisttemplate_id, TTT.id AS tasktemplate_id FROM checklists_checklisttemplate CCT, tasks_tasktemplate TTT 
			 WHERE CCT.id = _checklisttemplateid AND CCT.company_id = _companyid AND TTT.id = _tasktemplateid AND TTT.company_id = _companyid;
			 GET DIAGNOSTICS _rowcount = ROW_COUNT;
			 RETURN _rowcount;
	 ELSE 
			 _rowcount = 0;
	 END IF;
	 RETURN _rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_tasktemplatestep_active
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_tasktemplatestep_active"("_companyid" int4, "_id" int4, "_active" bool);
CREATE OR REPLACE FUNCTION "public"."set_tasktemplatestep_active"("_companyid" int4, "_id" int4, "_active" bool)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE tasks_tasktemplatestep SET is_active = _active, modified_at = now()::timestamp 
	 FROM tasks_tasktemplate  
	 WHERE tasks_tasktemplate.id = tasks_tasktemplatestep.template_id AND tasks_tasktemplatestep.id = _id AND tasks_tasktemplate.company_id = _companyid; --tasks_templatestep does not have a company_id?
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_user_lastloggedindate
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_user_lastloggedindate"("_id" int4);
CREATE OR REPLACE FUNCTION "public"."set_user_lastloggedindate"("_id" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE profiles_user SET last_login = now()::timestamp WHERE id = _id;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
     RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_user_successor
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_user_successor"("_companyid" int4, "_userid" int4, "_successorid" int4);
CREATE OR REPLACE FUNCTION "public"."set_user_successor"("_companyid" int4, "_userid" int4, "_successorid" int4)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
	rowcountactions integer;
BEGIN
	UPDATE profiles_user SET successor_id = _successorid WHERE company_id = _companyid AND id = _userid;
	GET DIAGNOSTICS rowcount = ROW_COUNT;
	INSERT INTO actions_action_assigned_users (action_id, user_id)
	SELECT AA.id, _successorid FROM actions_action AA WHERE AA.company_id = _companyid AND AA.created_by_id = _userid AND AA.id NOT IN (SELECT AAA.action_id FROM actions_action_assigned_users AAA WHERE AAA.user_id = _successorid);
	GET DIAGNOSTICS rowcountactions = ROW_COUNT;
  RETURN rowcount + rowcountactions;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_userprofile
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_userprofile"("_companyid" int4, "_id" int4, "_email" varchar, "_firstname" varchar, "_lastname" varchar, "_picture" varchar);
CREATE OR REPLACE FUNCTION "public"."set_userprofile"("_companyid" int4, "_id" int4, "_email" varchar, "_firstname" varchar, "_lastname" varchar, "_picture" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE profiles_user SET email = _email, first_name = _firstname, last_name = _lastname, picture = _picture,modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
     RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_userprofile
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_userprofile"("_companyid" int4, "_id" int4, "_email" varchar, "_firstname" varchar, "_lastname" varchar, "_picture" varchar, "_username" varchar);
CREATE OR REPLACE FUNCTION "public"."set_userprofile"("_companyid" int4, "_id" int4, "_email" varchar, "_firstname" varchar, "_lastname" varchar, "_picture" varchar, "_username" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE profiles_user SET email = _email, first_name = _firstname, last_name = _lastname, picture = _picture, username = _username,  modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
     RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_userprofile
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_userprofile"("_companyid" int4, "_id" int4, "_email" varchar, "_firstname" varchar, "_lastname" varchar);
CREATE OR REPLACE FUNCTION "public"."set_userprofile"("_companyid" int4, "_id" int4, "_email" varchar, "_firstname" varchar, "_lastname" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE profiles_user SET email = _email,first_name = _firstname,last_name = _lastname, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
     RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for set_userprofile_password
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."set_userprofile_password"("_companyid" int4, "_id" int4, "_password" varchar);
CREATE OR REPLACE FUNCTION "public"."set_userprofile_password"("_companyid" int4, "_id" int4, "_password" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
DECLARE
  rowcount integer;
BEGIN
   UPDATE profiles_user SET password = _password, modified_at = now()::timestamp WHERE id = _id AND company_id = _companyid;
   GET DIAGNOSTICS rowcount = ROW_COUNT;
	 RETURN rowcount;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for sign_audit
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."sign_audit"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signedbyid2" int4, "_signature1" varchar, "_signature2" varchar, "_signedby1" varchar, "_signedby2" varchar, "_signedat" timestamp);
CREATE OR REPLACE FUNCTION "public"."sign_audit"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signedbyid2" int4, "_signature1" varchar, "_signature2" varchar, "_signedby1" varchar, "_signedby2" varchar, "_signedat" timestamp)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	--NOTE! _signedbyid2 and _signedby1 are not used for now
	UPDATE audits_audit SET 
is_complete = true,
signature_1 = _signature1, 
signature_2 = _signature2, 
signed_at_1 = _signedat, 
signed_at_2 = _signedat, 
signed_by_1_id = _signedbyid1, 
signed_by_2 = _signedby2, 
modified_at = now()::timestamp,
total_score = calculate_audit_score(_id)
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for sign_audit
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."sign_audit"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signature1" varchar, "_signedby1" varchar);
CREATE OR REPLACE FUNCTION "public"."sign_audit"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signature1" varchar, "_signedby1" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	--NOTE! _signedbyid2 and _signedby1 are not used for now
	UPDATE audits_audit SET 
is_complete = true,
signature_1 = _signature1, 
signed_at_1 = now()::timestamp, 
signed_by_1_id = _signedbyid1, 
modified_at = now()::timestamp,
total_score = calculate_audit_score(_id)
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for sign_audit
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."sign_audit"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signedbyid2" int4, "_signature1" varchar, "_signature2" varchar, "_signedby1" varchar, "_signedby2" varchar);
CREATE OR REPLACE FUNCTION "public"."sign_audit"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signedbyid2" int4, "_signature1" varchar, "_signature2" varchar, "_signedby1" varchar, "_signedby2" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	--NOTE! _signedbyid2 and _signedby1 are not used for now
	UPDATE audits_audit SET 
is_complete = true,
signature_1 = _signature1, 
signature_2 = _signature2, 
signed_at_1 = now()::timestamp, 
signed_at_2 = now()::timestamp, 
signed_by_1_id = _signedbyid1, 
signed_by_2 = _signedby2, 
modified_at = now()::timestamp,
total_score = calculate_audit_score(_id)
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for sign_audit
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."sign_audit"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signature1" varchar, "_signedby1" varchar, "_signedat" timestamp);
CREATE OR REPLACE FUNCTION "public"."sign_audit"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signature1" varchar, "_signedby1" varchar, "_signedat" timestamp)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	--NOTE! _signedbyid2 and _signedby1 are not used for now
	UPDATE audits_audit SET 
is_complete = true,
signature_1 = _signature1, 
signed_at_1 = _signedat, 
signed_by_1_id = _signedbyid1, 
modified_at = now()::timestamp,
total_score = calculate_audit_score(_id)
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for sign_checklist
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."sign_checklist"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signature1" varchar, "_signedby1" varchar, "_signedat" timestamp);
CREATE OR REPLACE FUNCTION "public"."sign_checklist"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signature1" varchar, "_signedby1" varchar, "_signedat" timestamp)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	--NOTE! _signedbyid2 and _signedby1 are not used for now
	UPDATE checklists_checklist SET 
is_complete = true,
signature_1 = _signature1, 
signed_at_1 = _signedat, 
signed_by_1_id = _signedbyid1, 
modified_at = now()::timestamp  
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for sign_checklist
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."sign_checklist"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signedbyid2" int4, "_signature1" varchar, "_signature2" varchar, "_signedby1" varchar, "_signedby2" varchar);
CREATE OR REPLACE FUNCTION "public"."sign_checklist"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signedbyid2" int4, "_signature1" varchar, "_signature2" varchar, "_signedby1" varchar, "_signedby2" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	--NOTE! _signedbyid2 and _signedby1 are not used for now
	UPDATE checklists_checklist SET 
is_complete = true,
signature_1 = _signature1, 
signature_2 = _signature2, 
signed_at_1 = now()::timestamp, 
signed_at_2 = now()::timestamp, 
signed_by_1_id = _signedbyid1, 
signed_by_2 = _signedby2, 
modified_at = now()::timestamp  
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for sign_checklist
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."sign_checklist"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signature1" varchar, "_signedby1" varchar);
CREATE OR REPLACE FUNCTION "public"."sign_checklist"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signature1" varchar, "_signedby1" varchar)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	--NOTE! _signedbyid2 and _signedby1 are not used for now
	UPDATE checklists_checklist SET 
is_complete = true,
signature_1 = _signature1, 
signed_at_1 = now()::timestamp, 
signed_by_1_id = _signedbyid1, 
modified_at = now()::timestamp  
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Function structure for sign_checklist
-- ----------------------------
DROP FUNCTION IF EXISTS "public"."sign_checklist"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signedbyid2" int4, "_signature1" varchar, "_signature2" varchar, "_signedby1" varchar, "_signedby2" varchar, "_signedat" timestamp);
CREATE OR REPLACE FUNCTION "public"."sign_checklist"("_id" int4, "_companyid" int4, "_signedbyid1" int4, "_signedbyid2" int4, "_signature1" varchar, "_signature2" varchar, "_signedby1" varchar, "_signedby2" varchar, "_signedat" timestamp)
  RETURNS "pg_catalog"."int4" AS $BODY$
	DECLARE
		_rowcount int4;
	BEGIN
	--NOTE! _signedbyid2 and _signedby1 are not used for now
	UPDATE checklists_checklist SET 
is_complete = true,
signature_1 = _signature1, 
signature_2 = _signature2, 
signed_at_1 = _signedat, 
signed_at_2 = _signedat, 
signed_by_1_id = _signedbyid1, 
signed_by_2 = _signedby2, 
modified_at = now()::timestamp  
WHERE id = _id AND company_id = _companyid;
GET DIAGNOSTICS _rowcount = ROW_COUNT;
	 RETURN _rowcount;
END$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."actions_action_assigned_areas_id_seq"
OWNED BY "public"."actions_action_assigned_areas"."id";
SELECT setval('"public"."actions_action_assigned_areas_id_seq"', 1333, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."actions_action_assigned_users_id_seq"
OWNED BY "public"."actions_action_assigned_users"."id";
SELECT setval('"public"."actions_action_assigned_users_id_seq"', 16405, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."actions_action_id_seq"
OWNED BY "public"."actions_action"."id";
SELECT setval('"public"."actions_action_id_seq"', 13986, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."actions_actioncomment_id_seq"
OWNED BY "public"."actions_actioncomment"."id";
SELECT setval('"public"."actions_actioncomment_id_seq"', 19691, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."actions_actioncommentviewed_id_seq"
OWNED BY "public"."actions_actioncommentviewed"."id";
SELECT setval('"public"."actions_actioncommentviewed_id_seq"', 7343, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."actions_actionviewed_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."announcement_id_seq"', 67, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."auditproperty_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."audits_audit_id_seq"
OWNED BY "public"."audits_audit"."id";
SELECT setval('"public"."audits_audit_id_seq"', 10724, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."audits_audit_tasks_id_seq"
OWNED BY "public"."audits_audit_tasks"."id";
SELECT setval('"public"."audits_audit_tasks_id_seq"', 103331, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."audits_audittemplate_id_seq"
OWNED BY "public"."audits_audittemplate"."id";
SELECT setval('"public"."audits_audittemplate_id_seq"', 4399, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."audits_audittemplate_tasks_id_seq"
OWNED BY "public"."audits_audittemplate_tasks"."id";
SELECT setval('"public"."audits_audittemplate_tasks_id_seq"', 15975, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."audittemplateproperty_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."auth_group_id_seq"
OWNED BY "public"."auth_group"."id";
SELECT setval('"public"."auth_group_id_seq"', 2, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."auth_group_permissions_id_seq"
OWNED BY "public"."auth_group_permissions"."id";
SELECT setval('"public"."auth_group_permissions_id_seq"', 4, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."auth_permission_id_seq"
OWNED BY "public"."auth_permission"."id";
SELECT setval('"public"."auth_permission_id_seq"', 88, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."checklistproperty_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."checklists_checklist_id_seq"
OWNED BY "public"."checklists_checklist"."id";
SELECT setval('"public"."checklists_checklist_id_seq"', 125594, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."checklists_checklist_tasks_id_seq"
OWNED BY "public"."checklists_checklist_tasks"."id";
SELECT setval('"public"."checklists_checklist_tasks_id_seq"', 1037870, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."checklists_checklisttemplate_id_seq"
OWNED BY "public"."checklists_checklisttemplate"."id";
SELECT setval('"public"."checklists_checklisttemplate_id_seq"', 6135, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."checklists_checklisttemplate_tasks_id_seq"
OWNED BY "public"."checklists_checklisttemplate_tasks"."id";
SELECT setval('"public"."checklists_checklisttemplate_tasks_id_seq"', 39913, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."checklisttemplateproperty_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."comments_commentviewed_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."comments_id_seq"', 1481, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."companies_area_id_seq"
OWNED BY "public"."companies_area"."id";
SELECT setval('"public"."companies_area_id_seq"', 8057, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."companies_company_id_seq"
OWNED BY "public"."companies_company"."id";
SELECT setval('"public"."companies_company_id_seq"', 1017, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."companies_properties_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."companies_setting_id_seq"', 133, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."companies_shift_id_seq"
OWNED BY "public"."companies_shift"."id";
SELECT setval('"public"."companies_shift_id_seq"', 2458, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."django_admin_log_id_seq"
OWNED BY "public"."django_admin_log"."id";
SELECT setval('"public"."django_admin_log_id_seq"', 2438, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."django_content_type_id_seq"
OWNED BY "public"."django_content_type"."id";
SELECT setval('"public"."django_content_type_id_seq"', 30, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."django_migrations_id_seq"
OWNED BY "public"."django_migrations"."id";
SELECT setval('"public"."django_migrations_id_seq"', 244, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."factoryfeed_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."factoryfeed_messageliked_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."factoryfeed_messageviewed_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."factoryfeedmessages_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."fcm_django_fcmdevice_id_seq"
OWNED BY "public"."fcm_django_fcmdevice"."id";
SELECT setval('"public"."fcm_django_fcmdevice_id_seq"', 206996, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."guardian_groupobjectpermission_id_seq"
OWNED BY "public"."guardian_groupobjectpermission"."id";
SELECT setval('"public"."guardian_groupobjectpermission_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."guardian_userobjectpermission_id_seq"
OWNED BY "public"."guardian_userobjectpermission"."id";
SELECT setval('"public"."guardian_userobjectpermission_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."logging_data_auditing_id_seq"', 275218, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."logging_log_id_seq"', 24928, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."logging_requestresponse_id_seq"', 297133, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."profiles_user_allowed_areas_id_seq"
OWNED BY "public"."profiles_user_allowed_areas"."id";
SELECT setval('"public"."profiles_user_allowed_areas_id_seq"', 276812, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."profiles_user_areas_id_seq"
OWNED BY "public"."profiles_user_areas"."id";
SELECT setval('"public"."profiles_user_areas_id_seq"', 14089, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."profiles_user_groups_id_seq"
OWNED BY "public"."profiles_user_groups"."id";
SELECT setval('"public"."profiles_user_groups_id_seq"', 4, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."profiles_user_id_seq"
OWNED BY "public"."profiles_user"."id";
SELECT setval('"public"."profiles_user_id_seq"', 6590, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."profiles_user_user_permissions_id_seq"
OWNED BY "public"."profiles_user_user_permissions"."id";
SELECT setval('"public"."profiles_user_user_permissions_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."properties_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."propertygroups_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."propertyvalue_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."propertyvaluekind_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."resource_languages_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."resource_settings_id_seq"', 2, false);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."taskproperty_id_seq"', 2918, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."tasks_task_id_seq"
OWNED BY "public"."tasks_task"."id";
SELECT setval('"public"."tasks_task_id_seq"', 6276122, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."tasks_taskrecurrency_id_seq"
OWNED BY "public"."tasks_taskrecurrency"."id";
SELECT setval('"public"."tasks_taskrecurrency_id_seq"', 20318, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."tasks_taskrecurrency_one_time_shifts_id_seq"
OWNED BY "public"."tasks_taskrecurrency_one_time_shifts"."id";
SELECT setval('"public"."tasks_taskrecurrency_one_time_shifts_id_seq"', 1879, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."tasks_taskrecurrency_shifts_id_seq"
OWNED BY "public"."tasks_taskrecurrency_shifts"."id";
SELECT setval('"public"."tasks_taskrecurrency_shifts_id_seq"', 95273, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."tasks_taskstatusrecord_id_seq"
OWNED BY "public"."tasks_taskstatusrecord"."id";
SELECT setval('"public"."tasks_taskstatusrecord_id_seq"', 1861454, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."tasks_tasktemplate_id_seq"
OWNED BY "public"."tasks_tasktemplate"."id";
SELECT setval('"public"."tasks_tasktemplate_id_seq"', 73152, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."tasks_tasktemplate_tags_links_id_seq"
OWNED BY "public"."tasks_tasktemplate_tags_links"."id";
SELECT setval('"public"."tasks_tasktemplate_tags_links_id_seq"', 1955, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."tasks_tasktemplatestep_id_seq"
OWNED BY "public"."tasks_tasktemplatestep"."id";
SELECT setval('"public"."tasks_tasktemplatestep_id_seq"', 41392, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."tasks_tasktemplatetag_id_seq"
OWNED BY "public"."tasks_tasktemplatetag"."id";
SELECT setval('"public"."tasks_tasktemplatetag_id_seq"', 211, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
SELECT setval('"public"."tasktemplateproperty_id_seq"', 2311, true);

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "public"."uploads_requesteds3link_id_seq"
OWNED BY "public"."uploads_requesteds3link"."id";
SELECT setval('"public"."uploads_requesteds3link_id_seq"', 1749, true);

-- ----------------------------
-- Indexes structure for table actions_action
-- ----------------------------
CREATE INDEX "actions_action_company_id_aa4e2270" ON "public"."actions_action" USING btree (
  "company_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "actions_action_created_by_id_c62485a4" ON "public"."actions_action" USING btree (
  "created_by_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "actions_action_task_id_1abb38e6" ON "public"."actions_action" USING btree (
  "task_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "actions_action_task_template_id_cc873e21" ON "public"."actions_action" USING btree (
  "task_template_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table actions_action
-- ----------------------------
ALTER TABLE "public"."actions_action" ADD CONSTRAINT "actions_action_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table actions_action_assigned_areas
-- ----------------------------
CREATE INDEX "actions_action_assigned_areas_action_id_53a99f67" ON "public"."actions_action_assigned_areas" USING btree (
  "action_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "actions_action_assigned_areas_area_id_3cce9018" ON "public"."actions_action_assigned_areas" USING btree (
  "area_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table actions_action_assigned_areas
-- ----------------------------
ALTER TABLE "public"."actions_action_assigned_areas" ADD CONSTRAINT "actions_action_assigned_areas_action_id_area_id_768e9695_uniq" UNIQUE ("action_id", "area_id");

-- ----------------------------
-- Primary Key structure for table actions_action_assigned_areas
-- ----------------------------
ALTER TABLE "public"."actions_action_assigned_areas" ADD CONSTRAINT "actions_action_assigned_areas_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table actions_action_assigned_users
-- ----------------------------
CREATE INDEX "actions_action_assigned_users_action_id_4fe80efa" ON "public"."actions_action_assigned_users" USING btree (
  "action_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "actions_action_assigned_users_user_id_85b2503a" ON "public"."actions_action_assigned_users" USING btree (
  "user_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table actions_action_assigned_users
-- ----------------------------
ALTER TABLE "public"."actions_action_assigned_users" ADD CONSTRAINT "actions_action_assigned_users_action_id_user_id_226e6e03_uniq" UNIQUE ("action_id", "user_id");

-- ----------------------------
-- Primary Key structure for table actions_action_assigned_users
-- ----------------------------
ALTER TABLE "public"."actions_action_assigned_users" ADD CONSTRAINT "actions_action_assigned_users_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table actions_actioncomment
-- ----------------------------
CREATE INDEX "actions_actioncomment_action_id_691fb1e8" ON "public"."actions_actioncomment" USING btree (
  "action_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "actions_actioncomment_company_id_042212ca" ON "public"."actions_actioncomment" USING btree (
  "company_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "actions_actioncomment_user_id_edc2967a" ON "public"."actions_actioncomment" USING btree (
  "user_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table actions_actioncomment
-- ----------------------------
ALTER TABLE "public"."actions_actioncomment" ADD CONSTRAINT "actions_actioncomment_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table actions_actioncommentviewed
-- ----------------------------
CREATE INDEX "actions_actioncommentviewed_comment_id_8694fdd7" ON "public"."actions_actioncommentviewed" USING btree (
  "comment_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "actions_actioncommentviewed_user_id_c5b65c68" ON "public"."actions_actioncommentviewed" USING btree (
  "user_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table actions_actioncommentviewed
-- ----------------------------
ALTER TABLE "public"."actions_actioncommentviewed" ADD CONSTRAINT "actions_actioncommentviewed_user_id_comment_id_c6e29ea9_uniq" UNIQUE ("user_id", "comment_id");

-- ----------------------------
-- Primary Key structure for table actions_actioncommentviewed
-- ----------------------------
ALTER TABLE "public"."actions_actioncommentviewed" ADD CONSTRAINT "actions_actioncommentviewed_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table actions_actionviewed
-- ----------------------------
CREATE INDEX "actions_actionviewed_action_id_8694fdd1" ON "public"."actions_actionviewed" USING btree (
  "action_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "actions_actionviewed_user_id_c5b65c61" ON "public"."actions_actionviewed" USING btree (
  "user_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table actions_actionviewed
-- ----------------------------
ALTER TABLE "public"."actions_actionviewed" ADD CONSTRAINT "actions_actionviewed_user_id_action_id_c6e29ea1_uniq" UNIQUE ("user_id", "action_id");

-- ----------------------------
-- Primary Key structure for table actions_actionviewed
-- ----------------------------
ALTER TABLE "public"."actions_actionviewed" ADD CONSTRAINT "actions_actionviewed_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table audits_audit
-- ----------------------------
CREATE INDEX "audits_audit_company_id_1be2d791" ON "public"."audits_audit" USING btree (
  "company_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "audits_audit_signed_by_1_id_f62a8187" ON "public"."audits_audit" USING btree (
  "signed_by_1_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "audits_audit_template_id_589907e2" ON "public"."audits_audit" USING btree (
  "template_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Checks structure for table audits_audit
-- ----------------------------
ALTER TABLE "public"."audits_audit" ADD CONSTRAINT "audits_audit_total_score_check" CHECK (total_score >= 0);

-- ----------------------------
-- Primary Key structure for table audits_audit
-- ----------------------------
ALTER TABLE "public"."audits_audit" ADD CONSTRAINT "audits_audit_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table audits_audit_tasks
-- ----------------------------
CREATE INDEX "audits_audit_tasks_audit_id_2ba9d89d" ON "public"."audits_audit_tasks" USING btree (
  "audit_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "audits_audit_tasks_task_id_259d1810" ON "public"."audits_audit_tasks" USING btree (
  "task_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table audits_audit_tasks
-- ----------------------------
ALTER TABLE "public"."audits_audit_tasks" ADD CONSTRAINT "audits_audit_tasks_audit_id_task_id_7f99c97a_uniq" UNIQUE ("audit_id", "task_id");

-- ----------------------------
-- Primary Key structure for table audits_audit_tasks
-- ----------------------------
ALTER TABLE "public"."audits_audit_tasks" ADD CONSTRAINT "audits_audit_tasks_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table audits_audittemplate
-- ----------------------------
CREATE INDEX "audits_audittemplate_area_id_d4b463f2" ON "public"."audits_audittemplate" USING btree (
  "area_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "audits_audittemplate_company_id_fc966e48" ON "public"."audits_audittemplate" USING btree (
  "company_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table audits_audittemplate
-- ----------------------------
ALTER TABLE "public"."audits_audittemplate" ADD CONSTRAINT "audits_audittemplate_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table audits_audittemplate_properties
-- ----------------------------
ALTER TABLE "public"."audits_audittemplate_properties" ADD CONSTRAINT "audits_audittemplate_properties_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table audits_audittemplate_tasks
-- ----------------------------
CREATE INDEX "audits_audittemplate_tasks_audittemplate_id_f5128bf7" ON "public"."audits_audittemplate_tasks" USING btree (
  "audittemplate_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "audits_audittemplate_tasks_tasktemplate_id_556d1799" ON "public"."audits_audittemplate_tasks" USING btree (
  "tasktemplate_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table audits_audittemplate_tasks
-- ----------------------------
ALTER TABLE "public"."audits_audittemplate_tasks" ADD CONSTRAINT "audits_audittemplate_tas_audittemplate_id_tasktem_7cc08b7b_uniq" UNIQUE ("audittemplate_id", "tasktemplate_id");

-- ----------------------------
-- Primary Key structure for table audits_audittemplate_tasks
-- ----------------------------
ALTER TABLE "public"."audits_audittemplate_tasks" ADD CONSTRAINT "audits_audittemplate_tasks_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table audits_properties
-- ----------------------------
ALTER TABLE "public"."audits_properties" ADD CONSTRAINT "audits_properties_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table auth_group
-- ----------------------------
CREATE INDEX "auth_group_name_a6ea08ec_like" ON "public"."auth_group" USING btree (
  "name" COLLATE "pg_catalog"."default" "pg_catalog"."varchar_pattern_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table auth_group
-- ----------------------------
ALTER TABLE "public"."auth_group" ADD CONSTRAINT "auth_group_name_key" UNIQUE ("name");

-- ----------------------------
-- Primary Key structure for table auth_group
-- ----------------------------
ALTER TABLE "public"."auth_group" ADD CONSTRAINT "auth_group_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table auth_group_permissions
-- ----------------------------
CREATE INDEX "auth_group_permissions_group_id_b120cbf9" ON "public"."auth_group_permissions" USING btree (
  "group_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "auth_group_permissions_permission_id_84c5c92e" ON "public"."auth_group_permissions" USING btree (
  "permission_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table auth_group_permissions
-- ----------------------------
ALTER TABLE "public"."auth_group_permissions" ADD CONSTRAINT "auth_group_permissions_group_id_permission_id_0cd325b0_uniq" UNIQUE ("group_id", "permission_id");

-- ----------------------------
-- Primary Key structure for table auth_group_permissions
-- ----------------------------
ALTER TABLE "public"."auth_group_permissions" ADD CONSTRAINT "auth_group_permissions_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table auth_permission
-- ----------------------------
CREATE INDEX "auth_permission_content_type_id_2f476e4b" ON "public"."auth_permission" USING btree (
  "content_type_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table auth_permission
-- ----------------------------
ALTER TABLE "public"."auth_permission" ADD CONSTRAINT "auth_permission_content_type_id_codename_01ab375a_uniq" UNIQUE ("content_type_id", "codename");

-- ----------------------------
-- Primary Key structure for table auth_permission
-- ----------------------------
ALTER TABLE "public"."auth_permission" ADD CONSTRAINT "auth_permission_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table authtoken_token
-- ----------------------------
CREATE INDEX "authtoken_token_key_10f0b77e_like" ON "public"."authtoken_token" USING btree (
  "key" COLLATE "pg_catalog"."default" "pg_catalog"."varchar_pattern_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table authtoken_token
-- ----------------------------
ALTER TABLE "public"."authtoken_token" ADD CONSTRAINT "authtoken_token_user_id_key" UNIQUE ("user_id");

-- ----------------------------
-- Primary Key structure for table authtoken_token
-- ----------------------------
ALTER TABLE "public"."authtoken_token" ADD CONSTRAINT "authtoken_token_pkey" PRIMARY KEY ("key");

-- ----------------------------
-- Indexes structure for table checklists_checklist
-- ----------------------------
CREATE INDEX "checklists_checklist_company_id_6477dc04" ON "public"."checklists_checklist" USING btree (
  "company_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "checklists_checklist_signed_by_id_33abf68d" ON "public"."checklists_checklist" USING btree (
  "signed_by_1_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "checklists_checklist_template_id_ef1bc1b8" ON "public"."checklists_checklist" USING btree (
  "template_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table checklists_checklist
-- ----------------------------
ALTER TABLE "public"."checklists_checklist" ADD CONSTRAINT "checklists_checklist_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table checklists_checklist_tasks
-- ----------------------------
CREATE INDEX "checklists_checklist_tasks_checklist_id_9d1e1ebe" ON "public"."checklists_checklist_tasks" USING btree (
  "checklist_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "checklists_checklist_tasks_task_id_7d81b6bc" ON "public"."checklists_checklist_tasks" USING btree (
  "task_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table checklists_checklist_tasks
-- ----------------------------
ALTER TABLE "public"."checklists_checklist_tasks" ADD CONSTRAINT "checklists_checklist_tasks_checklist_id_task_id_965a5b8b_uniq" UNIQUE ("checklist_id", "task_id");

-- ----------------------------
-- Primary Key structure for table checklists_checklist_tasks
-- ----------------------------
ALTER TABLE "public"."checklists_checklist_tasks" ADD CONSTRAINT "checklists_checklist_tasks_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table checklists_checklisttemplate
-- ----------------------------
CREATE INDEX "checklists_checklisttemplate_area_id_f939758d" ON "public"."checklists_checklisttemplate" USING btree (
  "area_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "checklists_checklisttemplate_company_id_79d211ac" ON "public"."checklists_checklisttemplate" USING btree (
  "company_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table checklists_checklisttemplate
-- ----------------------------
ALTER TABLE "public"."checklists_checklisttemplate" ADD CONSTRAINT "checklists_checklisttemplate_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table checklists_checklisttemplate_properties
-- ----------------------------
ALTER TABLE "public"."checklists_checklisttemplate_properties" ADD CONSTRAINT "checklist_checklisttemplate_properties_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table checklists_checklisttemplate_tasks
-- ----------------------------
CREATE INDEX "checklists_checklisttempla_checklisttemplate_id_1277bf39" ON "public"."checklists_checklisttemplate_tasks" USING btree (
  "checklisttemplate_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "checklists_checklisttemplate_tasks_tasktemplate_id_c68d5f75" ON "public"."checklists_checklisttemplate_tasks" USING btree (
  "tasktemplate_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table checklists_checklisttemplate_tasks
-- ----------------------------
ALTER TABLE "public"."checklists_checklisttemplate_tasks" ADD CONSTRAINT "checklists_checklisttemp_checklisttemplate_id_tas_82a5dab5_uniq" UNIQUE ("checklisttemplate_id", "tasktemplate_id");

-- ----------------------------
-- Primary Key structure for table checklists_checklisttemplate_tasks
-- ----------------------------
ALTER TABLE "public"."checklists_checklisttemplate_tasks" ADD CONSTRAINT "checklists_checklisttemplate_tasks_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table checklists_properties
-- ----------------------------
ALTER TABLE "public"."checklists_properties" ADD CONSTRAINT "checklists_properties_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table comments
-- ----------------------------
ALTER TABLE "public"."comments" ADD CONSTRAINT "comments_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Uniques structure for table comments_commentviewed
-- ----------------------------
ALTER TABLE "public"."comments_commentviewed" ADD CONSTRAINT "comments_commentviewed_user_id_comment_id_c6e29ea1_uniq" UNIQUE ("user_id", "comment_id");

-- ----------------------------
-- Primary Key structure for table comments_commentviewed
-- ----------------------------
ALTER TABLE "public"."comments_commentviewed" ADD CONSTRAINT "comments_commentviewed_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table companies_area
-- ----------------------------
CREATE INDEX "companies_area_company_id_c1dc0d48" ON "public"."companies_area" USING btree (
  "company_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "companies_area_level_1bf662cf" ON "public"."companies_area" USING btree (
  "level" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "companies_area_lft_16a70b95" ON "public"."companies_area" USING btree (
  "lft" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "companies_area_parent_id_3d91d229" ON "public"."companies_area" USING btree (
  "parent_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "companies_area_rght_a9158267" ON "public"."companies_area" USING btree (
  "rght" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "companies_area_tree_id_a9bd8702" ON "public"."companies_area" USING btree (
  "tree_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Checks structure for table companies_area
-- ----------------------------
ALTER TABLE "public"."companies_area" ADD CONSTRAINT "companies_area_level_check" CHECK (level >= 0);
ALTER TABLE "public"."companies_area" ADD CONSTRAINT "companies_area_lft_check" CHECK (lft >= 0);
ALTER TABLE "public"."companies_area" ADD CONSTRAINT "companies_area_rght_check" CHECK (rght >= 0);
ALTER TABLE "public"."companies_area" ADD CONSTRAINT "companies_area_tree_id_check" CHECK (tree_id >= 0);
ALTER TABLE "public"."companies_area" ADD CONSTRAINT "companies_area_days_to_get_data_check" CHECK (days_to_get_data >= 0);

-- ----------------------------
-- Primary Key structure for table companies_area
-- ----------------------------
ALTER TABLE "public"."companies_area" ADD CONSTRAINT "companies_area_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table companies_company
-- ----------------------------
CREATE INDEX "companies_company_manager_id_a35665a6" ON "public"."companies_company" USING btree (
  "manager_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "companies_company_name_f775eceb_like" ON "public"."companies_company" USING btree (
  "name" COLLATE "pg_catalog"."default" "pg_catalog"."varchar_pattern_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table companies_company
-- ----------------------------
ALTER TABLE "public"."companies_company" ADD CONSTRAINT "companies_company_name_key" UNIQUE ("name");

-- ----------------------------
-- Checks structure for table companies_company
-- ----------------------------
ALTER TABLE "public"."companies_company" ADD CONSTRAINT "companies_company_logoff_after_check" CHECK (logoff_after >= 0);

-- ----------------------------
-- Primary Key structure for table companies_company
-- ----------------------------
ALTER TABLE "public"."companies_company" ADD CONSTRAINT "companies_company_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Uniques structure for table companies_properties
-- ----------------------------
ALTER TABLE "public"."companies_properties" ADD CONSTRAINT "companies_properties_aaaabbbb_uniq" UNIQUE ("property_id", "company_id");

-- ----------------------------
-- Primary Key structure for table companies_properties
-- ----------------------------
ALTER TABLE "public"."companies_properties" ADD CONSTRAINT "companies_properties_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table companies_setting
-- ----------------------------
ALTER TABLE "public"."companies_setting" ADD CONSTRAINT "companies_setting_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table companies_shift
-- ----------------------------
CREATE INDEX "companies_shift_area_id_c706cafe" ON "public"."companies_shift" USING btree (
  "area_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "companies_shift_company_id_0640ca0d" ON "public"."companies_shift" USING btree (
  "company_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table companies_shift
-- ----------------------------
ALTER TABLE "public"."companies_shift" ADD CONSTRAINT "companies_shift_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table django_admin_log
-- ----------------------------
CREATE INDEX "django_admin_log_content_type_id_c4bce8eb" ON "public"."django_admin_log" USING btree (
  "content_type_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "django_admin_log_user_id_c564eba6" ON "public"."django_admin_log" USING btree (
  "user_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Checks structure for table django_admin_log
-- ----------------------------
ALTER TABLE "public"."django_admin_log" ADD CONSTRAINT "django_admin_log_action_flag_check" CHECK (action_flag >= 0);

-- ----------------------------
-- Primary Key structure for table django_admin_log
-- ----------------------------
ALTER TABLE "public"."django_admin_log" ADD CONSTRAINT "django_admin_log_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Uniques structure for table django_content_type
-- ----------------------------
ALTER TABLE "public"."django_content_type" ADD CONSTRAINT "django_content_type_app_label_model_76bd3d3b_uniq" UNIQUE ("app_label", "model");

-- ----------------------------
-- Primary Key structure for table django_content_type
-- ----------------------------
ALTER TABLE "public"."django_content_type" ADD CONSTRAINT "django_content_type_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table django_migrations
-- ----------------------------
ALTER TABLE "public"."django_migrations" ADD CONSTRAINT "django_migrations_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table django_session
-- ----------------------------
CREATE INDEX "django_session_expire_date_a5c62663" ON "public"."django_session" USING btree (
  "expire_date" "pg_catalog"."timestamptz_ops" ASC NULLS LAST
);
CREATE INDEX "django_session_session_key_c0390e0f_like" ON "public"."django_session" USING btree (
  "session_key" COLLATE "pg_catalog"."default" "pg_catalog"."varchar_pattern_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table django_session
-- ----------------------------
ALTER TABLE "public"."django_session" ADD CONSTRAINT "django_session_pkey" PRIMARY KEY ("session_key");

-- ----------------------------
-- Uniques structure for table factoryfeed_messageliked
-- ----------------------------
ALTER TABLE "public"."factoryfeed_messageliked" ADD CONSTRAINT "factoryfeedmessageliked_userid_factoryfeedmessagesid_c6e29ea1_u" UNIQUE ("user_id", "factoryfeedmessage_id");

-- ----------------------------
-- Primary Key structure for table factoryfeed_messageliked
-- ----------------------------
ALTER TABLE "public"."factoryfeed_messageliked" ADD CONSTRAINT "factoryfeedmessageliked_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table factoryfeed_messages
-- ----------------------------
ALTER TABLE "public"."factoryfeed_messages" ADD CONSTRAINT "factoryfeed_messages_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Uniques structure for table factoryfeed_messageviewed
-- ----------------------------
ALTER TABLE "public"."factoryfeed_messageviewed" ADD CONSTRAINT "factoryfeedmessagesviewed_userid_factoryfeedmessagesid_c6e29ea1" UNIQUE ("user_id", "factoryfeedmessage_id");

-- ----------------------------
-- Primary Key structure for table factoryfeed_messageviewed
-- ----------------------------
ALTER TABLE "public"."factoryfeed_messageviewed" ADD CONSTRAINT "factoryfeedmessagesviewed_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table factoryfeeds
-- ----------------------------
ALTER TABLE "public"."factoryfeeds" ADD CONSTRAINT "factoryfeeds_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table fcm_django_fcmdevice
-- ----------------------------
CREATE INDEX "fcm_django_fcmdevice_device_id_a9406c36" ON "public"."fcm_django_fcmdevice" USING btree (
  "device_id" COLLATE "pg_catalog"."default" "pg_catalog"."text_ops" ASC NULLS LAST
);
CREATE INDEX "fcm_django_fcmdevice_user_id_6cdfc0a2" ON "public"."fcm_django_fcmdevice" USING btree (
  "user_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table fcm_django_fcmdevice
-- ----------------------------
ALTER TABLE "public"."fcm_django_fcmdevice" ADD CONSTRAINT "fcm_django_fcmdevice_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table guardian_groupobjectpermission
-- ----------------------------
CREATE INDEX "guardian_groupobjectpermission_content_type_id_7ade36b8" ON "public"."guardian_groupobjectpermission" USING btree (
  "content_type_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "guardian_groupobjectpermission_group_id_4bbbfb62" ON "public"."guardian_groupobjectpermission" USING btree (
  "group_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "guardian_groupobjectpermission_permission_id_36572738" ON "public"."guardian_groupobjectpermission" USING btree (
  "permission_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table guardian_groupobjectpermission
-- ----------------------------
ALTER TABLE "public"."guardian_groupobjectpermission" ADD CONSTRAINT "guardian_groupobjectperm_group_id_permission_id_o_3f189f7c_uniq" UNIQUE ("group_id", "permission_id", "object_pk");

-- ----------------------------
-- Primary Key structure for table guardian_groupobjectpermission
-- ----------------------------
ALTER TABLE "public"."guardian_groupobjectpermission" ADD CONSTRAINT "guardian_groupobjectpermission_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table guardian_userobjectpermission
-- ----------------------------
CREATE INDEX "guardian_userobjectpermission_content_type_id_2e892405" ON "public"."guardian_userobjectpermission" USING btree (
  "content_type_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "guardian_userobjectpermission_permission_id_71807bfc" ON "public"."guardian_userobjectpermission" USING btree (
  "permission_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "guardian_userobjectpermission_user_id_d5c1e964" ON "public"."guardian_userobjectpermission" USING btree (
  "user_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table guardian_userobjectpermission
-- ----------------------------
ALTER TABLE "public"."guardian_userobjectpermission" ADD CONSTRAINT "guardian_userobjectpermi_user_id_permission_id_ob_b0b3d2fc_uniq" UNIQUE ("user_id", "permission_id", "object_pk");

-- ----------------------------
-- Primary Key structure for table guardian_userobjectpermission
-- ----------------------------
ALTER TABLE "public"."guardian_userobjectpermission" ADD CONSTRAINT "guardian_userobjectpermission_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table profiles_expiredtoken
-- ----------------------------
CREATE INDEX "profiles_expiredtoken_key_40027c5d_like" ON "public"."profiles_expiredtoken" USING btree (
  "key" COLLATE "pg_catalog"."default" "pg_catalog"."varchar_pattern_ops" ASC NULLS LAST
);
CREATE INDEX "profiles_expiredtoken_user_id_99e038df" ON "public"."profiles_expiredtoken" USING btree (
  "user_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table profiles_expiredtoken
-- ----------------------------
ALTER TABLE "public"."profiles_expiredtoken" ADD CONSTRAINT "profiles_expiredtoken_pkey" PRIMARY KEY ("key");

-- ----------------------------
-- Indexes structure for table profiles_user
-- ----------------------------
CREATE INDEX "profiles_user_company_id_88d43e4e" ON "public"."profiles_user" USING btree (
  "company_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "profiles_user_successor_id_acf72925" ON "public"."profiles_user" USING btree (
  "successor_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "profiles_user_upn_c162538f_like" ON "public"."profiles_user" USING btree (
  "upn" COLLATE "pg_catalog"."default" "pg_catalog"."varchar_pattern_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table profiles_user
-- ----------------------------
ALTER TABLE "public"."profiles_user" ADD CONSTRAINT "profiles_user_upn_key" UNIQUE ("upn");

-- ----------------------------
-- Primary Key structure for table profiles_user
-- ----------------------------
ALTER TABLE "public"."profiles_user" ADD CONSTRAINT "profiles_user_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table profiles_user_allowed_areas
-- ----------------------------
CREATE INDEX "profiles_user_allowed_areas_area_id_f882e06a" ON "public"."profiles_user_allowed_areas" USING btree (
  "area_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "profiles_user_allowed_areas_user_id_d5e785a5" ON "public"."profiles_user_allowed_areas" USING btree (
  "user_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table profiles_user_allowed_areas
-- ----------------------------
ALTER TABLE "public"."profiles_user_allowed_areas" ADD CONSTRAINT "profiles_user_allowed_areas_user_id_area_id_05b38d8a_uniq" UNIQUE ("user_id", "area_id");

-- ----------------------------
-- Primary Key structure for table profiles_user_allowed_areas
-- ----------------------------
ALTER TABLE "public"."profiles_user_allowed_areas" ADD CONSTRAINT "profiles_user_allowed_areas_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table profiles_user_areas
-- ----------------------------
CREATE INDEX "profiles_user_areas_area_id_e8512005" ON "public"."profiles_user_areas" USING btree (
  "area_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "profiles_user_areas_user_id_9c51fca7" ON "public"."profiles_user_areas" USING btree (
  "user_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table profiles_user_areas
-- ----------------------------
ALTER TABLE "public"."profiles_user_areas" ADD CONSTRAINT "profiles_user_areas_user_id_area_id_035a5817_uniq" UNIQUE ("user_id", "area_id");

-- ----------------------------
-- Primary Key structure for table profiles_user_areas
-- ----------------------------
ALTER TABLE "public"."profiles_user_areas" ADD CONSTRAINT "profiles_user_areas_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table profiles_user_groups
-- ----------------------------
CREATE INDEX "profiles_user_groups_group_id_352908a1" ON "public"."profiles_user_groups" USING btree (
  "group_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "profiles_user_groups_user_id_4d7ad1f7" ON "public"."profiles_user_groups" USING btree (
  "user_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table profiles_user_groups
-- ----------------------------
ALTER TABLE "public"."profiles_user_groups" ADD CONSTRAINT "profiles_user_groups_user_id_group_id_8abc21ba_uniq" UNIQUE ("user_id", "group_id");

-- ----------------------------
-- Primary Key structure for table profiles_user_groups
-- ----------------------------
ALTER TABLE "public"."profiles_user_groups" ADD CONSTRAINT "profiles_user_groups_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table profiles_user_user_permissions
-- ----------------------------
CREATE INDEX "profiles_user_user_permissions_permission_id_11ba56f0" ON "public"."profiles_user_user_permissions" USING btree (
  "permission_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "profiles_user_user_permissions_user_id_d22af5be" ON "public"."profiles_user_user_permissions" USING btree (
  "user_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table profiles_user_user_permissions
-- ----------------------------
ALTER TABLE "public"."profiles_user_user_permissions" ADD CONSTRAINT "profiles_user_user_permi_user_id_permission_id_d7ec8e00_uniq" UNIQUE ("user_id", "permission_id");

-- ----------------------------
-- Primary Key structure for table profiles_user_user_permissions
-- ----------------------------
ALTER TABLE "public"."profiles_user_user_permissions" ADD CONSTRAINT "profiles_user_user_permissions_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table properties
-- ----------------------------
ALTER TABLE "public"."properties" ADD CONSTRAINT "properties_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table propertygroups
-- ----------------------------
ALTER TABLE "public"."propertygroups" ADD CONSTRAINT "propertygroups_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table propertyvalue
-- ----------------------------
ALTER TABLE "public"."propertyvalue" ADD CONSTRAINT "propertyvalue_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table propertyvaluekind
-- ----------------------------
ALTER TABLE "public"."propertyvaluekind" ADD CONSTRAINT "propertyvaluekind_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table resource_languages
-- ----------------------------
ALTER TABLE "public"."resource_languages" ADD CONSTRAINT "resource_languages_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Uniques structure for table resource_settings
-- ----------------------------
ALTER TABLE "public"."resource_settings" ADD CONSTRAINT "resource_settings_settingskey_a6e29ea1_uniq" UNIQUE ("settingskey");

-- ----------------------------
-- Primary Key structure for table resource_settings
-- ----------------------------
ALTER TABLE "public"."resource_settings" ADD CONSTRAINT "resource_settings_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table sequences_sequence
-- ----------------------------
CREATE INDEX "sequences_sequence_name_667d3102_like" ON "public"."sequences_sequence" USING btree (
  "name" COLLATE "pg_catalog"."default" "pg_catalog"."varchar_pattern_ops" ASC NULLS LAST
);

-- ----------------------------
-- Checks structure for table sequences_sequence
-- ----------------------------
ALTER TABLE "public"."sequences_sequence" ADD CONSTRAINT "sequences_sequence_last_check" CHECK (last >= 0);

-- ----------------------------
-- Primary Key structure for table sequences_sequence
-- ----------------------------
ALTER TABLE "public"."sequences_sequence" ADD CONSTRAINT "sequences_sequence_pkey" PRIMARY KEY ("name");

-- ----------------------------
-- Primary Key structure for table tasks_properties
-- ----------------------------
ALTER TABLE "public"."tasks_properties" ADD CONSTRAINT "tasks_properties_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table tasks_task
-- ----------------------------
CREATE INDEX "tasks_task_company_id_f699f141" ON "public"."tasks_task" USING btree (
  "company_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_task_created_at_idx" ON "public"."tasks_task" USING btree (
  "created_at" "pg_catalog"."timestamptz_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_task_due_at_idx" ON "public"."tasks_task" USING btree (
  "due_at" "pg_catalog"."timestamptz_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_task_is_active_idx" ON "public"."tasks_task" USING btree (
  "is_active" "pg_catalog"."bool_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_task_modified_at_idx" ON "public"."tasks_task" USING btree (
  "modified_at" "pg_catalog"."timestamptz_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_task_recurrency_id_44b7f17b" ON "public"."tasks_task" USING btree (
  "recurrency_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_task_shift_id_bc303916" ON "public"."tasks_task" USING btree (
  "shift_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_task_signed_at_idx" ON "public"."tasks_task" USING btree (
  "signed_at" "pg_catalog"."timestamptz_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_task_signed_by_id_54b25a58" ON "public"."tasks_task" USING btree (
  "signed_by_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_task_start_at_idx" ON "public"."tasks_task" USING btree (
  "start_at" "pg_catalog"."timestamptz_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_task_template_id_4c7816ef" ON "public"."tasks_task" USING btree (
  "template_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_task_time_realized_by_id_a3da60f5" ON "public"."tasks_task" USING btree (
  "time_realized_by_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table tasks_task
-- ----------------------------
ALTER TABLE "public"."tasks_task" ADD CONSTRAINT "tasks_task_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table tasks_taskrecurrency
-- ----------------------------
CREATE INDEX "tasks_taskrecurrency_area_id_8a424fab" ON "public"."tasks_taskrecurrency" USING btree (
  "area_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_taskrecurrency_company_id_f0c77a81" ON "public"."tasks_taskrecurrency" USING btree (
  "company_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_taskrecurrency_created_at_idx" ON "public"."tasks_taskrecurrency" USING btree (
  "created_at" "pg_catalog"."timestamptz_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_taskrecurrency_is_active_idx" ON "public"."tasks_taskrecurrency" USING btree (
  "is_active" "pg_catalog"."bool_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_taskrecurrency_last_signed_at_idx" ON "public"."tasks_taskrecurrency" USING btree (
  "last_signed_at" "pg_catalog"."timestamptz_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_taskrecurrency_modified_at_idx" ON "public"."tasks_taskrecurrency" USING btree (
  "modified_at" "pg_catalog"."timestamptz_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_taskrecurrency_shift_id_e95b64d8" ON "public"."tasks_taskrecurrency" USING btree (
  "shift_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_taskrecurrency_template_id_a8883c2c" ON "public"."tasks_taskrecurrency" USING btree (
  "template_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_taskrecurrency_type_idx" ON "public"."tasks_taskrecurrency" USING btree (
  "type" COLLATE "pg_catalog"."default" "pg_catalog"."text_ops" ASC NULLS LAST
);

-- ----------------------------
-- Checks structure for table tasks_taskrecurrency
-- ----------------------------
ALTER TABLE "public"."tasks_taskrecurrency" ADD CONSTRAINT "tasks_taskrecurrency_month_check" CHECK (month >= 0);
ALTER TABLE "public"."tasks_taskrecurrency" ADD CONSTRAINT "tasks_taskrecurrency_week_check" CHECK (week >= 0);
ALTER TABLE "public"."tasks_taskrecurrency" ADD CONSTRAINT "tasks_taskrecurrency_weekday_check" CHECK (weekday >= 0);
ALTER TABLE "public"."tasks_taskrecurrency" ADD CONSTRAINT "tasks_taskrecurrency_weekday_number_check" CHECK (weekday_number >= 0);
ALTER TABLE "public"."tasks_taskrecurrency" ADD CONSTRAINT "tasks_taskrecurrency_day_check" CHECK (day >= 0);

-- ----------------------------
-- Primary Key structure for table tasks_taskrecurrency
-- ----------------------------
ALTER TABLE "public"."tasks_taskrecurrency" ADD CONSTRAINT "tasks_taskrecurrency_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table tasks_taskrecurrency_one_time_shifts
-- ----------------------------
CREATE INDEX "tasks_taskrecurrency_one_time_shifts_shift_id_8624b72d" ON "public"."tasks_taskrecurrency_one_time_shifts" USING btree (
  "shift_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_taskrecurrency_one_time_shifts_taskrecurrency_id_d4987e51" ON "public"."tasks_taskrecurrency_one_time_shifts" USING btree (
  "taskrecurrency_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table tasks_taskrecurrency_one_time_shifts
-- ----------------------------
ALTER TABLE "public"."tasks_taskrecurrency_one_time_shifts" ADD CONSTRAINT "tasks_taskrecurrency_one_taskrecurrency_id_shift__fc8cf1e7_uniq" UNIQUE ("taskrecurrency_id", "shift_id");

-- ----------------------------
-- Primary Key structure for table tasks_taskrecurrency_one_time_shifts
-- ----------------------------
ALTER TABLE "public"."tasks_taskrecurrency_one_time_shifts" ADD CONSTRAINT "tasks_taskrecurrency_one_time_shifts_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table tasks_taskrecurrency_shifts
-- ----------------------------
CREATE INDEX "tasks_taskrecurrency_shifts_shift_id_fb0a028e" ON "public"."tasks_taskrecurrency_shifts" USING btree (
  "shift_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_taskrecurrency_shifts_taskrecurrency_id_d7cdefac" ON "public"."tasks_taskrecurrency_shifts" USING btree (
  "taskrecurrency_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table tasks_taskrecurrency_shifts
-- ----------------------------
ALTER TABLE "public"."tasks_taskrecurrency_shifts" ADD CONSTRAINT "tasks_taskrecurrency_shi_taskrecurrency_id_shift__c02a3fa8_uniq" UNIQUE ("taskrecurrency_id", "shift_id");

-- ----------------------------
-- Primary Key structure for table tasks_taskrecurrency_shifts
-- ----------------------------
ALTER TABLE "public"."tasks_taskrecurrency_shifts" ADD CONSTRAINT "tasks_taskrecurrency_shifts_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table tasks_taskstatusrecord
-- ----------------------------
CREATE INDEX "tasks_taskstatusrecord_signed_by_id_dcd344a5" ON "public"."tasks_taskstatusrecord" USING btree (
  "signed_by_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_taskstatusrecord_task_id_3c97c8b6" ON "public"."tasks_taskstatusrecord" USING btree (
  "task_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table tasks_taskstatusrecord
-- ----------------------------
ALTER TABLE "public"."tasks_taskstatusrecord" ADD CONSTRAINT "tasks_taskstatusrecord_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table tasks_tasktemplate
-- ----------------------------
CREATE INDEX "tasks_tasktemplate_area_id_ea70ab9c" ON "public"."tasks_tasktemplate" USING btree (
  "area_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_tasktemplate_company_id_97507168" ON "public"."tasks_tasktemplate" USING btree (
  "company_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_tasktemplate_created_at_idx" ON "public"."tasks_tasktemplate" USING btree (
  "created_at" "pg_catalog"."timestamptz_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_tasktemplate_is_active_idx" ON "public"."tasks_tasktemplate" USING btree (
  "is_active" "pg_catalog"."bool_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_tasktemplate_modified_at_idx" ON "public"."tasks_tasktemplate" USING btree (
  "modified_at" "pg_catalog"."timestamptz_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_tasktemplate_role_idx" ON "public"."tasks_tasktemplate" USING btree (
  "role" COLLATE "pg_catalog"."default" "pg_catalog"."text_ops" ASC NULLS LAST
);

-- ----------------------------
-- Checks structure for table tasks_tasktemplate
-- ----------------------------
ALTER TABLE "public"."tasks_tasktemplate" ADD CONSTRAINT "tasks_tasktemplate_deeplink_id_check" CHECK (deeplink_id >= 0);
ALTER TABLE "public"."tasks_tasktemplate" ADD CONSTRAINT "tasks_tasktemplate_index_check" CHECK (index >= 0);

-- ----------------------------
-- Primary Key structure for table tasks_tasktemplate
-- ----------------------------
ALTER TABLE "public"."tasks_tasktemplate" ADD CONSTRAINT "tasks_tasktemplate_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Primary Key structure for table tasks_tasktemplate_properties
-- ----------------------------
ALTER TABLE "public"."tasks_tasktemplate_properties" ADD CONSTRAINT "tasks_tasktemplate_properties_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table tasks_tasktemplate_tags_links
-- ----------------------------
CREATE INDEX "tasks_tasktemplate_tags_links_tasktemplate_id_d2885edf" ON "public"."tasks_tasktemplate_tags_links" USING btree (
  "tasktemplate_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_tasktemplate_tags_links_tasktemplatetag_id_91177e5e" ON "public"."tasks_tasktemplate_tags_links" USING btree (
  "tasktemplatetag_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Uniques structure for table tasks_tasktemplate_tags_links
-- ----------------------------
ALTER TABLE "public"."tasks_tasktemplate_tags_links" ADD CONSTRAINT "tasks_tasktemplate_tags__tasktemplate_id_tasktemp_816c8ab8_uniq" UNIQUE ("tasktemplate_id", "tasktemplatetag_id");

-- ----------------------------
-- Primary Key structure for table tasks_tasktemplate_tags_links
-- ----------------------------
ALTER TABLE "public"."tasks_tasktemplate_tags_links" ADD CONSTRAINT "tasks_tasktemplate_tags_links_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table tasks_tasktemplatestep
-- ----------------------------
CREATE INDEX "tasks_tasktemplatestep_created_at_idx" ON "public"."tasks_tasktemplatestep" USING btree (
  "created_at" "pg_catalog"."timestamptz_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_tasktemplatestep_is_active_idx" ON "public"."tasks_tasktemplatestep" USING btree (
  "is_active" "pg_catalog"."bool_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_tasktemplatestep_modified_at_idx" ON "public"."tasks_tasktemplatestep" USING btree (
  "modified_at" "pg_catalog"."timestamptz_ops" ASC NULLS LAST
);
CREATE INDEX "tasks_tasktemplatestep_template_id_4247b8b7" ON "public"."tasks_tasktemplatestep" USING btree (
  "template_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Checks structure for table tasks_tasktemplatestep
-- ----------------------------
ALTER TABLE "public"."tasks_tasktemplatestep" ADD CONSTRAINT "tasks_tasktemplatestep_index_check" CHECK (index >= 0);

-- ----------------------------
-- Primary Key structure for table tasks_tasktemplatestep
-- ----------------------------
ALTER TABLE "public"."tasks_tasktemplatestep" ADD CONSTRAINT "tasks_tasktemplatestep_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table tasks_tasktemplatetag
-- ----------------------------
CREATE INDEX "tasks_tasktemplatetag_company_id_70d4a727" ON "public"."tasks_tasktemplatetag" USING btree (
  "company_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table tasks_tasktemplatetag
-- ----------------------------
ALTER TABLE "public"."tasks_tasktemplatetag" ADD CONSTRAINT "tasks_tasktemplatetag_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Indexes structure for table uploads_requesteds3link
-- ----------------------------
CREATE INDEX "uploads_requesteds3link_company_id_40d5a4fa" ON "public"."uploads_requesteds3link" USING btree (
  "company_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);
CREATE INDEX "uploads_requesteds3link_user_id_d6b07602" ON "public"."uploads_requesteds3link" USING btree (
  "user_id" "pg_catalog"."int4_ops" ASC NULLS LAST
);

-- ----------------------------
-- Primary Key structure for table uploads_requesteds3link
-- ----------------------------
ALTER TABLE "public"."uploads_requesteds3link" ADD CONSTRAINT "uploads_requesteds3link_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- Foreign Keys structure for table actions_action
-- ----------------------------
ALTER TABLE "public"."actions_action" ADD CONSTRAINT "actions_action_company_id_aa4e2270_fk_companies_company_id" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."actions_action" ADD CONSTRAINT "actions_action_created_by_id_c62485a4_fk_profiles_user_id" FOREIGN KEY ("created_by_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."actions_action" ADD CONSTRAINT "actions_action_task_id_1abb38e6_fk_tasks_task_id" FOREIGN KEY ("task_id") REFERENCES "public"."tasks_task" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."actions_action" ADD CONSTRAINT "actions_action_task_template_id_cc873e21_fk_tasks_tas" FOREIGN KEY ("task_template_id") REFERENCES "public"."tasks_tasktemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table actions_action_assigned_areas
-- ----------------------------
ALTER TABLE "public"."actions_action_assigned_areas" ADD CONSTRAINT "actions_action_assig_action_id_53a99f67_fk_actions_a" FOREIGN KEY ("action_id") REFERENCES "public"."actions_action" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."actions_action_assigned_areas" ADD CONSTRAINT "actions_action_assig_area_id_3cce9018_fk_companies" FOREIGN KEY ("area_id") REFERENCES "public"."companies_area" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table actions_action_assigned_users
-- ----------------------------
ALTER TABLE "public"."actions_action_assigned_users" ADD CONSTRAINT "actions_action_assig_action_id_4fe80efa_fk_actions_a" FOREIGN KEY ("action_id") REFERENCES "public"."actions_action" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."actions_action_assigned_users" ADD CONSTRAINT "actions_action_assig_user_id_85b2503a_fk_profiles_" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table actions_actioncomment
-- ----------------------------
ALTER TABLE "public"."actions_actioncomment" ADD CONSTRAINT "actions_actioncommen_company_id_042212ca_fk_companies" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."actions_actioncomment" ADD CONSTRAINT "actions_actioncomment_action_id_691fb1e8_fk_actions_action_id" FOREIGN KEY ("action_id") REFERENCES "public"."actions_action" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."actions_actioncomment" ADD CONSTRAINT "actions_actioncomment_user_id_edc2967a_fk_profiles_user_id" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table actions_actioncommentviewed
-- ----------------------------
ALTER TABLE "public"."actions_actioncommentviewed" ADD CONSTRAINT "actions_actioncommen_comment_id_8694fdd7_fk_actions_a" FOREIGN KEY ("comment_id") REFERENCES "public"."actions_actioncomment" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."actions_actioncommentviewed" ADD CONSTRAINT "actions_actioncommen_user_id_c5b65c68_fk_profiles_" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table actions_actionviewed
-- ----------------------------
ALTER TABLE "public"."actions_actionviewed" ADD CONSTRAINT "actions_actionviewe_action_id_8694fdd1_fk_actions_a" FOREIGN KEY ("action_id") REFERENCES "public"."actions_action" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."actions_actionviewed" ADD CONSTRAINT "actions_actionviewe_user_id_c5b65c61_fk_profiles_" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table audits_audit
-- ----------------------------
ALTER TABLE "public"."audits_audit" ADD CONSTRAINT "audits_audit_company_id_1be2d791_fk_companies_company_id" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."audits_audit" ADD CONSTRAINT "audits_audit_signed_by_1_id_f62a8187_fk_profiles_user_id" FOREIGN KEY ("signed_by_1_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."audits_audit" ADD CONSTRAINT "audits_audit_template_id_589907e2_fk_audits_audittemplate_id" FOREIGN KEY ("template_id") REFERENCES "public"."audits_audittemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table audits_audit_tasks
-- ----------------------------
ALTER TABLE "public"."audits_audit_tasks" ADD CONSTRAINT "audits_audit_tasks_audit_id_2ba9d89d_fk_audits_audit_id" FOREIGN KEY ("audit_id") REFERENCES "public"."audits_audit" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."audits_audit_tasks" ADD CONSTRAINT "audits_audit_tasks_task_id_259d1810_fk_tasks_task_id" FOREIGN KEY ("task_id") REFERENCES "public"."tasks_task" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table audits_audittemplate
-- ----------------------------
ALTER TABLE "public"."audits_audittemplate" ADD CONSTRAINT "audits_audittemplate_area_id_d4b463f2_fk_companies_area_id" FOREIGN KEY ("area_id") REFERENCES "public"."companies_area" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."audits_audittemplate" ADD CONSTRAINT "audits_audittemplate_company_id_fc966e48_fk_companies" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table audits_audittemplate_properties
-- ----------------------------
ALTER TABLE "public"."audits_audittemplate_properties" ADD CONSTRAINT "audits_audittemplate_properties_aaaabbbb_fk_audittemplate_a" FOREIGN KEY ("audittemplate_id") REFERENCES "public"."audits_audittemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."audits_audittemplate_properties" ADD CONSTRAINT "audits_audittemplate_properties_aaaabbbb_fk_company_a" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."audits_audittemplate_properties" ADD CONSTRAINT "audits_audittemplate_properties_aaaabbbb_fk_property_a" FOREIGN KEY ("property_id") REFERENCES "public"."properties" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."audits_audittemplate_properties" ADD CONSTRAINT "audits_audittemplate_properties_aaaabbbb_fk_propertyvalue_a" FOREIGN KEY ("propertyvalue_id") REFERENCES "public"."propertyvalue" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table audits_audittemplate_tasks
-- ----------------------------
ALTER TABLE "public"."audits_audittemplate_tasks" ADD CONSTRAINT "audits_audittemplate_audittemplate_id_f5128bf7_fk_audits_au" FOREIGN KEY ("audittemplate_id") REFERENCES "public"."audits_audittemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."audits_audittemplate_tasks" ADD CONSTRAINT "audits_audittemplate_tasktemplate_id_556d1799_fk_tasks_tas" FOREIGN KEY ("tasktemplate_id") REFERENCES "public"."tasks_tasktemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table audits_properties
-- ----------------------------
ALTER TABLE "public"."audits_properties" ADD CONSTRAINT "audits_properties_aaaabbbb_fk_audit_a" FOREIGN KEY ("audit_id") REFERENCES "public"."audits_audit" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."audits_properties" ADD CONSTRAINT "audits_properties_aaaabbbb_fk_auditstemplate_a" FOREIGN KEY ("template_property_id") REFERENCES "public"."audits_audittemplate_properties" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."audits_properties" ADD CONSTRAINT "audits_properties_aaaabbbb_fk_company_a" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."audits_properties" ADD CONSTRAINT "audits_properties_aaaabbbb_fk_profilesuser_a" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."audits_properties" ADD CONSTRAINT "audits_properties_aaaabbbb_fk_property_a" FOREIGN KEY ("property_id") REFERENCES "public"."properties" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table auth_group_permissions
-- ----------------------------
ALTER TABLE "public"."auth_group_permissions" ADD CONSTRAINT "auth_group_permissio_permission_id_84c5c92e_fk_auth_perm" FOREIGN KEY ("permission_id") REFERENCES "public"."auth_permission" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."auth_group_permissions" ADD CONSTRAINT "auth_group_permissions_group_id_b120cbf9_fk_auth_group_id" FOREIGN KEY ("group_id") REFERENCES "public"."auth_group" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table auth_permission
-- ----------------------------
ALTER TABLE "public"."auth_permission" ADD CONSTRAINT "auth_permission_content_type_id_2f476e4b_fk_django_co" FOREIGN KEY ("content_type_id") REFERENCES "public"."django_content_type" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table authtoken_token
-- ----------------------------
ALTER TABLE "public"."authtoken_token" ADD CONSTRAINT "authtoken_token_user_id_35299eff_fk_profiles_user_id" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table checklists_checklist
-- ----------------------------
ALTER TABLE "public"."checklists_checklist" ADD CONSTRAINT "checklists_checklist_company_id_6477dc04_fk_companies" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."checklists_checklist" ADD CONSTRAINT "checklists_checklist_signed_by_1_id_46e9f9b1_fk_profiles_" FOREIGN KEY ("signed_by_1_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."checklists_checklist" ADD CONSTRAINT "checklists_checklist_template_id_ef1bc1b8_fk_checklist" FOREIGN KEY ("template_id") REFERENCES "public"."checklists_checklisttemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table checklists_checklist_tasks
-- ----------------------------
ALTER TABLE "public"."checklists_checklist_tasks" ADD CONSTRAINT "checklists_checklist_checklist_id_9d1e1ebe_fk_checklist" FOREIGN KEY ("checklist_id") REFERENCES "public"."checklists_checklist" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."checklists_checklist_tasks" ADD CONSTRAINT "checklists_checklist_tasks_task_id_7d81b6bc_fk_tasks_task_id" FOREIGN KEY ("task_id") REFERENCES "public"."tasks_task" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table checklists_checklisttemplate
-- ----------------------------
ALTER TABLE "public"."checklists_checklisttemplate" ADD CONSTRAINT "checklists_checklist_area_id_f939758d_fk_companies" FOREIGN KEY ("area_id") REFERENCES "public"."companies_area" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."checklists_checklisttemplate" ADD CONSTRAINT "checklists_checklist_company_id_79d211ac_fk_companies" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table checklists_checklisttemplate_properties
-- ----------------------------
ALTER TABLE "public"."checklists_checklisttemplate_properties" ADD CONSTRAINT "checklist_checklisttemplate_properties_aaaabbbb_fk_checklisttem" FOREIGN KEY ("checklisttemplate_id") REFERENCES "public"."checklists_checklisttemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."checklists_checklisttemplate_properties" ADD CONSTRAINT "checklist_checklisttemplate_properties_aaaabbbb_fk_company_a" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."checklists_checklisttemplate_properties" ADD CONSTRAINT "checklist_checklisttemplate_properties_aaaabbbb_fk_property_a" FOREIGN KEY ("property_id") REFERENCES "public"."properties" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."checklists_checklisttemplate_properties" ADD CONSTRAINT "checklist_checklisttemplate_properties_aaaabbbb_fk_propertyvalu" FOREIGN KEY ("propertyvalue_id") REFERENCES "public"."propertyvalue" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table checklists_checklisttemplate_tasks
-- ----------------------------
ALTER TABLE "public"."checklists_checklisttemplate_tasks" ADD CONSTRAINT "checklists_checklist_checklisttemplate_id_1277bf39_fk_checklist" FOREIGN KEY ("checklisttemplate_id") REFERENCES "public"."checklists_checklisttemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."checklists_checklisttemplate_tasks" ADD CONSTRAINT "checklists_checklist_tasktemplate_id_c68d5f75_fk_tasks_tas" FOREIGN KEY ("tasktemplate_id") REFERENCES "public"."tasks_tasktemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table checklists_properties
-- ----------------------------
ALTER TABLE "public"."checklists_properties" ADD CONSTRAINT "checklists_properties_aaaabbbb_fk_checklist_a" FOREIGN KEY ("checklist_id") REFERENCES "public"."checklists_checklist" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."checklists_properties" ADD CONSTRAINT "checklists_properties_aaaabbbb_fk_checklisttemplate_a" FOREIGN KEY ("template_property_id") REFERENCES "public"."checklists_checklisttemplate_properties" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."checklists_properties" ADD CONSTRAINT "checklists_properties_aaaabbbb_fk_company_a" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."checklists_properties" ADD CONSTRAINT "checklists_properties_aaaabbbb_fk_profilesuser_a" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."checklists_properties" ADD CONSTRAINT "checklists_properties_aaaabbbb_fk_property_a" FOREIGN KEY ("property_id") REFERENCES "public"."properties" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table comments
-- ----------------------------
ALTER TABLE "public"."comments" ADD CONSTRAINT "comments_aaaabbbb_fk_company_a" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."comments" ADD CONSTRAINT "comments_aaaabbbb_fk_tasks_a" FOREIGN KEY ("task_id") REFERENCES "public"."tasks_task" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."comments" ADD CONSTRAINT "comments_aaaabbbb_fk_user_a" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."comments" ADD CONSTRAINT "comments_ab_fk_tasktemplate_a" FOREIGN KEY ("tasktemplate_id") REFERENCES "public"."tasks_tasktemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table comments_commentviewed
-- ----------------------------
ALTER TABLE "public"."comments_commentviewed" ADD CONSTRAINT "comments_commentviewed_comment_id_8694fdd1_fk_comments_a" FOREIGN KEY ("comment_id") REFERENCES "public"."comments" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."comments_commentviewed" ADD CONSTRAINT "comments_commentviewed_user_id_c5b65c61_fk_profiles_a" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table companies_area
-- ----------------------------
ALTER TABLE "public"."companies_area" ADD CONSTRAINT "companies_area_company_id_c1dc0d48_fk_companies_company_id" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."companies_area" ADD CONSTRAINT "companies_area_parent_id_3d91d229_fk_companies_area_id" FOREIGN KEY ("parent_id") REFERENCES "public"."companies_area" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table companies_company
-- ----------------------------
ALTER TABLE "public"."companies_company" ADD CONSTRAINT "companies_company_manager_id_a35665a6_fk_profiles_user_id" FOREIGN KEY ("manager_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table companies_properties
-- ----------------------------
ALTER TABLE "public"."companies_properties" ADD CONSTRAINT "companies_properties_aaaabbbb_fk_company_a" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."companies_properties" ADD CONSTRAINT "companies_properties_aaaabbbb_fk_property_a" FOREIGN KEY ("property_id") REFERENCES "public"."properties" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table companies_setting
-- ----------------------------
ALTER TABLE "public"."companies_setting" ADD CONSTRAINT "companies_setting_a694fdd1_fk_companies_a" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table companies_shift
-- ----------------------------
ALTER TABLE "public"."companies_shift" ADD CONSTRAINT "companies_shift_area_id_c706cafe_fk_companies_area_id" FOREIGN KEY ("area_id") REFERENCES "public"."companies_area" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."companies_shift" ADD CONSTRAINT "companies_shift_company_id_0640ca0d_fk_companies_company_id" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table django_admin_log
-- ----------------------------
ALTER TABLE "public"."django_admin_log" ADD CONSTRAINT "django_admin_log_content_type_id_c4bce8eb_fk_django_co" FOREIGN KEY ("content_type_id") REFERENCES "public"."django_content_type" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."django_admin_log" ADD CONSTRAINT "django_admin_log_user_id_c564eba6_fk_profiles_user_id" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table factoryfeed_messageliked
-- ----------------------------
ALTER TABLE "public"."factoryfeed_messageliked" ADD CONSTRAINT "factoryfeedmessageliked_factoryfeedmessages_id_8694fdd1_fk_fact" FOREIGN KEY ("factoryfeedmessage_id") REFERENCES "public"."factoryfeed_messages" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."factoryfeed_messageliked" ADD CONSTRAINT "factoryfeedmessageliked_user_id_c5b65c61_fk_profiles_a" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table factoryfeed_messages
-- ----------------------------
ALTER TABLE "public"."factoryfeed_messages" ADD CONSTRAINT "factoryfeed_messages_aaaabbbb_fk_company_a" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."factoryfeed_messages" ADD CONSTRAINT "factoryfeed_messages_aaaabbbb_fk_factoryfeeds_a" FOREIGN KEY ("factoryfeed_id") REFERENCES "public"."factoryfeeds" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."factoryfeed_messages" ADD CONSTRAINT "factoryfeed_messages_aaaabbbb_fk_user_a" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."factoryfeed_messages" ADD CONSTRAINT "factoryfeed_messages_ab_fk_factoryfeedsmessages_a" FOREIGN KEY ("parent_id") REFERENCES "public"."factoryfeed_messages" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table factoryfeed_messageviewed
-- ----------------------------
ALTER TABLE "public"."factoryfeed_messageviewed" ADD CONSTRAINT "factoryfeedmessagesviewed_factoryfeedmessages_id_8694fdd1_fk_fa" FOREIGN KEY ("factoryfeedmessage_id") REFERENCES "public"."factoryfeed_messages" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."factoryfeed_messageviewed" ADD CONSTRAINT "factoryfeedmessagesviewed_user_id_c5b65c61_fk_profiles_a" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table factoryfeeds
-- ----------------------------
ALTER TABLE "public"."factoryfeeds" ADD CONSTRAINT "factoryfeeds_aaaabbbb_fk_company_a" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table fcm_django_fcmdevice
-- ----------------------------
ALTER TABLE "public"."fcm_django_fcmdevice" ADD CONSTRAINT "fcm_django_fcmdevice_user_id_6cdfc0a2_fk_profiles_user_id" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table guardian_groupobjectpermission
-- ----------------------------
ALTER TABLE "public"."guardian_groupobjectpermission" ADD CONSTRAINT "guardian_groupobject_content_type_id_7ade36b8_fk_django_co" FOREIGN KEY ("content_type_id") REFERENCES "public"."django_content_type" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."guardian_groupobjectpermission" ADD CONSTRAINT "guardian_groupobject_group_id_4bbbfb62_fk_auth_grou" FOREIGN KEY ("group_id") REFERENCES "public"."auth_group" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."guardian_groupobjectpermission" ADD CONSTRAINT "guardian_groupobject_permission_id_36572738_fk_auth_perm" FOREIGN KEY ("permission_id") REFERENCES "public"."auth_permission" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table guardian_userobjectpermission
-- ----------------------------
ALTER TABLE "public"."guardian_userobjectpermission" ADD CONSTRAINT "guardian_userobjectp_content_type_id_2e892405_fk_django_co" FOREIGN KEY ("content_type_id") REFERENCES "public"."django_content_type" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."guardian_userobjectpermission" ADD CONSTRAINT "guardian_userobjectp_permission_id_71807bfc_fk_auth_perm" FOREIGN KEY ("permission_id") REFERENCES "public"."auth_permission" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."guardian_userobjectpermission" ADD CONSTRAINT "guardian_userobjectp_user_id_d5c1e964_fk_profiles_" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table profiles_expiredtoken
-- ----------------------------
ALTER TABLE "public"."profiles_expiredtoken" ADD CONSTRAINT "profiles_expiredtoken_user_id_99e038df_fk_profiles_user_id" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table profiles_user
-- ----------------------------
ALTER TABLE "public"."profiles_user" ADD CONSTRAINT "profiles_user_company_id_88d43e4e_fk_companies_company_id" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."profiles_user" ADD CONSTRAINT "profiles_user_successor_id_acf72925_fk_profiles_user_id" FOREIGN KEY ("successor_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table profiles_user_allowed_areas
-- ----------------------------
ALTER TABLE "public"."profiles_user_allowed_areas" ADD CONSTRAINT "profiles_user_allowe_area_id_f882e06a_fk_companies" FOREIGN KEY ("area_id") REFERENCES "public"."companies_area" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."profiles_user_allowed_areas" ADD CONSTRAINT "profiles_user_allowe_user_id_d5e785a5_fk_profiles_" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table profiles_user_areas
-- ----------------------------
ALTER TABLE "public"."profiles_user_areas" ADD CONSTRAINT "profiles_user_areas_area_id_e8512005_fk_companies_area_id" FOREIGN KEY ("area_id") REFERENCES "public"."companies_area" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."profiles_user_areas" ADD CONSTRAINT "profiles_user_areas_user_id_9c51fca7_fk_profiles_user_id" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table profiles_user_groups
-- ----------------------------
ALTER TABLE "public"."profiles_user_groups" ADD CONSTRAINT "profiles_user_groups_group_id_352908a1_fk_auth_group_id" FOREIGN KEY ("group_id") REFERENCES "public"."auth_group" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."profiles_user_groups" ADD CONSTRAINT "profiles_user_groups_user_id_4d7ad1f7_fk_profiles_user_id" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table profiles_user_user_permissions
-- ----------------------------
ALTER TABLE "public"."profiles_user_user_permissions" ADD CONSTRAINT "profiles_user_user_p_permission_id_11ba56f0_fk_auth_perm" FOREIGN KEY ("permission_id") REFERENCES "public"."auth_permission" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."profiles_user_user_permissions" ADD CONSTRAINT "profiles_user_user_p_user_id_d22af5be_fk_profiles_" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table properties
-- ----------------------------
ALTER TABLE "public"."properties" ADD CONSTRAINT "properties_aaaabbbb_fk_propertygroup_a" FOREIGN KEY ("propertygroup_id") REFERENCES "public"."propertygroups" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."properties" ADD CONSTRAINT "properties_aaaabbbb_fk_propertyvalue_a" FOREIGN KEY ("propertyvalue_id") REFERENCES "public"."propertyvalue" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."properties" ADD CONSTRAINT "properties_aaaabbbb_fk_propertyvaluekind_a" FOREIGN KEY ("propertyvaluekind_id") REFERENCES "public"."propertyvalue" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table propertyvalue
-- ----------------------------
ALTER TABLE "public"."propertyvalue" ADD CONSTRAINT "propertyvalue_aaaabbbb_fk_propertyvaluekind_a" FOREIGN KEY ("propertyvaluekind_id") REFERENCES "public"."propertyvalue" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table tasks_properties
-- ----------------------------
ALTER TABLE "public"."tasks_properties" ADD CONSTRAINT "tasks_properties_aaaabbbb_fk_company_a" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_properties" ADD CONSTRAINT "tasks_properties_aaaabbbb_fk_profilesuser_a" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_properties" ADD CONSTRAINT "tasks_properties_aaaabbbb_fk_property_a" FOREIGN KEY ("property_id") REFERENCES "public"."properties" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_properties" ADD CONSTRAINT "tasks_properties_aaaabbbb_fk_task_a" FOREIGN KEY ("task_id") REFERENCES "public"."tasks_task" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_properties" ADD CONSTRAINT "tasks_properties_aaaabbbb_fk_tasktemplate_properties_a" FOREIGN KEY ("template_property_id") REFERENCES "public"."tasks_tasktemplate_properties" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table tasks_task
-- ----------------------------
ALTER TABLE "public"."tasks_task" ADD CONSTRAINT "tasks_task_company_id_f699f141_fk_companies_company_id" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_task" ADD CONSTRAINT "tasks_task_recurrency_id_44b7f17b_fk_tasks_taskrecurrency_id" FOREIGN KEY ("recurrency_id") REFERENCES "public"."tasks_taskrecurrency" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_task" ADD CONSTRAINT "tasks_task_shift_id_bc303916_fk_companies_shift_id" FOREIGN KEY ("shift_id") REFERENCES "public"."companies_shift" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_task" ADD CONSTRAINT "tasks_task_signed_by_id_54b25a58_fk_profiles_user_id" FOREIGN KEY ("signed_by_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_task" ADD CONSTRAINT "tasks_task_template_id_4c7816ef_fk_tasks_tasktemplate_id" FOREIGN KEY ("template_id") REFERENCES "public"."tasks_tasktemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_task" ADD CONSTRAINT "tasks_task_time_realized_by_id_a3da60f5_fk_profiles_user_id" FOREIGN KEY ("time_realized_by_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table tasks_taskrecurrency
-- ----------------------------
ALTER TABLE "public"."tasks_taskrecurrency" ADD CONSTRAINT "tasks_taskrecurrency_area_id_8a424fab_fk_companies_area_id" FOREIGN KEY ("area_id") REFERENCES "public"."companies_area" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_taskrecurrency" ADD CONSTRAINT "tasks_taskrecurrency_company_id_f0c77a81_fk_companies" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_taskrecurrency" ADD CONSTRAINT "tasks_taskrecurrency_shift_id_e95b64d8_fk_companies_shift_id" FOREIGN KEY ("shift_id") REFERENCES "public"."companies_shift" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_taskrecurrency" ADD CONSTRAINT "tasks_taskrecurrency_template_id_a8883c2c_fk_tasks_tas" FOREIGN KEY ("template_id") REFERENCES "public"."tasks_tasktemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table tasks_taskrecurrency_one_time_shifts
-- ----------------------------
ALTER TABLE "public"."tasks_taskrecurrency_one_time_shifts" ADD CONSTRAINT "tasks_taskrecurrency_shift_id_8624b72d_fk_companies" FOREIGN KEY ("shift_id") REFERENCES "public"."companies_shift" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_taskrecurrency_one_time_shifts" ADD CONSTRAINT "tasks_taskrecurrency_taskrecurrency_id_d4987e51_fk_tasks_tas" FOREIGN KEY ("taskrecurrency_id") REFERENCES "public"."tasks_taskrecurrency" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table tasks_taskrecurrency_shifts
-- ----------------------------
ALTER TABLE "public"."tasks_taskrecurrency_shifts" ADD CONSTRAINT "tasks_taskrecurrency_shift_id_fb0a028e_fk_companies" FOREIGN KEY ("shift_id") REFERENCES "public"."companies_shift" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_taskrecurrency_shifts" ADD CONSTRAINT "tasks_taskrecurrency_taskrecurrency_id_d7cdefac_fk_tasks_tas" FOREIGN KEY ("taskrecurrency_id") REFERENCES "public"."tasks_taskrecurrency" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table tasks_taskstatusrecord
-- ----------------------------
ALTER TABLE "public"."tasks_taskstatusrecord" ADD CONSTRAINT "tasks_taskstatusreco_signed_by_id_dcd344a5_fk_profiles_" FOREIGN KEY ("signed_by_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_taskstatusrecord" ADD CONSTRAINT "tasks_taskstatusrecord_task_id_3c97c8b6_fk_tasks_task_id" FOREIGN KEY ("task_id") REFERENCES "public"."tasks_task" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table tasks_tasktemplate
-- ----------------------------
ALTER TABLE "public"."tasks_tasktemplate" ADD CONSTRAINT "tasks_tasktemplate_area_id_ea70ab9c_fk_companies_area_id" FOREIGN KEY ("area_id") REFERENCES "public"."companies_area" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_tasktemplate" ADD CONSTRAINT "tasks_tasktemplate_company_id_97507168_fk_companies_company_id" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table tasks_tasktemplate_properties
-- ----------------------------
ALTER TABLE "public"."tasks_tasktemplate_properties" ADD CONSTRAINT "tasks_tasktemplate_properties_aaaabbbb_fk_company_a" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_tasktemplate_properties" ADD CONSTRAINT "tasks_tasktemplate_properties_aaaabbbb_fk_property_a" FOREIGN KEY ("property_id") REFERENCES "public"."properties" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_tasktemplate_properties" ADD CONSTRAINT "tasks_tasktemplate_properties_aaaabbbb_fk_propertyvalue_a" FOREIGN KEY ("propertyvalue_id") REFERENCES "public"."propertyvalue" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_tasktemplate_properties" ADD CONSTRAINT "tasks_tasktemplate_properties_aaaabbbb_fk_tasktemplate_a" FOREIGN KEY ("tasktemplate_id") REFERENCES "public"."tasks_tasktemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table tasks_tasktemplate_tags_links
-- ----------------------------
ALTER TABLE "public"."tasks_tasktemplate_tags_links" ADD CONSTRAINT "tasks_tasktemplate_t_tasktemplate_id_d2885edf_fk_tasks_tas" FOREIGN KEY ("tasktemplate_id") REFERENCES "public"."tasks_tasktemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."tasks_tasktemplate_tags_links" ADD CONSTRAINT "tasks_tasktemplate_t_tasktemplatetag_id_91177e5e_fk_tasks_tas" FOREIGN KEY ("tasktemplatetag_id") REFERENCES "public"."tasks_tasktemplatetag" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table tasks_tasktemplatestep
-- ----------------------------
ALTER TABLE "public"."tasks_tasktemplatestep" ADD CONSTRAINT "tasks_tasktemplatest_template_id_4247b8b7_fk_tasks_tas" FOREIGN KEY ("template_id") REFERENCES "public"."tasks_tasktemplate" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table tasks_tasktemplatetag
-- ----------------------------
ALTER TABLE "public"."tasks_tasktemplatetag" ADD CONSTRAINT "tasks_tasktemplateta_company_id_70d4a727_fk_companies" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;

-- ----------------------------
-- Foreign Keys structure for table uploads_requesteds3link
-- ----------------------------
ALTER TABLE "public"."uploads_requesteds3link" ADD CONSTRAINT "uploads_requesteds3l_company_id_40d5a4fa_fk_companies" FOREIGN KEY ("company_id") REFERENCES "public"."companies_company" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."uploads_requesteds3link" ADD CONSTRAINT "uploads_requesteds3link_user_id_d6b07602_fk_profiles_user_id" FOREIGN KEY ("user_id") REFERENCES "public"."profiles_user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
